{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { HitTypes, DataTypes, WPC } from \"../resources/Constants.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DataParser {\n  constructor() {}\n  static init(romData) {\n    if (DataParser.instance) {\n      return this.instance;\n    }\n    this.instance = new DataParser();\n    return this.instance;\n  }\n  static initTableAddrs(dataType) {\n    let Page;\n    let PageByteIdx;\n    let HitTablePtr;\n    let HitPagePtr;\n    let RomAddr;\n    let WpcAddr;\n    let Ptr = 0;\n    logStr(`Searching ROM for Master Animation Table Address`);\n    for (Page = 0; Page < ROM.totalPages; Page++) {\n      for (PageByteIdx = 0; PageByteIdx < WPC.PageLength; PageByteIdx++) {\n        switch (ROM.byteAtAddr(Ptr++) & 0xFF) {\n          case 0xBE:\n            if (PageByteIdx >= WPC.PageLength - 16) {\n              break;\n            }\n            if ((ROM.byteAtAddr(Ptr + 2) & 0xff) == 0x3a && (ROM.byteAtAddr(Ptr + 3) & 0xff) == 0x58 && (ROM.byteAtAddr(Ptr + 4) & 0xff) == 0x3a && (ROM.byteAtAddr(Ptr + 5) & 0xff) == 0xd6 && (ROM.byteAtAddr(Ptr + 7) & 0xff) == 0x34 && (ROM.byteAtAddr(Ptr + 8) & 0xff) == 0x04 && ((ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xf6 || (ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xbd) && ((ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xbd || (ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xf6)) {\n              HitTablePtr = Ptr;\n              HitPagePtr = Ptr + 2;\n              RomAddr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n              if (RomAddr == -1) {\n                logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Font Table Pointer opcode: ${toHex(HitTablePtr & 0xFF)} ${toHex(HitTablePtr + 1 & 0xFF)}`);\n                return -1;\n              }\n              logStr(`Address in ROM of Font Table Pointer ${toHex(RomAddr)}`);\n              if (dataType == DataTypes.FontData) {\n                VariableSizedImageData.TableAddress = DataParser.processHitType(HitTypes.AddrAddr, HitTablePtr, HitPagePtr, Ptr);\n                if (VariableSizedImageData.TableAddress == -1) {\n                  logStr(`Error from ProcessHitType while trying to process Font Table Pointer opcode: ${toHex(HitTablePtr & 0xFF)} ${toHex(HitTablePtr + 1 & 0xFF)}`);\n                  break;\n                }\n                logStr(`Found Address in ROM of Font Table ${toHex(VariableSizedImageData.TableAddress)}`);\n              }\n              HitTablePtr = RomAddr;\n              HitPagePtr = RomAddr + 2;\n              WpcAddr = (ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff) & 0xffff;\n              if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom && WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength && ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                RomAddr += 2;\n              } else {\n                RomAddr += 3;\n              }\n              logStr(`Address in ROM of Graphics Table Pointer ${toHex(RomAddr)}`);\n              HitTablePtr = RomAddr;\n              HitPagePtr = RomAddr + 2;\n              FullFrameImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n              if (FullFrameImageData.TableAddress == -1) {\n                logStr(`Error from processHitType while trying to process Graphic Table Pointer: ${toHex(HitTablePtr & 0xFF)} ${toHex(HitTablePtr + 1 & 0xFF)}`);\n                if (dataType == DataTypes.FontData) {\n                  return 0;\n                }\n                return -1;\n              }\n              logStr(`Found Address in ROM of Graphics Table ${toHex(FullFrameImageData.TableAddress)}`);\n              if (dataType != DataTypes.AniData) {\n                return 0;\n              }\n              HitTablePtr = ROM.byteAtAddr(RomAddr);\n              HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n              WpcAddr = (ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff) & 0xffff;\n              if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom && WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength && ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                RomAddr += 2;\n              } else {\n                RomAddr += 3;\n              }\n              logStr(`Address in ROM of Animation Table Pointer ${toHex(RomAddr)}`);\n              HitTablePtr = ROM.byteAtAddr(RomAddr);\n              HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n              VariableSizedImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n              if (VariableSizedImageData.TableAddress == -1) {\n                logStr(`Error from processHitType while trying to process Animation Table Pointer: ${HitTablePtr & 0xFF} ${HitTablePtr + 1 & 0xFF}`);\n                return -1;\n              }\n              logStr(`Found Address in ROM of Animation Table ${toHex(VariableSizedImageData.TableAddress)}`);\n              ROM.startPtr = Ptr;\n              return 0;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n  static getFirstImageIndex(TableIndex) {\n    const imageIndex = this.getNextImageIndex(0, TableIndex);\n    if (imageIndex == -1) {\n      return -1;\n    }\n    VariableSizedImageData.CurrentImageIndex = imageIndex;\n    return imageIndex;\n  }\n  static getNextImageIndex(pImageIndex, TableIndex) {\n    let Addr;\n    let Ptr;\n    let ImageIndexMin;\n    let ImageIndexMax;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    Ptr = Addr;\n    while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n      ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n      ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if ((pImageIndex & 0xFF) < (ImageIndexMin & 0xFF)) {\n        return ImageIndexMin;\n      }\n      if ((pImageIndex & 0xFF) < (ImageIndexMax & 0xFF)) {\n        return pImageIndex + 1;\n      }\n    }\n    return -1;\n  }\n  static getLastImageIndex(pImageIndex, TableIndex) {\n    let ImageIndex = 0;\n    let hit = 0;\n    let counter = 0;\n    while (ImageIndex != -1) {\n      ImageIndex = this.getNextImageIndex(ImageIndex, TableIndex);\n      counter++;\n      if (ImageIndex != -1) {\n        pImageIndex = ImageIndex;\n      }\n      hit = 1;\n    }\n    if (hit == 0) {\n      return -1;\n    }\n    return pImageIndex;\n  }\n  static getPrevImageIndex(pImageIndex, TableIndex) {\n    let Addr;\n    let Ptr;\n    let ImageIndexMin;\n    let ImageIndexMax;\n    let windUp;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    if (pImageIndex == null) {\n      return -1;\n    }\n    Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    Ptr = Addr;\n    windUp = 0;\n    while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n      Ptr += 2;\n      windUp++;\n    }\n    while (windUp != 0) {\n      Ptr -= 2;\n      windUp--;\n      ImageIndexMin = ROM.byteAtAddr(Ptr) & 0xFF;\n      ImageIndexMax = ROM.byteAtAddr(Ptr + 1) & 0xFF;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if ((pImageIndex & 0xFF) > (ImageIndexMax & 0xFF)) {\n        pImageIndex = ImageIndexMax;\n        return pImageIndex;\n      }\n      if ((pImageIndex & 0xFF) > (ImageIndexMin & 0xFF)) {\n        pImageIndex = pImageIndex - 1;\n        return pImageIndex;\n      }\n    }\n    return -1;\n  }\n  static getROMAddressOfVariableSizedImageTable(TableIndex) {\n    const result = this.extractWPCAddrAndPageOfImageTable(TableIndex);\n    const Addr = result[0];\n    const Page = result[1];\n    if (Addr == -1) {\n      return -1;\n    }\n    const romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (romAddr == -1) {\n      return -1;\n    }\n    return romAddr;\n  }\n  static extractWPCAddrAndPageOfImageTable(TableIndex) {\n    let romAddr;\n    let Ptr;\n    let Addr;\n    let Page;\n    if (!VariableSizedImageData.TableAddress) {\n      return [-1, -1];\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return [-1, -1];\n    }\n    if (VariableSizedImageData.CurrentTableIndex < VariableSizedImageData.minTableIndex || VariableSizedImageData.CurrentTableIndex > VariableSizedImageData.maxTableIndex) {\n      return [-1, -1];\n    }\n    romAddr = DataParser.getAddrToWPCAddressOfVariableSizedImageTable(TableIndex);\n    if (romAddr == -1) {\n      return [-1, -1];\n    }\n    Ptr = romAddr;\n    Addr = ROM.byteAtAddr(Ptr) & 0xff;\n    Addr = Addr << 8;\n    Addr = Addr | ROM.byteAtAddr(Ptr + 1) & 0xff;\n    Addr = Addr & 0xffff;\n    Page = ROM.byteAtAddr(Ptr + 2) & 0xff;\n    {\n      let TempAddr;\n      let TempPage;\n      romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n      if (romAddr == -1) {\n        return [-1, -1];\n      }\n      Ptr = romAddr;\n      TempAddr = ROM.byteAtAddr(Ptr) & 0xff;\n      TempAddr = TempAddr << 8;\n      TempAddr = TempAddr | ROM.byteAtAddr(Ptr + 1) & 0xff;\n      TempAddr = TempAddr & 0xffff;\n      TempPage = ROM.byteAtAddr(Ptr + 2) & 0xff;\n      logStr(`Testing Tempaddr ${toHex(TempAddr)} and Page ${toHex(TempPage)}`);\n      if (TempAddr >= WPC.BaseCodeAddrPagedRom && TempAddr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) {\n        Addr = TempAddr;\n      }\n      logStr(`extractWPCAddrAndPageOfImageTable() FIXUP, Addr fixed to ${toHex(Addr)},${toHex(Page)}`);\n    }\n    return [Addr, Page];\n  }\n  static getROMAddressFromWPCAddrAndPage(Addr, Page) {\n    let romAddr;\n    if (Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      if (Page != WPC.NonpagedBankIndicator) {\n        logStr(`getROMAddressFromWPCAddrAndPage() Non-banked WPC addr ${Addr} followed by page byte ${Page}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n        Page = WPC.NonpagedBankIndicator;\n      }\n    }\n    if (Page == WPC.NonpagedBankIndicator && Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      romAddr = (ROM.totalPages - 2) * WPC.PageLength + (Addr - WPC.BaseCodeAddrNonpagedRom);\n    } else if (Page >= ROM.basePageIndex && Page < ROM.basePageIndex + ROM.totalPages - 2 && Addr >= WPC.BaseCodeAddrPagedRom && Addr < WPC.BaseCodeAddrNonpagedRom) {\n      romAddr = (Page - ROM.basePageIndex) * WPC.PageLength + (Addr - WPC.BaseCodeAddrPagedRom);\n    } else {\n      logStr(`Invalid WPC Addr and Page, ${toHex(Addr)},${toHex(Page)}, BasePage ${toHex(ROM.basePageIndex)}, TotalPages ${ROM.totalPages}`);\n      return -1;\n    }\n    if (romAddr >= ROM.size) {\n      logStr(`Unexpected: Calculated addr in ROM ${romAddr} is greater than determined ROM size ${ROM.size}`);\n      return -1;\n    }\n    return romAddr;\n  }\n  static getAddrToWPCAddressOfVariableSizedImageTable(TableIndex) {\n    let romAddr;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    romAddr = VariableSizedImageData.TableAddress + 3 * TableIndex;\n    if (romAddr >= ROM.size) {\n      return -1;\n    }\n    return romAddr;\n  }\n  static getROMAddressFromAddrOf3ByteWPCAddrPage(pSrc) {\n    let Addr;\n    let Page;\n    const result = DataParser.extractWPCAddrAndPageFromBuffer(pSrc);\n    Addr = result[0];\n    Page = result[1];\n    if (Addr == -1) {\n      logStr(`Error from ExtractWPCAddrAndPageFromBuffer(), Passed it ptr to: ${ROM.byteAtAddr(pSrc) & 0xFF} ${ROM.byteAtAddr(pSrc + 1) & 0xFF} ${ROM.byteAtAddr(pSrc + 2) & 0xFF}`);\n      return -1;\n    }\n    logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() WPC TableAddress ${toHex(Addr)},${toHex(Page)}`);\n    Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (Addr == -1) {\n      logStr(`Error from getROMAddressFromWPCAddrAndPage(), Passed it WPC Addr ${Addr},${Page}`);\n      return -1;\n    }\n    logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() ROM TableAddress ${toHex(Addr)}`);\n    return Addr;\n  }\n  static getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex) {\n    let Addr;\n    let Page;\n    let Ptr;\n    let TableHeight;\n    let TableSpacing;\n    let ImageIndexMin, ImageIndexMax, ImageNum, ImageFound;\n    Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    if (Addr >= ROM.size) {\n      return -1;\n    }\n    Ptr = Addr;\n    ImageNum = ImageFound = 0;\n    while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n      ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n      ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if (ImageFound == 0) {\n        while (ImageIndexMin <= ImageIndexMax) {\n          if (ImageIndex <= ImageIndexMin) {\n            logStr(`getROMAddressOfVariableSizedImageIndex() ImageFound, ImageNum ${ImageNum}, ImageIndexMin ${ImageIndexMin}, ImageIndexMax ${ImageIndexMax}`);\n            ImageFound = 1;\n            break;\n          }\n          ImageNum++;\n          ImageIndexMin++;\n        }\n      }\n    }\n    Ptr++;\n    TableHeight = ROM.byteAtAddr(Ptr++);\n    TableSpacing = ROM.byteAtAddr(Ptr++);\n    Ptr += ImageNum * 2;\n    Addr = ROM.byteAtAddr(Ptr) & 0xFF;\n    Addr = Addr << 8;\n    Addr |= ROM.byteAtAddr(Ptr + 1) & 0xFF;\n    Addr &= 0xFFFF;\n    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n    Page = result[1];\n    if (Page == -1) {\n      return -1;\n    }\n    Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (Addr == -1) {\n      return -1;\n    }\n    logStr(`getROMAddressOfVariableSizedImageIndex() TableHeight ${TableHeight}, TableSpacing ${TableSpacing} ImageIndex ${ImageIndex} at ${Addr}`);\n    return Addr;\n  }\n  static extractWPCAddrAndPageFromBuffer(pSrc) {\n    let Addr;\n    let Page;\n    Addr = ROM.byteAtAddr(pSrc) & 0xff;\n    Addr = Addr << 8;\n    Addr = Addr | ROM.byteAtAddr(pSrc + 1) & 0xff;\n    Addr = Addr & 0xffff;\n    Page = ROM.byteAtAddr(pSrc + 2) & 0xff;\n    if (Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      if (Page != WPC.NonpagedBankIndicator) {\n        logStr(`extractWPCAddrAndPageFromBuffer() Non-banked WPC addr ${toHex(Addr)} followed by page byte ${toHex(Page)}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n        Page = WPC.NonpagedBankIndicator;\n      }\n    }\n    if (Addr != null) {\n      if (Addr >= WPC.BaseCodeAddrPagedRom && Addr < WPC.BaseCodeAddrPagedRom + WPC.PageLength || Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {} else {\n        logStr(`Expected a WPC Addr, but read ${toHex(Addr)}`);\n        return [-1, -1];\n      }\n    }\n    if (Page != null) {\n      if (Page >= ROM.basePageIndex && Page < ROM.basePageIndex + ROM.totalPages || Page == WPC.NonpagedBankIndicator) {} else {\n        logStr(`Expected a WPC Page Number, but read ${Page}, Base is ${ROM.basePageIndex}, Total Pages ${ROM.totalPages}`);\n        return [-1, -1];\n      }\n    }\n    return [Addr, Page];\n  }\n  static processHitType(HitType, HitTablePtr, HitPagePtr, Ptr) {\n    let Addr;\n    let HitBuf = [0, 0, 0];\n    let pTbl;\n    switch (HitType) {\n      case HitTypes.AddrAddrAddr:\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xFF)}`);\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n        if (Addr == -1) {\n          logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xFF} ${HitTablePtr + 1 & 0xFF}`);\n          return -1;\n        }\n        logStr(`HitTypes.AddrAddrAddr derived ROM TableAddressAddress ${Addr}, going to HitTypes.AddrAddr`);\n        HitTablePtr = ROM.byteAtAddr(Addr);\n      case HitTypes.AddrAddr:\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xFF)}`);\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n        if (Addr == -1) {\n          logStr(`Error from GetROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xFF} ${HitTablePtr + 1 & 0xFF}`);\n          return -1;\n        }\n        logStr(`HitTypes.AddrAddr derived TableAddress of ${toHex(Addr)} going to HitTypes.Addr`);\n        HitTablePtr = Addr;\n        HitPagePtr = Addr + 2;\n      case HitTypes.Addr:\n        if (HitTablePtr == null) {\n          logStr(\"HitTypes.Addr, but HitTablePtr is NULL\");\n          return -1;\n        }\n        HitBuf[0] = HitTablePtr;\n        HitBuf[1] = HitTablePtr + 1;\n        if (HitPagePtr == null) {\n          let Addr;\n          Addr = HitBuf[0] & 0xff;\n          Addr = Addr << 8;\n          Addr = Addr | HitBuf[1] & 0xff;\n          Addr = Addr & 0xffff;\n          if (!(Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n            logStr(`HitTypes.Addr, but HitPagePtr is NULL, and Addr is in paged ROM`);\n            return -1;\n          }\n          HitBuf[2] = WPC.NonpagedBankIndicator;\n        } else {\n          HitBuf[2] = ROM.byteAtAddr(HitPagePtr);\n        }\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitBuf[0]) & 0xFF)} ${toHex(ROM.byteAtAddr(HitBuf[1]) & 0xFF)} ${toHex(HitBuf[2] & 0xFF)}`);\n        pTbl = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitBuf[0]);\n        if (pTbl != -1) {\n          logStr(\"Table Found!\");\n          return pTbl;\n        }\n        logStr(`Error deriving table addr from hit, HitType ${Ptr - 1 & 0xFF}, HitBytes ${HitBuf[0] & 0xFF} ${HitBuf[1] & 0xFF} ${HitBuf[2] & 0xFF}. Will keep looking. May need to debug by opening window while pressing <shift>`);\n        break;\n      case HitTypes.None:\n        return 0;\n      default:\n        logStr(\"Unexpected HitType\");\n        break;\n    }\n    return -1;\n  }\n  static preAnalyzeVariableSizedImageTable() {\n    let Ptr;\n    let Addr;\n    let TableCount = 0;\n    ROM.vSImageTableMap = [[0]];\n    if (!VariableSizedImageData.TableAddress) {\n      logStr(`Unexpected NULL ${VariableSizedImageData.TableAddress}`);\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      logStr(`Unexpected table address ${VariableSizedImageData.TableAddress} is >= ${ROM.size}`);\n    }\n    Ptr = VariableSizedImageData.TableAddress;\n    let continueLooping = true;\n    while (continueLooping) {\n      Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Ptr);\n      if (Addr == -1) {\n        continueLooping = false;\n      } else {\n        VariableSizedImageData.maxTableIndex++;\n        const ImageIndex = DataParser.getLastImageIndex(-1, VariableSizedImageData.maxTableIndex - 1);\n        ROM.vSImageTableMap[VariableSizedImageData.maxTableIndex - 1].push(ImageIndex);\n        if (ImageIndex == -1) {\n          VariableSizedImageData.maxTableIndex--;\n          logStr(`Stopped looking for image tables due to getLastImageIndex() error on TableIndex ${VariableSizedImageData.maxTableIndex}`);\n          continueLooping = false;\n        }\n        Ptr += 3;\n        TableCount++;\n      }\n    }\n    logStr(`Determined TableCount: ${TableCount}%d`);\n    if (TableCount == 0) {\n      logStr(\"Found 0 table entries\");\n      return -1;\n    }\n    VariableSizedImageData.minTableIndex = 0;\n    VariableSizedImageData.maxTableIndex = TableCount - 1;\n    VariableSizedImageData.maxImageIndex = DataParser.getLastImageIndex(VariableSizedImageData.maxImageIndex, VariableSizedImageData.maxTableIndex);\n    if (VariableSizedImageData.maxImageIndex == -1) {\n      logStr(`Error looking up max image index for last table index ${VariableSizedImageData.maxTableIndex}`);\n      return -1;\n    }\n    VariableSizedImageData.minImageIndex = DataParser.getFirstImageIndex(VariableSizedImageData.minTableIndex);\n    if (VariableSizedImageData.minTableIndex == -1) {\n      logStr(`Error looking up min image index for first table index ${VariableSizedImageData.maxTableIndex})`);\n      return -1;\n    }\n    logStr(`Determined maxTableIndex ${VariableSizedImageData.maxTableIndex}, maxImageIndex ${VariableSizedImageData.maxImageIndex}`);\n    return 0;\n  }\n  static getVariableSizedImageTableMetadata(TableIndex) {\n    let Addr;\n    let Ptr;\n    let TableHeight;\n    let TableSpacing;\n    Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return [-1, -1];\n    }\n    if (Addr >= ROM.size) {\n      return [-1, -1];\n    }\n    Ptr = Addr;\n    while ((ROM.byteAtAddr(Ptr++) & 0xFF) != 0x00);\n    TableHeight = ROM.byteAtAddr(Ptr++);\n    TableSpacing = ROM.byteAtAddr(Ptr++);\n    return [TableHeight, TableSpacing];\n  }\n}","map":{"version":3,"names":["HitTypes","DataTypes","WPC","toHex","logStr","VariableSizedImageData","FullFrameImageData","ROM","DataParser","constructor","init","romData","instance","initTableAddrs","dataType","Page","PageByteIdx","HitTablePtr","HitPagePtr","RomAddr","WpcAddr","Ptr","totalPages","PageLength","byteAtAddr","getROMAddressFromAddrOf3ByteWPCAddrPage","FontData","TableAddress","processHitType","AddrAddr","BaseCodeAddrNonpagedRom","NonpagedLength","NonpagedBankIndicator","Addr","AniData","startPtr","getFirstImageIndex","TableIndex","imageIndex","getNextImageIndex","CurrentImageIndex","pImageIndex","ImageIndexMin","ImageIndexMax","size","minTableIndex","maxTableIndex","getROMAddressOfVariableSizedImageTable","getLastImageIndex","ImageIndex","hit","counter","getPrevImageIndex","windUp","result","extractWPCAddrAndPageOfImageTable","romAddr","getROMAddressFromWPCAddrAndPage","CurrentTableIndex","getAddrToWPCAddressOfVariableSizedImageTable","TempAddr","TempPage","BaseCodeAddrPagedRom","basePageIndex","pSrc","extractWPCAddrAndPageFromBuffer","getROMAddressOfVariableSizedImageIndex","TableHeight","TableSpacing","ImageNum","ImageFound","HitType","HitBuf","pTbl","AddrAddrAddr","None","preAnalyzeVariableSizedImageTable","TableCount","vSImageTableMap","continueLooping","push","maxImageIndex","minImageIndex","getVariableSizedImageTableMetadata"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/node_modules/wpcedit/dist/classes/DataParser.js"],"sourcesContent":["import { HitTypes, DataTypes, WPC } from \"../resources/Constants.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DataParser {\n    constructor() {\n    }\n    static init(romData) {\n        if (DataParser.instance) {\n            return this.instance;\n        }\n        this.instance = new DataParser();\n        return this.instance;\n    }\n    static initTableAddrs(dataType) {\n        let Page;\n        let PageByteIdx;\n        let HitTablePtr;\n        let HitPagePtr;\n        let RomAddr;\n        let WpcAddr;\n        let Ptr = 0;\n        logStr(`Searching ROM for Master Animation Table Address`);\n        for (Page = 0; Page < ROM.totalPages; Page++) {\n            for (PageByteIdx = 0; PageByteIdx < WPC.PageLength; PageByteIdx++) {\n                switch (ROM.byteAtAddr(Ptr++) & 0xFF) {\n                    case 0xBE:\n                        if (PageByteIdx >= WPC.PageLength - 16) {\n                            break;\n                        }\n                        if ((ROM.byteAtAddr(Ptr + 2) & 0xff) == 0x3a &&\n                            (ROM.byteAtAddr(Ptr + 3) & 0xff) == 0x58 &&\n                            (ROM.byteAtAddr(Ptr + 4) & 0xff) == 0x3a &&\n                            (ROM.byteAtAddr(Ptr + 5) & 0xff) == 0xd6 &&\n                            (ROM.byteAtAddr(Ptr + 7) & 0xff) == 0x34 &&\n                            (ROM.byteAtAddr(Ptr + 8) & 0xff) == 0x04 &&\n                            ((ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xf6 || (ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xbd) &&\n                            ((ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xbd || (ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xf6)) {\n                            HitTablePtr = Ptr;\n                            HitPagePtr = Ptr + 2;\n                            RomAddr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                            if (RomAddr == -1) {\n                                logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Font Table Pointer opcode: ${toHex((HitTablePtr) & 0xFF)} ${toHex(((HitTablePtr + 1)) & 0xFF)}`);\n                                return -1;\n                            }\n                            logStr(`Address in ROM of Font Table Pointer ${toHex(RomAddr)}`);\n                            if (dataType == DataTypes.FontData) {\n                                VariableSizedImageData.TableAddress = DataParser.processHitType(HitTypes.AddrAddr, HitTablePtr, HitPagePtr, Ptr);\n                                if (VariableSizedImageData.TableAddress == -1) {\n                                    logStr(`Error from ProcessHitType while trying to process Font Table Pointer opcode: ${toHex((HitTablePtr) & 0xFF)} ${toHex(((HitTablePtr + 1)) & 0xFF)}`);\n                                    break;\n                                }\n                                logStr(`Found Address in ROM of Font Table ${toHex(VariableSizedImageData.TableAddress)}`);\n                            }\n                            HitTablePtr = RomAddr;\n                            HitPagePtr = RomAddr + 2;\n                            WpcAddr =\n                                ((ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff)) &\n                                    0xffff;\n                            if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom &&\n                                WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength &&\n                                ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                                RomAddr += 2;\n                            }\n                            else {\n                                RomAddr += 3;\n                            }\n                            logStr(`Address in ROM of Graphics Table Pointer ${toHex(RomAddr)}`);\n                            HitTablePtr = (RomAddr);\n                            HitPagePtr = (RomAddr + 2);\n                            FullFrameImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n                            if (FullFrameImageData.TableAddress == -1) {\n                                logStr(`Error from processHitType while trying to process Graphic Table Pointer: ${toHex((HitTablePtr) & 0xFF)} ${toHex(((HitTablePtr + 1)) & 0xFF)}`);\n                                if (dataType == DataTypes.FontData) {\n                                    return 0;\n                                }\n                                return -1;\n                            }\n                            logStr(`Found Address in ROM of Graphics Table ${toHex(FullFrameImageData.TableAddress)}`);\n                            if (dataType != DataTypes.AniData) {\n                                return 0;\n                            }\n                            HitTablePtr = ROM.byteAtAddr(RomAddr);\n                            HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n                            WpcAddr =\n                                ((ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff)) &\n                                    0xffff;\n                            if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom &&\n                                WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength &&\n                                ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                                RomAddr += 2;\n                            }\n                            else {\n                                RomAddr += 3;\n                            }\n                            logStr(`Address in ROM of Animation Table Pointer ${toHex(RomAddr)}`);\n                            HitTablePtr = ROM.byteAtAddr(RomAddr);\n                            HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n                            VariableSizedImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n                            if (VariableSizedImageData.TableAddress == -1) {\n                                logStr(`Error from processHitType while trying to process Animation Table Pointer: ${(HitTablePtr) & 0xFF} ${((HitTablePtr + 1)) & 0xFF}`);\n                                return -1;\n                            }\n                            logStr(`Found Address in ROM of Animation Table ${toHex(VariableSizedImageData.TableAddress)}`);\n                            ROM.startPtr = Ptr;\n                            return 0;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n    static getFirstImageIndex(TableIndex) {\n        const imageIndex = this.getNextImageIndex(0, TableIndex);\n        if (imageIndex == -1) {\n            return -1;\n        }\n        VariableSizedImageData.CurrentImageIndex = imageIndex;\n        return imageIndex;\n    }\n    static getNextImageIndex(pImageIndex, TableIndex) {\n        let Addr;\n        let Ptr;\n        let ImageIndexMin;\n        let ImageIndexMax;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if ((TableIndex < VariableSizedImageData.minTableIndex) || (TableIndex > VariableSizedImageData.maxTableIndex)) {\n            return -1;\n        }\n        Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        Ptr = Addr;\n        while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n            ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n            ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if ((pImageIndex & 0xFF) < (ImageIndexMin & 0xFF)) {\n                return ImageIndexMin;\n            }\n            if ((pImageIndex & 0xFF) < (ImageIndexMax & 0xFF)) {\n                return pImageIndex + 1;\n            }\n        }\n        return -1;\n    }\n    static getLastImageIndex(pImageIndex, TableIndex) {\n        let ImageIndex = 0;\n        let hit = 0;\n        let counter = 0;\n        while ((ImageIndex != -1)) {\n            ImageIndex = this.getNextImageIndex(ImageIndex, TableIndex);\n            counter++;\n            if (ImageIndex != -1) {\n                pImageIndex = ImageIndex;\n            }\n            hit = 1;\n        }\n        if (hit == 0) {\n            return -1;\n        }\n        return pImageIndex;\n    }\n    static getPrevImageIndex(pImageIndex, TableIndex) {\n        let Addr;\n        let Ptr;\n        let ImageIndexMin;\n        let ImageIndexMax;\n        let windUp;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if ((TableIndex < VariableSizedImageData.minTableIndex) || (TableIndex > VariableSizedImageData.maxTableIndex)) {\n            return -1;\n        }\n        if (pImageIndex == null) {\n            return -1;\n        }\n        Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        Ptr = Addr;\n        windUp = 0;\n        while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n            Ptr += 2;\n            windUp++;\n        }\n        while (windUp != 0) {\n            Ptr -= 2;\n            windUp--;\n            ImageIndexMin = ROM.byteAtAddr(Ptr) & 0xFF;\n            ImageIndexMax = ROM.byteAtAddr((Ptr + 1)) & 0xFF;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if (((pImageIndex) & 0xFF) > (ImageIndexMax & 0xFF)) {\n                pImageIndex = ImageIndexMax;\n                return pImageIndex;\n            }\n            if (((pImageIndex) & 0xFF) > (ImageIndexMin & 0xFF)) {\n                pImageIndex = (pImageIndex) - 1;\n                return pImageIndex;\n            }\n        }\n        return -1;\n    }\n    static getROMAddressOfVariableSizedImageTable(TableIndex) {\n        const result = this.extractWPCAddrAndPageOfImageTable(TableIndex);\n        const Addr = result[0];\n        const Page = result[1];\n        if (Addr == -1) {\n            return -1;\n        }\n        const romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (romAddr == -1) {\n            return -1;\n        }\n        return romAddr;\n    }\n    static extractWPCAddrAndPageOfImageTable(TableIndex) {\n        let romAddr;\n        let Ptr;\n        let Addr;\n        let Page;\n        if (!VariableSizedImageData.TableAddress) {\n            return [-1, -1];\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return [-1, -1];\n        }\n        if (VariableSizedImageData.CurrentTableIndex <\n            VariableSizedImageData.minTableIndex ||\n            VariableSizedImageData.CurrentTableIndex >\n                VariableSizedImageData.maxTableIndex) {\n            return [-1, -1];\n        }\n        romAddr = DataParser.getAddrToWPCAddressOfVariableSizedImageTable(TableIndex);\n        if (romAddr == -1) {\n            return [-1, -1];\n        }\n        Ptr = romAddr;\n        Addr = ROM.byteAtAddr(Ptr) & 0xff;\n        Addr = Addr << 8;\n        Addr = Addr | (ROM.byteAtAddr(Ptr + 1) & 0xff);\n        Addr = Addr & 0xffff;\n        Page = ROM.byteAtAddr(Ptr + 2) & 0xff;\n        {\n            let TempAddr;\n            let TempPage;\n            romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n            if (romAddr == -1) {\n                return [-1, -1];\n            }\n            Ptr = romAddr;\n            TempAddr = ROM.byteAtAddr(Ptr) & 0xff;\n            TempAddr = TempAddr << 8;\n            TempAddr = TempAddr | (ROM.byteAtAddr(Ptr + 1) & 0xff);\n            TempAddr = TempAddr & 0xffff;\n            TempPage = ROM.byteAtAddr(Ptr + 2) & 0xff;\n            logStr(`Testing Tempaddr ${toHex(TempAddr)} and Page ${toHex(TempPage)}`);\n            if (TempAddr >= WPC.BaseCodeAddrPagedRom &&\n                TempAddr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) {\n                Addr = TempAddr;\n            }\n            logStr(`extractWPCAddrAndPageOfImageTable() FIXUP, Addr fixed to ${toHex(Addr)},${toHex(Page)}`);\n        }\n        return [Addr, Page];\n    }\n    static getROMAddressFromWPCAddrAndPage(Addr, Page) {\n        let romAddr;\n        if (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            if (Page != WPC.NonpagedBankIndicator) {\n                logStr(`getROMAddressFromWPCAddrAndPage() Non-banked WPC addr ${Addr} followed by page byte ${Page}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n                Page = WPC.NonpagedBankIndicator;\n            }\n        }\n        if (Page == WPC.NonpagedBankIndicator &&\n            Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            romAddr =\n                (ROM.totalPages - 2) * WPC.PageLength +\n                    (Addr - WPC.BaseCodeAddrNonpagedRom);\n        }\n        else if (Page >= ROM.basePageIndex &&\n            Page < ROM.basePageIndex + ROM.totalPages - 2 &&\n            Addr >= WPC.BaseCodeAddrPagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom) {\n            romAddr =\n                (Page - ROM.basePageIndex) * WPC.PageLength +\n                    (Addr - WPC.BaseCodeAddrPagedRom);\n        }\n        else {\n            logStr(`Invalid WPC Addr and Page, ${toHex(Addr)},${toHex(Page)}, BasePage ${toHex(ROM.basePageIndex)}, TotalPages ${ROM.totalPages}`);\n            return -1;\n        }\n        if (romAddr >= ROM.size) {\n            logStr(`Unexpected: Calculated addr in ROM ${romAddr} is greater than determined ROM size ${ROM.size}`);\n            return -1;\n        }\n        return romAddr;\n    }\n    static getAddrToWPCAddressOfVariableSizedImageTable(TableIndex) {\n        let romAddr;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if (TableIndex < VariableSizedImageData.minTableIndex ||\n            TableIndex > VariableSizedImageData.maxTableIndex) {\n            return -1;\n        }\n        romAddr = VariableSizedImageData.TableAddress + 3 * TableIndex;\n        if (romAddr >= ROM.size) {\n            return -1;\n        }\n        return romAddr;\n    }\n    static getROMAddressFromAddrOf3ByteWPCAddrPage(pSrc) {\n        let Addr;\n        let Page;\n        const result = DataParser.extractWPCAddrAndPageFromBuffer((pSrc));\n        Addr = result[0];\n        Page = result[1];\n        if (Addr == -1) {\n            logStr(`Error from ExtractWPCAddrAndPageFromBuffer(), Passed it ptr to: ${ROM.byteAtAddr(pSrc) & 0xFF} ${(ROM.byteAtAddr(pSrc + 1)) & 0xFF} ${(ROM.byteAtAddr(pSrc + 2)) & 0xFF}`);\n            return -1;\n        }\n        logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() WPC TableAddress ${toHex(Addr)},${toHex(Page)}`);\n        Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (Addr == -1) {\n            logStr(`Error from getROMAddressFromWPCAddrAndPage(), Passed it WPC Addr ${Addr},${Page}`);\n            return -1;\n        }\n        logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() ROM TableAddress ${toHex(Addr)}`);\n        return Addr;\n    }\n    static getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex) {\n        let Addr;\n        let Page;\n        let Ptr;\n        let TableHeight;\n        let TableSpacing;\n        let ImageIndexMin, ImageIndexMax, ImageNum, ImageFound;\n        Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        if (Addr >= ROM.size) {\n            return -1;\n        }\n        Ptr = Addr;\n        ImageNum = ImageFound = 0;\n        while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n            ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n            ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if (ImageFound == 0) {\n                while (ImageIndexMin <= ImageIndexMax) {\n                    if (ImageIndex <= ImageIndexMin) {\n                        logStr(`getROMAddressOfVariableSizedImageIndex() ImageFound, ImageNum ${ImageNum}, ImageIndexMin ${ImageIndexMin}, ImageIndexMax ${ImageIndexMax}`);\n                        ImageFound = 1;\n                        break;\n                    }\n                    ImageNum++;\n                    ImageIndexMin++;\n                }\n            }\n        }\n        Ptr++;\n        TableHeight = ROM.byteAtAddr(Ptr++);\n        TableSpacing = ROM.byteAtAddr(Ptr++);\n        Ptr += (ImageNum * 2);\n        Addr = (ROM.byteAtAddr(Ptr)) & 0xFF;\n        Addr = Addr << 8;\n        Addr |= (ROM.byteAtAddr(Ptr + 1)) & 0xFF;\n        Addr &= 0xFFFF;\n        const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n        Page = result[1];\n        if (Page == -1) {\n            return -1;\n        }\n        Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (Addr == -1) {\n            return -1;\n        }\n        logStr(`getROMAddressOfVariableSizedImageIndex() TableHeight ${TableHeight}, TableSpacing ${TableSpacing} ImageIndex ${ImageIndex} at ${Addr}`);\n        return Addr;\n    }\n    static extractWPCAddrAndPageFromBuffer(pSrc) {\n        let Addr;\n        let Page;\n        Addr = ROM.byteAtAddr(pSrc) & 0xff;\n        Addr = Addr << 8;\n        Addr = Addr | ROM.byteAtAddr(pSrc + 1) & 0xff;\n        Addr = Addr & 0xffff;\n        Page = ROM.byteAtAddr(pSrc + 2) & 0xff;\n        if (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            if (Page != WPC.NonpagedBankIndicator) {\n                logStr(`extractWPCAddrAndPageFromBuffer() Non-banked WPC addr ${toHex(Addr)} followed by page byte ${toHex(Page)}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n                Page = WPC.NonpagedBankIndicator;\n            }\n        }\n        if (Addr != null) {\n            if ((Addr >= WPC.BaseCodeAddrPagedRom &&\n                Addr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) ||\n                (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n                    Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n            }\n            else {\n                logStr(`Expected a WPC Addr, but read ${toHex(Addr)}`);\n                return [-1, -1];\n            }\n        }\n        if (Page != null) {\n            if ((Page >= ROM.basePageIndex &&\n                Page < ROM.basePageIndex + ROM.totalPages) ||\n                Page == WPC.NonpagedBankIndicator) {\n            }\n            else {\n                logStr(`Expected a WPC Page Number, but read ${Page}, Base is ${ROM.basePageIndex}, Total Pages ${ROM.totalPages}`);\n                return [-1, -1];\n            }\n        }\n        return [Addr, Page];\n    }\n    static processHitType(HitType, HitTablePtr, HitPagePtr, Ptr) {\n        let Addr;\n        let HitBuf = [0, 0, 0];\n        let pTbl;\n        switch (HitType) {\n            case HitTypes.AddrAddrAddr:\n                logStr(`Potential Match. HitType ${toHex((ROM.byteAtAddr(Ptr - 1)) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex(ROM.byteAtAddr((HitTablePtr + 1)) & 0xFF)}`);\n                Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                if (Addr == -1) {\n                    logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${((HitTablePtr) & 0xFF)} ${((HitTablePtr + 1)) & 0xFF}`);\n                    return -1;\n                }\n                logStr(`HitTypes.AddrAddrAddr derived ROM TableAddressAddress ${Addr}, going to HitTypes.AddrAddr`);\n                HitTablePtr = ROM.byteAtAddr(Addr);\n            case HitTypes.AddrAddr:\n                logStr(`Potential Match. HitType ${toHex((ROM.byteAtAddr(Ptr - 1)) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex((ROM.byteAtAddr(HitTablePtr + 1)) & 0xFF)}`);\n                Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                if (Addr == -1) {\n                    logStr(`Error from GetROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${(HitTablePtr) & 0xFF} ${((HitTablePtr + 1)) & 0xFF}`);\n                    return -1;\n                }\n                logStr(`HitTypes.AddrAddr derived TableAddress of ${toHex(Addr)} going to HitTypes.Addr`);\n                HitTablePtr = Addr;\n                HitPagePtr = Addr + 2;\n            case HitTypes.Addr:\n                if (HitTablePtr == null) {\n                    logStr(\"HitTypes.Addr, but HitTablePtr is NULL\");\n                    return -1;\n                }\n                HitBuf[0] = (HitTablePtr);\n                HitBuf[1] = (HitTablePtr + 1);\n                if (HitPagePtr == null) {\n                    let Addr;\n                    Addr = HitBuf[0] & 0xff;\n                    Addr = Addr << 8;\n                    Addr = Addr | (HitBuf[1] & 0xff);\n                    Addr = Addr & 0xffff;\n                    if (!(Addr >= WPC.BaseCodeAddrNonpagedRom &&\n                        Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n                        logStr(`HitTypes.Addr, but HitPagePtr is NULL, and Addr is in paged ROM`);\n                        return -1;\n                    }\n                    HitBuf[2] = WPC.NonpagedBankIndicator;\n                }\n                else {\n                    HitBuf[2] = ROM.byteAtAddr(HitPagePtr);\n                }\n                logStr(`Potential Match. HitType ${toHex((ROM.byteAtAddr(Ptr - 1)) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitBuf[0]) & 0xFF)} ${toHex(ROM.byteAtAddr((HitBuf[1])) & 0xFF)} ${toHex(((HitBuf[2])) & 0xFF)}`);\n                pTbl = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitBuf[0]);\n                if (pTbl != -1) {\n                    logStr(\"Table Found!\");\n                    return pTbl;\n                }\n                logStr(`Error deriving table addr from hit, HitType ${((Ptr - 1)) & 0xFF}, HitBytes ${(HitBuf[0]) & 0xFF} ${((HitBuf[1])) & 0xFF} ${((HitBuf[2])) & 0xFF}. Will keep looking. May need to debug by opening window while pressing <shift>`);\n                break;\n            case HitTypes.None:\n                return 0;\n            default:\n                logStr(\"Unexpected HitType\");\n                break;\n        }\n        return -1;\n    }\n    static preAnalyzeVariableSizedImageTable() {\n        let Ptr;\n        let Addr;\n        let TableCount = 0;\n        ROM.vSImageTableMap = [[0]];\n        if (!VariableSizedImageData.TableAddress) {\n            logStr(`Unexpected NULL ${VariableSizedImageData.TableAddress}`);\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            logStr(`Unexpected table address ${VariableSizedImageData.TableAddress} is >= ${ROM.size}`);\n        }\n        Ptr = VariableSizedImageData.TableAddress;\n        let continueLooping = true;\n        while (continueLooping) {\n            Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Ptr);\n            if (Addr == -1) {\n                continueLooping = false;\n            }\n            else {\n                VariableSizedImageData.maxTableIndex++;\n                const ImageIndex = DataParser.getLastImageIndex(-1, (VariableSizedImageData.maxTableIndex - 1));\n                ROM.vSImageTableMap[VariableSizedImageData.maxTableIndex - 1].push(ImageIndex);\n                if (ImageIndex == -1) {\n                    VariableSizedImageData.maxTableIndex--;\n                    logStr(`Stopped looking for image tables due to getLastImageIndex() error on TableIndex ${VariableSizedImageData.maxTableIndex}`);\n                    continueLooping = false;\n                }\n                Ptr += 3;\n                TableCount++;\n            }\n        }\n        logStr(`Determined TableCount: ${TableCount}%d`);\n        if (TableCount == 0) {\n            logStr(\"Found 0 table entries\");\n            return -1;\n        }\n        VariableSizedImageData.minTableIndex = 0;\n        VariableSizedImageData.maxTableIndex = (TableCount - 1);\n        VariableSizedImageData.maxImageIndex = DataParser.getLastImageIndex(VariableSizedImageData.maxImageIndex, VariableSizedImageData.maxTableIndex);\n        if (VariableSizedImageData.maxImageIndex == -1) {\n            logStr(`Error looking up max image index for last table index ${VariableSizedImageData.maxTableIndex}`);\n            return -1;\n        }\n        VariableSizedImageData.minImageIndex = DataParser.getFirstImageIndex(VariableSizedImageData.minTableIndex);\n        if (VariableSizedImageData.minTableIndex == -1) {\n            logStr(`Error looking up min image index for first table index ${VariableSizedImageData.maxTableIndex})`);\n            return -1;\n        }\n        logStr(`Determined maxTableIndex ${VariableSizedImageData.maxTableIndex}, maxImageIndex ${VariableSizedImageData.maxImageIndex}`);\n        return 0;\n    }\n    static getVariableSizedImageTableMetadata(TableIndex) {\n        let Addr;\n        let Ptr;\n        let TableHeight;\n        let TableSpacing;\n        Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return [-1, -1];\n        }\n        if (Addr >= ROM.size) {\n            return [-1, -1];\n        }\n        Ptr = (Addr);\n        while ((ROM.byteAtAddr(Ptr++) & 0xFF) != 0x00)\n            ;\n        TableHeight = ROM.byteAtAddr(Ptr++);\n        TableSpacing = ROM.byteAtAddr(Ptr++);\n        return [TableHeight, TableSpacing];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}