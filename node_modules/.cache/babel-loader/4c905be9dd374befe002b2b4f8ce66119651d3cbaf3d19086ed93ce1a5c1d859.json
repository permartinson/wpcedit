{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { DmdDecoder } from \"./DmdDecoder.js\";\nimport { DataTypes, WPC } from \"../resources/Constants.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class VariableSizedImage {\n  static init() {\n    if (VariableSizedImage.instance) {\n      return this.instance;\n    }\n    this.instance = new VariableSizedImage();\n    return this.instance;\n  }\n  constructor() {\n    VariableSizedImageData.init();\n  }\n  prev(steps) {\n    DmdDecoder.decodePreviousIndex(steps, DataTypes.FontData);\n  }\n  next(steps) {\n    DmdDecoder.decodeNextIndex(steps, DataTypes.FontData);\n  }\n  get maxImageIndex() {\n    return VariableSizedImageData.maxImageIndex;\n  }\n  get minImageIndex() {\n    return VariableSizedImageData.minImageIndex;\n  }\n  get maxTableIndex() {\n    return VariableSizedImageData.maxTableIndex;\n  }\n  get minTableIndex() {\n    return VariableSizedImageData.minTableIndex;\n  }\n  get indexMap() {\n    return ROM.vSImageTableMap;\n  }\n  set index(index) {\n    VariableSizedImageData.CurrentImageIndex = index;\n  }\n  get index() {\n    return VariableSizedImageData.CurrentImageIndex;\n  }\n  set table(table) {\n    VariableSizedImageData.CurrentTableIndex = table;\n  }\n  get table() {\n    return VariableSizedImageData.CurrentTableIndex;\n  }\n  getImageAt(table, index) {\n    VariableSizedImageData.CurrentTableIndex = table;\n    VariableSizedImageData.CurrentImageIndex = index;\n    VariableSizedImage._getCurrent();\n    return VariableSizedImage.currentPlane;\n  }\n  get plane() {\n    VariableSizedImage._getCurrent();\n    return VariableSizedImage.currentPlane;\n  }\n  placeInFullFrame(vsPlane, xOffset, yOffset, fullFrameImage = new Uint8Array(WPC.DmdPageBytes)) {\n    const vsByteWidth = Math.ceil(vsPlane.width / 8);\n    const bitOffset = xOffset % 8;\n    const bytesPerRow = Math.ceil((bitOffset + vsPlane.width + 1) / 8);\n    const vsImageLength = bytesPerRow * vsPlane.height;\n    const startMask = 0xff >> 8 - bitOffset;\n    const endMask = 0xff << (xOffset + vsPlane.width) % 8 & 0xff;\n    for (let i = 0; i < vsImageLength; i++) {\n      const col = i % bytesPerRow;\n      const row = Math.floor(i / bytesPerRow);\n      const prevByteIndex = vsByteWidth * row + (col - 1);\n      const thisByteIndex = vsByteWidth * row + col;\n      const destXPos = Math.floor(xOffset / 8) + col;\n      const destYPos = yOffset + row;\n      const destPos = destYPos * (WPC.DmdCols / 8) + destXPos;\n      const sourceByte = fullFrameImage[destPos];\n      let mergeByte = sourceByte & startMask;\n      let prevByte = 0x00;\n      let thisByte = 0x00;\n      if (col > 0) {\n        prevByte = vsPlane.image[prevByteIndex] >> 8 - bitOffset & 0xff;\n        mergeByte = 0x00;\n      }\n      if (col < bytesPerRow) {\n        thisByte = vsPlane.image[thisByteIndex] << bitOffset & 0xff;\n        thisByte = mergeByte + thisByte & 0xff;\n      }\n      let destByte = prevByte + thisByte;\n      if (col == bytesPerRow - 1) {\n        destByte = destByte & 0xff >> 8 - (xOffset + vsPlane.width) % 8;\n        destByte = destByte + (sourceByte & endMask);\n      }\n      fullFrameImage[destPos] = destByte;\n    }\n    return fullFrameImage;\n  }\n  static _getCurrent() {\n    DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n    DmdDecoder.decodeVariableSizedImageData();\n    VariableSizedImage.currentPlane.image = VariableSizedImageData.Planes.Plane0.Plane_Data;\n    VariableSizedImage.currentPlane.mask = VariableSizedImageData.Planes.Plane0.Plane_Skipped;\n    VariableSizedImage.currentPlane.xor = VariableSizedImageData.Planes.Plane0.Plane_XorBits;\n    VariableSizedImage.currentPlane.type = VariableSizedImageData.Planes.Plane0.Plane_Encoding;\n    VariableSizedImage.currentPlane.width = VariableSizedImageData.CurrentImageXSize;\n    VariableSizedImage.currentPlane.height = VariableSizedImageData.CurrentImageYSize;\n    VariableSizedImage.currentPlane.xOffset = VariableSizedImageData.CurrentImageXShift;\n    VariableSizedImage.currentPlane.yOffset = VariableSizedImageData.CurrentImageYShift;\n    VariableSizedImage.currentPlane.address = VariableSizedImageData.Address;\n    VariableSizedImage.currentPlane.tableAddress = VariableSizedImageData.TableAddress;\n  }\n}\nVariableSizedImage.currentPlane = {\n  width: 0,\n  height: 0,\n  image: new Uint8Array(),\n  mask: new Uint8Array(),\n  xor: new Uint8Array(WPC.DmdPageBytes),\n  flags: new Uint8Array(WPC.DmdPageBytes),\n  xOffset: 0,\n  yOffset: 0,\n  type: 255,\n  address: 0,\n  tableAddress: 0\n};","map":{"version":3,"names":["DmdDecoder","DataTypes","WPC","VariableSizedImageData","ROM","VariableSizedImage","init","instance","constructor","prev","steps","decodePreviousIndex","FontData","next","decodeNextIndex","maxImageIndex","minImageIndex","maxTableIndex","minTableIndex","indexMap","vSImageTableMap","index","CurrentImageIndex","table","CurrentTableIndex","getImageAt","_getCurrent","currentPlane","plane","placeInFullFrame","vsPlane","xOffset","yOffset","fullFrameImage","Uint8Array","DmdPageBytes","vsByteWidth","Math","ceil","width","bitOffset","bytesPerRow","vsImageLength","height","startMask","endMask","i","col","row","floor","prevByteIndex","thisByteIndex","destXPos","destYPos","destPos","DmdCols","sourceByte","mergeByte","prevByte","thisByte","image","destByte","decodeVariableSizedImageIndexToPlane","decodeVariableSizedImageData","Planes","Plane0","Plane_Data","mask","Plane_Skipped","xor","Plane_XorBits","type","Plane_Encoding","CurrentImageXSize","CurrentImageYSize","CurrentImageXShift","CurrentImageYShift","address","Address","tableAddress","TableAddress","flags"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit/node_modules/wpcedit/dist/classes/VariableSizedImage.js"],"sourcesContent":["import { DmdDecoder } from \"./DmdDecoder.js\";\nimport { DataTypes, WPC } from \"../resources/Constants.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class VariableSizedImage {\n    static init() {\n        if (VariableSizedImage.instance) {\n            return this.instance;\n        }\n        this.instance = new VariableSizedImage();\n        return this.instance;\n    }\n    constructor() {\n        VariableSizedImageData.init();\n    }\n    prev(steps) {\n        DmdDecoder.decodePreviousIndex(steps, DataTypes.FontData);\n    }\n    next(steps) {\n        DmdDecoder.decodeNextIndex(steps, DataTypes.FontData);\n    }\n    get maxImageIndex() {\n        return VariableSizedImageData.maxImageIndex;\n    }\n    get minImageIndex() {\n        return VariableSizedImageData.minImageIndex;\n    }\n    get maxTableIndex() {\n        return VariableSizedImageData.maxTableIndex;\n    }\n    get minTableIndex() {\n        return VariableSizedImageData.minTableIndex;\n    }\n    get indexMap() {\n        return ROM.vSImageTableMap;\n    }\n    set index(index) {\n        VariableSizedImageData.CurrentImageIndex = index;\n    }\n    get index() {\n        return VariableSizedImageData.CurrentImageIndex;\n    }\n    set table(table) {\n        VariableSizedImageData.CurrentTableIndex = table;\n    }\n    get table() {\n        return VariableSizedImageData.CurrentTableIndex;\n    }\n    getImageAt(table, index) {\n        VariableSizedImageData.CurrentTableIndex = table;\n        VariableSizedImageData.CurrentImageIndex = index;\n        VariableSizedImage._getCurrent();\n        return VariableSizedImage.currentPlane;\n    }\n    get plane() {\n        VariableSizedImage._getCurrent();\n        return VariableSizedImage.currentPlane;\n    }\n    placeInFullFrame(vsPlane, xOffset, yOffset, fullFrameImage = new Uint8Array(WPC.DmdPageBytes)) {\n        const vsByteWidth = Math.ceil(vsPlane.width / 8);\n        const bitOffset = xOffset % 8;\n        const bytesPerRow = Math.ceil((bitOffset + vsPlane.width + 1) / 8);\n        const vsImageLength = bytesPerRow * vsPlane.height;\n        const startMask = 0xff >> (8 - bitOffset);\n        const endMask = (0xff << (xOffset + vsPlane.width) % 8) & 0xff;\n        for (let i = 0; i < vsImageLength; i++) {\n            const col = i % bytesPerRow;\n            const row = Math.floor(i / bytesPerRow);\n            const prevByteIndex = vsByteWidth * row + (col - 1);\n            const thisByteIndex = vsByteWidth * row + col;\n            const destXPos = Math.floor(xOffset / 8) + col;\n            const destYPos = yOffset + row;\n            const destPos = destYPos * (WPC.DmdCols / 8) + destXPos;\n            const sourceByte = fullFrameImage[destPos];\n            let mergeByte = sourceByte & startMask;\n            let prevByte = 0x00;\n            let thisByte = 0x00;\n            if (col > 0) {\n                prevByte = (vsPlane.image[prevByteIndex] >> (8 - bitOffset)) & 0xff;\n                mergeByte = 0x00;\n            }\n            if (col < bytesPerRow) {\n                thisByte = (vsPlane.image[thisByteIndex] << bitOffset) & 0xff;\n                thisByte = (mergeByte + thisByte) & 0xff;\n            }\n            let destByte = prevByte + thisByte;\n            if (col == bytesPerRow - 1) {\n                destByte = destByte & (0xff >> (8 - ((xOffset + vsPlane.width) % 8)));\n                destByte = destByte + (sourceByte & endMask);\n            }\n            fullFrameImage[destPos] = destByte;\n        }\n        return fullFrameImage;\n    }\n    static _getCurrent() {\n        DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n        DmdDecoder.decodeVariableSizedImageData();\n        VariableSizedImage.currentPlane.image =\n            VariableSizedImageData.Planes.Plane0.Plane_Data;\n        VariableSizedImage.currentPlane.mask =\n            VariableSizedImageData.Planes.Plane0.Plane_Skipped;\n        VariableSizedImage.currentPlane.xor =\n            VariableSizedImageData.Planes.Plane0.Plane_XorBits;\n        VariableSizedImage.currentPlane.type =\n            VariableSizedImageData.Planes.Plane0.Plane_Encoding;\n        VariableSizedImage.currentPlane.width =\n            VariableSizedImageData.CurrentImageXSize;\n        VariableSizedImage.currentPlane.height =\n            VariableSizedImageData.CurrentImageYSize;\n        VariableSizedImage.currentPlane.xOffset =\n            VariableSizedImageData.CurrentImageXShift;\n        VariableSizedImage.currentPlane.yOffset =\n            VariableSizedImageData.CurrentImageYShift;\n        VariableSizedImage.currentPlane.address = VariableSizedImageData.Address;\n        VariableSizedImage.currentPlane.tableAddress =\n            VariableSizedImageData.TableAddress;\n    }\n}\nVariableSizedImage.currentPlane = {\n    width: 0,\n    height: 0,\n    image: new Uint8Array(),\n    mask: new Uint8Array(),\n    xor: new Uint8Array(WPC.DmdPageBytes),\n    flags: new Uint8Array(WPC.DmdPageBytes),\n    xOffset: 0,\n    yOffset: 0,\n    type: 255,\n    address: 0,\n    tableAddress: 0,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}