{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport BaseModal from './BaseModal.vue';\nimport ModalHeader from './ModalHeader.vue';\nimport ModalFooter from './ModalFooter.vue';\nimport ExportSection from '../ExportSection.vue';\nimport MainDmd from '../../dmd/MainDmd.vue';\nimport SubDmd from '../../dmd/SubDmd.vue';\nimport CheckBox from '../../ui/CheckBox.vue';\nimport { toHex } from '../../../helpers/formatting.js';\nimport { storeToRefs } from 'pinia';\nimport store from \"../../../stores/store.js\";\nimport { useMainStore } from '../../../stores/mainStore.js';\nconst MainStore = useMainStore(store);\nexport default {\n  name: 'SpriteModal',\n  components: {\n    BaseModal,\n    ModalHeader,\n    ModalFooter,\n    ExportSection,\n    MainDmd,\n    SubDmd,\n    CheckBox\n  },\n  setup() {\n    const {\n      exportOption,\n      settings\n    } = storeToRefs(MainStore);\n    return {\n      exportOption,\n      settings\n    };\n  },\n  data() {\n    // fetch the selected export option and create an object to pass the data for the selector\n    const options = new Array();\n    const labels = ['PNG image from render', 'Monochrome BMP image', 'Monochrome BMP image (inverted)', 'Raw byte array'];\n    for (let i = 0; i < labels.length; i++) {\n      const selected = i == this.exportOption;\n      options.push({\n        value: i,\n        label: labels[i],\n        selected: selected\n      });\n    }\n    return {\n      doBlend: true,\n      doMerge0: false,\n      doMerge1: false,\n      offset: 0,\n      blendOffset: 1,\n      merge0Offset: 2,\n      merge1Offset: 3,\n      doInBetween0: true,\n      doInBetween1: true,\n      exportMainDmd: -1,\n      options: options\n    };\n  },\n  props: {\n    show: Boolean,\n    index: Number\n  },\n  computed: {\n    planeIndices() {\n      const currIndex = Math.max(this.index + this.offset, 0);\n      return {\n        current: currIndex,\n        blend: Math.max(currIndex + this.blendOffset, 0),\n        merge0: Math.max(currIndex + this.merge0Offset, 0),\n        merge1: Math.max(currIndex + this.merge1Offset, 0)\n      };\n    },\n    // create strings for labels and titles:\n    currPlaneTitle() {\n      return `This plane, index ${this.planeIndices.current}`;\n    },\n    blendPlaneLabel() {\n      return `Blend with index ${this.planeIndices.blend}`;\n    },\n    merge0Label() {\n      return `Apply index ${this.planeIndices.merge0} on top`;\n    },\n    merge1Label() {\n      return `Apply index ${this.planeIndices.merge1} on top`;\n    },\n    title() {\n      return `Image ${toHex(MainStore.getFullFrameImageAt(this.planeIndices.current).address, 6)}`;\n    },\n    subTitle() {\n      return `Table ${toHex(MainStore.getFullFrameImageAt(this.planeIndices.current).tableAddress, 6)}`;\n    }\n  },\n  methods: {\n    image0() {\n      return this.mainImage();\n    },\n    image1() {\n      if (this.doBlend) {\n        return this.blendImage();\n      }\n      return this.mainImage();\n    },\n    mainImage() {\n      const indices = this.planeIndices;\n      if (this.doMerge0) {\n        // apply the merge image if checked\n        let image1 = MainStore.getFullFrameImageAt(indices.current).image;\n        if (this.doInBetween0) {\n          // if in-betweening is active (default), figure out the frames between the main frame and the merge frame\n          for (let i = 1; i <= Math.abs(indices.merge0 - indices.current); i++) {\n            if (this.doBlend && i % 2 != 0) {\n              // if blend is active, only use every second frame (because the other most likely belongs to the blend frame)\n              continue;\n            } else {\n              const plane2 = MainStore.getFullFrameImageAt(indices.current + i);\n              image1 = MainStore.mergePlanes(image1, plane2);\n            }\n          }\n        } else {\n          const plane2 = MainStore.getFullFrameImageAt(indices.merge0);\n          image1 = MainStore.mergePlanes(image1, plane2);\n        }\n        return image1;\n      }\n      return MainStore.getFullFrameImageAt(indices.current).image;\n    },\n    blendImage() {\n      const indices = this.planeIndices;\n      let image1 = MainStore.getFullFrameImageAt(indices.blend).image;\n      if (this.doMerge1) {\n        // apply the merge image if checked\n        if (this.doInBetween1) {\n          // if in-betweening is active (default), figure out the frames between the main frame and the merge frame\n          for (let i = 1; i <= Math.abs(indices.merge1 - indices.current); i++) {\n            if (this.doBlend && i % 2 != 1) {\n              // if blend is active, only use every second frame (because the other most likely belongs to the main frame)\n              continue;\n            } else {\n              const plane2 = MainStore.getFullFrameImageAt(indices.current + i);\n              image1 = MainStore.mergePlanes(image1, plane2);\n            }\n          }\n        } else {\n          const plane2 = MainStore.getFullFrameImageAt(indices.merge1);\n          image1 = MainStore.mergePlanes(image1, plane2);\n        }\n        return image1;\n      }\n      return MainStore.getFullFrameImageAt(indices.blend).image;\n    },\n    merge0Image() {\n      const indices = this.planeIndices;\n      return MainStore.getFullFrameImageAt(indices.merge0).image;\n    },\n    merge1Image() {\n      const indices = this.planeIndices;\n      return MainStore.getFullFrameImageAt(indices.merge1).image;\n    },\n    setBlendStatus(state) {\n      if (state == true) {\n        this.doBlend = true;\n      } else if (state == false) {\n        this.doBlend = false;\n      }\n    },\n    setMerge0Status(state) {\n      if (state == true) {\n        this.doMerge0 = true;\n      } else if (state == false) {\n        this.doMerge0 = false;\n      }\n    },\n    setMerge1Status(state) {\n      if (state == true) {\n        this.doMerge1 = true;\n      } else if (state == false) {\n        this.doMerge1 = false;\n      }\n    },\n    setBetween0Status(state) {\n      if (state == true) {\n        this.doInBetween0 = true;\n      } else if (state == false) {\n        this.doInBetween0 = false;\n      }\n    },\n    setBetween1Status(state) {\n      if (state == true) {\n        this.doInBetween1 = true;\n      } else if (state == false) {\n        this.doInBetween1 = false;\n      }\n    },\n    goToNextBlendPlane() {\n      this.blendOffset++;\n    },\n    goToPrevBlendPlane() {\n      this.blendOffset--;\n    },\n    goToNextMerge0Plane() {\n      let offset = 1;\n      if (this.doInBetween0 && this.doBlend) {\n        // in-betweening will only render evey other frame, so we need to skip one\n        offset = 2;\n      }\n      this.merge0Offset += offset;\n      if (this.doBlend) {\n        // syncronize if in blend mode\n        this.merge1Offset += offset;\n      }\n    },\n    goToPrevMerge0Plane() {\n      let offset = 1;\n      if (this.doInBetween0 && this.doBlend) {\n        // in-betweening will only render evey other frame, so we need to skip one\n        offset = 2;\n      }\n      if (this.merge0Offset > 0) {\n        this.merge0Offset -= offset;\n        if (this.doBlend) {\n          // syncronize if in blend mode\n          this.merge1Offset -= offset;\n        }\n      }\n    },\n    goToNextMerge1Plane() {\n      let offset = 1;\n      if (this.doInBetween1 && this.doBlend) {\n        // in-betweening will only render evey other frame, so we need to skip one\n        offset = 2;\n      }\n      this.merge1Offset += offset;\n      if (this.doBlend) {\n        // syncronize if in blend mode\n        this.merge0Offset += offset;\n      }\n    },\n    goToPrevMerge1Plane() {\n      let offset = 1;\n      if (this.doInBetween1 && this.doBlend) {\n        // in-betweening will only render evey other frame, so we need to skip one\n        offset = 2;\n      }\n      if (this.merge1Offset > this.blendOffset) {\n        this.merge1Offset -= offset;\n        if (this.doBlend) {\n          // syncronize if in blend mode\n          this.merge0Offset -= offset;\n        }\n      }\n    },\n    goNext() {\n      this.offset++;\n      this.setInitValues();\n    },\n    goPrev() {\n      if (this.planeIndices.current > 0) {\n        this.offset--;\n      }\n      this.setInitValues();\n    },\n    goN2() {\n      this.offset += 2;\n      this.setInitValues();\n    },\n    goP2() {\n      if (this.planeIndices.current > 0) {\n        this.offset -= 2;\n      }\n      this.setInitValues();\n    },\n    setInitValues() {\n      // reset the values\n      this.doMerge0 = false;\n      this.doMerge1 = false;\n      this.blendOffset = 1;\n      this.merge0Offset = 2;\n      this.merge1Offset = 3;\n    },\n    exportCurrentFrame(planeToExport) {\n      let image = this.mainImage();\n      let index = this.planeIndices.current;\n      if (planeToExport == 1) {\n        image = this.blendImge();\n        index = this.planeIndices.blend;\n      }\n      if (this.exportOption == 0) {\n        this.$refs.main.downloadPng();\n      } else if (this.exportOption == 3) {\n        let dataString = MainStore.exportAsDataArray(image);\n        let link = document.createElement(\"a\");\n        link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(dataString);\n        const filename = \"plane\" + index + \".txt\";\n        link.download = filename;\n        link.style.display = \"none\";\n        document.body.appendChild(link);\n        link.click();\n        link.parentNode.removeChild(link);\n      } else if (this.exportOption == 1 || this.exportOption == 2) {\n        let inverted = false;\n        if (this.exportOption == 2) {\n          inverted = true;\n        }\n        const bmp = MainStore.exportAs1bitBmp(image, inverted, 128, 32);\n        let link = document.createElement(\"a\");\n        link.href = 'data:image/bmp;base64,' + bmp;\n        const filename = \"plane\" + index + \".bmp\";\n        link.download = filename;\n        link.style.display = \"none\";\n        document.body.appendChild(link);\n        link.click();\n        link.parentNode.removeChild(link);\n      }\n    }\n  },\n  updated() {\n    this.offset = 0;\n    this.setInitValues();\n  }\n};","map":{"version":3,"mappings":";AAoEA,OAAOA,SAAQ,MAAO,iBAAiB;AACvC,OAAOC,WAAU,MAAO,mBAAmB;AAC3C,OAAOC,WAAU,MAAO,mBAAmB;AAC3C,OAAOC,aAAY,MAAO,sBAAsB;AAChD,OAAOC,OAAM,MAAO,uBAAuB;AAC3C,OAAOC,MAAK,MAAO,sBAAsB;AACzC,OAAOC,QAAO,MAAO,uBAAuB;AAC5C,SAASC,KAAI,QAAS,gCAAgC;AACtD,SAASC,WAAU,QAAS,OAAO;AACnC,OAAOC,KAAI,MAAO,0BAA0B;AAC5C,SAASC,YAAW,QAAS,8BAA8B;AAE3D,MAAMC,SAAQ,GAAID,YAAY,CAACD,KAAK,CAAC;AAErC,eAAe;EACXG,IAAI,EAAE,aAAa;EACnBC,UAAU,EAAE;IACRb,SAAS;IACTC,WAAW;IACXC,WAAW;IACXC,aAAa;IACbC,OAAO;IACPC,MAAM;IACNC;EACJ,CAAC;EACDQ,KAAK,GAAG;IACJ,MAAM;MAAEC,YAAY;MAAEC;IAAS,IAAIR,WAAW,CAACG,SAAS,CAAC;IACzD,OAAO;MACHI,YAAY;MACZC;IACJ;EACJ,CAAC;EACDC,IAAI,GAAG;IACH;IACA,MAAMC,OAAM,GAAI,IAAIC,KAAK,EAAE;IAC3B,MAAMC,MAAK,GAAI,CACX,uBAAuB,EACvB,sBAAsB,EACtB,iCAAiC,EACjC,gBAAe,CACnB;IACA,KAAI,IAAIC,CAAC,GAAC,CAAC,EAACA,CAAC,GAACD,MAAM,CAACE,MAAM,EAACD,CAAC,EAAE,EAAE;MAC7B,MAAME,QAAO,GAAKF,KAAK,IAAI,CAACN,YAAa;MACzCG,OAAO,CAACM,IAAI,CAAC;QAACC,KAAK,EAACJ,CAAC;QAACK,KAAK,EAACN,MAAM,CAACC,CAAC,CAAC;QAACE,QAAQ,EAACA;MAAQ,CAAC;IAC5D;IAEA,OAAO;MACHI,OAAO,EAAE,IAAI;MACbC,QAAQ,EAAE,KAAK;MACfC,QAAQ,EAAE,KAAK;MACfC,MAAM,EAAE,CAAC;MACTC,WAAW,EAAE,CAAC;MACdC,YAAY,EAAE,CAAC;MACfC,YAAY,EAAE,CAAC;MACfC,YAAY,EAAE,IAAI;MAClBC,YAAY,EAAE,IAAI;MAClBC,aAAa,EAAE,CAAC,CAAC;MACjBlB,OAAO,EAAEA;IACb;EACJ,CAAC;EACDmB,KAAK,EAAE;IACHC,IAAI,EAAEC,OAAO;IACbC,KAAK,EAAEC;EACX,CAAC;EACDC,QAAQ,EAAE;IACNC,YAAY,GAAG;MACX,MAAMC,SAAQ,GAAIC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACN,KAAK,GAAC,IAAI,CAACV,MAAM,EAAC,CAAC,CAAC;MACpD,OAAO;QACHiB,OAAO,EAAEH,SAAS;QAClBI,KAAK,EAAEH,IAAI,CAACC,GAAG,CAACF,SAAS,GAAC,IAAI,CAACb,WAAW,EAAC,CAAC,CAAC;QAC7CkB,MAAM,EAAEJ,IAAI,CAACC,GAAG,CAACF,SAAS,GAAC,IAAI,CAACZ,YAAY,EAAC,CAAC,CAAC;QAC/CkB,MAAM,EAAEL,IAAI,CAACC,GAAG,CAACF,SAAS,GAAC,IAAI,CAACX,YAAY,EAAC,CAAC;MAClD;IACJ,CAAC;IACD;IACAkB,cAAc,GAAG;MACb,OAAQ,qBAAoB,IAAI,CAACR,YAAY,CAACI,OAAQ,EAAC;IAC3D,CAAC;IACDK,eAAe,GAAG;MACd,OAAQ,oBAAmB,IAAI,CAACT,YAAY,CAACK,KAAM,EAAC;IACxD,CAAC;IACDK,WAAW,GAAG;MACV,OAAQ,eAAc,IAAI,CAACV,YAAY,CAACM,MAAM,SAAS;IAC3D,CAAC;IACDK,WAAW,GAAG;MACV,OAAQ,eAAc,IAAI,CAACX,YAAY,CAACO,MAAM,SAAS;IAC3D,CAAC;IACDK,KAAK,GAAG;MACJ,OAAQ,SAAQhD,KAAK,CAACI,SAAS,CAAC6C,mBAAmB,CAAC,IAAI,CAACb,YAAY,CAACI,OAAO,CAAC,CAACU,OAAO,EAAC,CAAC,CAAE,EAAC;IAC/F,CAAC;IACDC,QAAQ,GAAG;MACP,OAAQ,SAAQnD,KAAK,CAACI,SAAS,CAAC6C,mBAAmB,CAAC,IAAI,CAACb,YAAY,CAACI,OAAO,CAAC,CAACY,YAAY,EAAC,CAAC,CAAE,EAAC;IACpG;EACJ,CAAC;EACDC,OAAO,EAAE;IACLC,MAAM,GAAG;MACL,OAAO,IAAI,CAACC,SAAS,EAAE;IAC3B,CAAC;IACDC,MAAM,GAAG;MACL,IAAG,IAAI,CAACpC,OAAO,EAAE;QACb,OAAO,IAAI,CAACqC,UAAU,EAAE;MAC5B;MACA,OAAO,IAAI,CAACF,SAAS,EAAE;IAC3B,CAAC;IACDA,SAAS,GAAG;MACR,MAAMG,OAAM,GAAI,IAAI,CAACtB,YAAY;MACjC,IAAG,IAAI,CAACf,QAAQ,EAAE;QAAE;QAChB,IAAImC,MAAK,GAAIpD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAAClB,OAAO,CAAC,CAACmB,KAAK;QACjE,IAAG,IAAI,CAAChC,YAAY,EAAE;UAAE;UACpB,KAAI,IAAIb,CAAC,GAAC,CAAC,EAAEA,CAAC,IAAEwB,IAAI,CAACsB,GAAG,CAACF,OAAO,CAAChB,MAAM,GAACgB,OAAO,CAAClB,OAAO,CAAC,EAAE1B,CAAC,EAAE,EAAE;YAC3D,IAAG,IAAI,CAACM,OAAM,IAAKN,CAAC,GAAC,CAAC,IAAE,CAAC,EAAE;cAAE;cACzB;YACJ,OAAO;cACH,MAAM+C,MAAK,GAAIzD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAAClB,OAAO,GAAC1B,CAAC,CAAC;cAC/D0C,MAAK,GAAIpD,SAAS,CAAC0D,WAAW,CAACN,MAAM,EAACK,MAAM,CAAC;YACjD;UACJ;QACJ,OAAO;UACH,MAAMA,MAAK,GAAIzD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAAChB,MAAM,CAAC;UAC5Dc,MAAK,GAAIpD,SAAS,CAAC0D,WAAW,CAACN,MAAM,EAACK,MAAM,CAAC;QACjD;QACA,OAAOL,MAAM;MACjB;MACA,OAAOpD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAAClB,OAAO,CAAC,CAACmB,KAAK;IAC/D,CAAC;IACDF,UAAU,GAAG;MACT,MAAMC,OAAM,GAAI,IAAI,CAACtB,YAAY;MACjC,IAAIoB,MAAK,GAAIpD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAACjB,KAAK,CAAC,CAACkB,KAAK;MAC/D,IAAG,IAAI,CAACrC,QAAQ,EAAE;QAAE;QAChB,IAAG,IAAI,CAACM,YAAY,EAAE;UAAE;UACpB,KAAI,IAAId,CAAC,GAAC,CAAC,EAAEA,CAAC,IAAEwB,IAAI,CAACsB,GAAG,CAACF,OAAO,CAACf,MAAM,GAACe,OAAO,CAAClB,OAAO,CAAC,EAAE1B,CAAC,EAAE,EAAE;YAC3D,IAAG,IAAI,CAACM,OAAM,IAAKN,CAAC,GAAC,CAAC,IAAE,CAAC,EAAE;cAAE;cACzB;YACJ,OAAO;cACH,MAAM+C,MAAK,GAAIzD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAAClB,OAAO,GAAC1B,CAAC,CAAC;cAC/D0C,MAAK,GAAIpD,SAAS,CAAC0D,WAAW,CAACN,MAAM,EAACK,MAAM;YAChD;UACJ;QACJ,OAAO;UACH,MAAMA,MAAK,GAAIzD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAACf,MAAM,CAAC;UAC5Da,MAAK,GAAIpD,SAAS,CAAC0D,WAAW,CAACN,MAAM,EAACK,MAAM;QAChD;QACA,OAAOL,MAAM;MACjB;MACA,OAAOpD,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAACjB,KAAK,CAAC,CAACkB,KAAK;IAC7D,CAAC;IACDI,WAAW,GAAG;MACV,MAAML,OAAM,GAAI,IAAI,CAACtB,YAAY;MACjC,OAAOhC,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAAChB,MAAM,CAAC,CAACiB,KAAK;IAC9D,CAAC;IACDK,WAAW,GAAG;MACV,MAAMN,OAAM,GAAI,IAAI,CAACtB,YAAY;MACjC,OAAOhC,SAAS,CAAC6C,mBAAmB,CAACS,OAAO,CAACf,MAAM,CAAC,CAACgB,KAAK;IAC9D,CAAC;IACDM,cAAc,CAACC,KAAK,EAAE;MAClB,IAAGA,KAAI,IAAK,IAAI,EAAE;QACd,IAAI,CAAC9C,OAAM,GAAI,IAAI;MACvB,OAAO,IAAG8C,KAAI,IAAK,KAAK,EAAE;QACtB,IAAI,CAAC9C,OAAM,GAAI,KAAK;MACxB;IACJ,CAAC;IACD+C,eAAe,CAACD,KAAK,EAAE;MACnB,IAAGA,KAAI,IAAK,IAAI,EAAE;QACd,IAAI,CAAC7C,QAAO,GAAI,IAAI;MACxB,OAAO,IAAG6C,KAAI,IAAK,KAAK,EAAE;QACtB,IAAI,CAAC7C,QAAO,GAAI,KAAK;MACzB;IACJ,CAAC;IACD+C,eAAe,CAACF,KAAK,EAAE;MACnB,IAAGA,KAAI,IAAK,IAAI,EAAE;QACd,IAAI,CAAC5C,QAAO,GAAI,IAAI;MACxB,OAAO,IAAG4C,KAAI,IAAK,KAAK,EAAE;QACtB,IAAI,CAAC5C,QAAO,GAAI,KAAK;MACzB;IACJ,CAAC;IACD+C,iBAAiB,CAACH,KAAK,EAAE;MACrB,IAAGA,KAAI,IAAK,IAAI,EAAE;QACd,IAAI,CAACvC,YAAW,GAAI,IAAI;MAC5B,OAAO,IAAGuC,KAAI,IAAK,KAAK,EAAE;QACtB,IAAI,CAACvC,YAAW,GAAI,KAAK;MAC7B;IACJ,CAAC;IACD2C,iBAAiB,CAACJ,KAAK,EAAE;MACrB,IAAGA,KAAI,IAAK,IAAI,EAAE;QACd,IAAI,CAACtC,YAAW,GAAI,IAAI;MAC5B,OAAO,IAAGsC,KAAI,IAAK,KAAK,EAAE;QACtB,IAAI,CAACtC,YAAW,GAAI,KAAK;MAC7B;IACJ,CAAC;IACD2C,kBAAkB,GAAG;MACjB,IAAI,CAAC/C,WAAW,EAAE;IACtB,CAAC;IACDgD,kBAAkB,GAAG;MACjB,IAAI,CAAChD,WAAW,EAAE;IACtB,CAAC;IACDiD,mBAAmB,GAAG;MAClB,IAAIlD,MAAK,GAAI,CAAC;MACd,IAAG,IAAI,CAACI,YAAW,IAAK,IAAI,CAACP,OAAO,EAAE;QAAE;QACpCG,MAAK,GAAI,CAAC;MACd;MACA,IAAI,CAACE,YAAW,IAAKF,MAAM;MAC3B,IAAG,IAAI,CAACH,OAAO,EAAE;QAAE;QACf,IAAI,CAACM,YAAW,IAAKH,MAAM;MAC/B;IACJ,CAAC;IACDmD,mBAAmB,GAAG;MAClB,IAAInD,MAAK,GAAI,CAAC;MACd,IAAG,IAAI,CAACI,YAAW,IAAK,IAAI,CAACP,OAAO,EAAE;QAAE;QACpCG,MAAK,GAAI,CAAC;MACd;MACA,IAAG,IAAI,CAACE,YAAW,GAAI,CAAC,EAAE;QACvB,IAAI,CAACA,YAAY,IAAEF,MAAM;QACzB,IAAG,IAAI,CAACH,OAAO,EAAE;UAAE;UACd,IAAI,CAACM,YAAW,IAAKH,MAAM;QAC/B;MACJ;IACJ,CAAC;IACDoD,mBAAmB,GAAG;MAClB,IAAIpD,MAAK,GAAI,CAAC;MACd,IAAG,IAAI,CAACK,YAAW,IAAK,IAAI,CAACR,OAAO,EAAE;QAAE;QACpCG,MAAK,GAAI,CAAC;MACd;MACA,IAAI,CAACG,YAAY,IAAEH,MAAM;MACzB,IAAG,IAAI,CAACH,OAAO,EAAE;QAAE;QACf,IAAI,CAACK,YAAW,IAAKF,MAAM;MAC/B;IACJ,CAAC;IACDqD,mBAAmB,GAAG;MAClB,IAAIrD,MAAK,GAAI,CAAC;MACd,IAAG,IAAI,CAACK,YAAW,IAAK,IAAI,CAACR,OAAO,EAAE;QAAE;QACpCG,MAAK,GAAI,CAAC;MACd;MACA,IAAG,IAAI,CAACG,YAAW,GAAI,IAAI,CAACF,WAAW,EAAE;QACrC,IAAI,CAACE,YAAW,IAAKH,MAAM;QAC3B,IAAG,IAAI,CAACH,OAAO,EAAE;UAAE;UACf,IAAI,CAACK,YAAW,IAAKF,MAAM;QAC/B;MACJ;IACJ,CAAC;IACDsD,MAAM,GAAG;MACL,IAAI,CAACtD,MAAM,EAAE;MACb,IAAI,CAACuD,aAAa,EAAE;IACxB,CAAC;IACDC,MAAM,GAAG;MACL,IAAG,IAAI,CAAC3C,YAAY,CAACI,OAAM,GAAI,CAAC,EAAE;QAC9B,IAAI,CAACjB,MAAM,EAAE;MACjB;MACA,IAAI,CAACuD,aAAa,EAAE;IACxB,CAAC;IACDE,IAAI,GAAG;MACH,IAAI,CAACzD,MAAM,IAAE,CAAC;MACd,IAAI,CAACuD,aAAa,EAAE;IACxB,CAAC;IACDG,IAAI,GAAG;MACH,IAAG,IAAI,CAAC7C,YAAY,CAACI,OAAM,GAAI,CAAC,EAAE;QAC9B,IAAI,CAACjB,MAAM,IAAE,CAAC;MAClB;MACA,IAAI,CAACuD,aAAa,EAAE;IACxB,CAAC;IACDA,aAAa,GAAG;MACZ;MACA,IAAI,CAACzD,QAAO,GAAI,KAAK;MACrB,IAAI,CAACC,QAAO,GAAI,KAAK;MACrB,IAAI,CAACE,WAAU,GAAI,CAAC;MACpB,IAAI,CAACC,YAAW,GAAI,CAAC;MACrB,IAAI,CAACC,YAAW,GAAI,CAAC;IACzB,CAAC;IACDwD,kBAAkB,CAACC,aAAa,EAAE;MAC9B,IAAIxB,KAAI,GAAI,IAAI,CAACJ,SAAS,EAAE;MAC5B,IAAItB,KAAI,GAAI,IAAI,CAACG,YAAY,CAACI,OAAO;MACrC,IAAG2C,aAAY,IAAK,CAAC,EAAE;QACnBxB,KAAI,GAAI,IAAI,CAACyB,SAAS,EAAE;QACxBnD,KAAI,GAAI,IAAI,CAACG,YAAY,CAACK,KAAK;MACnC;MACA,IAAG,IAAI,CAACjC,YAAW,IAAK,CAAC,EAAE;QACvB,IAAI,CAAC6E,KAAK,CAACC,IAAI,CAACC,WAAW,EAAE;MACjC,OAAO,IAAG,IAAI,CAAC/E,YAAW,IAAK,CAAC,EAAE;QAC9B,IAAIgF,UAAS,GAAKpF,SAAS,CAACqF,iBAAiB,CAAC9B,KAAK,CAAC;QACpD,IAAI+B,IAAG,GAAIC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;QACtCF,IAAI,CAACG,IAAG,GAAI,gCAA+B,GAAIC,kBAAkB,CAACN,UAAU,CAAC;QAC7E,MAAMO,QAAO,GAAI,OAAO,GAAC9D,KAAK,GAAC,MAAM;QACrCyD,IAAI,CAACM,QAAO,GAAID,QAAQ;QACxBL,IAAI,CAACO,KAAK,CAACC,OAAM,GAAI,MAAM;QAC3BP,QAAQ,CAACQ,IAAI,CAACC,WAAW,CAACV,IAAI,CAAC;QAC/BA,IAAI,CAACW,KAAK,EAAE;QACZX,IAAI,CAACY,UAAU,CAACC,WAAW,CAACb,IAAI,CAAC;MACrC,OAAO,IAAG,IAAI,CAAClF,YAAW,IAAK,KAAK,IAAI,CAACA,YAAW,IAAK,CAAC,EAAE;QACxD,IAAIgG,QAAO,GAAI,KAAK;QACpB,IAAG,IAAI,CAAChG,YAAW,IAAK,CAAC,EAAE;UACvBgG,QAAO,GAAI,IAAI;QACnB;QACA,MAAMC,GAAE,GAAIrG,SAAS,CAACsG,eAAe,CAAC/C,KAAK,EAAC6C,QAAQ,EAAC,GAAG,EAAC,EAAE,CAAC;QAC5D,IAAId,IAAG,GAAIC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;QACtCF,IAAI,CAACG,IAAG,GAAI,wBAAuB,GAAIY,GAAG;QAC1C,MAAMV,QAAO,GAAI,OAAO,GAAC9D,KAAK,GAAC,MAAM;QACrCyD,IAAI,CAACM,QAAO,GAAID,QAAQ;QACxBL,IAAI,CAACO,KAAK,CAACC,OAAM,GAAI,MAAM;QAC3BP,QAAQ,CAACQ,IAAI,CAACC,WAAW,CAACV,IAAI,CAAC;QAC/BA,IAAI,CAACW,KAAK,EAAE;QACZX,IAAI,CAACY,UAAU,CAACC,WAAW,CAACb,IAAI,CAAC;MACrC;IACJ;EACJ,CAAC;EACDiB,OAAO,GAAG;IACN,IAAI,CAACpF,MAAK,GAAI,CAAC;IACf,IAAI,CAACuD,aAAa,EAAE;EACxB;AACJ","names":["BaseModal","ModalHeader","ModalFooter","ExportSection","MainDmd","SubDmd","CheckBox","toHex","storeToRefs","store","useMainStore","MainStore","name","components","setup","exportOption","settings","data","options","Array","labels","i","length","selected","push","value","label","doBlend","doMerge0","doMerge1","offset","blendOffset","merge0Offset","merge1Offset","doInBetween0","doInBetween1","exportMainDmd","props","show","Boolean","index","Number","computed","planeIndices","currIndex","Math","max","current","blend","merge0","merge1","currPlaneTitle","blendPlaneLabel","merge0Label","merge1Label","title","getFullFrameImageAt","address","subTitle","tableAddress","methods","image0","mainImage","image1","blendImage","indices","image","abs","plane2","mergePlanes","merge0Image","merge1Image","setBlendStatus","state","setMerge0Status","setMerge1Status","setBetween0Status","setBetween1Status","goToNextBlendPlane","goToPrevBlendPlane","goToNextMerge0Plane","goToPrevMerge0Plane","goToNextMerge1Plane","goToPrevMerge1Plane","goNext","setInitValues","goPrev","goN2","goP2","exportCurrentFrame","planeToExport","blendImge","$refs","main","downloadPng","dataString","exportAsDataArray","link","document","createElement","href","encodeURIComponent","filename","download","style","display","body","appendChild","click","parentNode","removeChild","inverted","bmp","exportAs1bitBmp","updated"],"sourceRoot":"","sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/src/components/ui/modals/FullFrameModal.vue"],"sourcesContent":["<template>\n    <BaseModal :show=\"show\" @close=\"$emit('close')\">\n        <ModalHeader\n            :stepBtns=\"true\"\n            :closeBtn=\"true\"\n            :title=\"title\"\n            @next=\"goNext()\"\n            @prev=\"goPrev()\"\n            @next2=\"goN2()\"\n            @prev2=\"goP2()\"\n            @close=\"$emit('close')\">\n        </ModalHeader>\n        <div class=\"modal-body\">\n            <MainDmd :image0=\"image0()\" :image1=\"image1()\" :index=\"planeIndices.current\" ref=\"main\"></MainDmd>\n            <div class=\"sub-dmds blend\">\n                <SubDmd\n                    class=\"plane plane0\"\n                    :title=\"this.currPlaneTitle\"\n                    :isEnabled=\"true\"\n                    :image=\"mainImage()\">\n                </SubDmd>\n                <SubDmd\n                    class=\"plane plane1\"\n                    :checkbox=\"this.blendPlaneLabel\"\n                    :image=\"blendImage()\"\n                    :isEnabled=\"this.doBlend\"\n                    :navBtns=\"true\"\n                    @next=\"goToNextBlendPlane()\"\n                    @prev=\"goToPrevBlendPlane()\"\n                    @enabled=\"setBlendStatus\">\n                </SubDmd>\n            </div>\n            <div class=\"sub-dmds merge\">\n                <div class=\"plane plane0\">\n                    <SubDmd\n                        :checkbox=\"this.merge0Label\"\n                        :image=\"merge0Image()\"\n                        :isEnabled=\"this.doMerge0\"\n                        :navBtns=\"true\"\n                        @next=\"goToNextMerge0Plane()\"\n                        @prev=\"goToPrevMerge0Plane()\"\n                        @enabled=\"setMerge0Status\">\n                    </SubDmd>\n                    <CheckBox v-if=\"settings.optionalInbetweening\" class=\"in-between\" @change=\"setBetween0Status\" :checked=\"true\" label=\"Also apply the planes in between\" ref=\"inBetween0\"></CheckBox>\n                </div>\n                <div>\n                    <SubDmd\n                        class=\"plane plane1\"\n                        :checkbox=\"this.merge1Label\"\n                        :image=\"merge1Image()\"\n                        :isEnabled=\"this.doMerge1\"\n                        :navBtns=\"true\"\n                        @next=\"goToNextMerge1Plane()\"\n                        @prev=\"goToPrevMerge1Plane()\"\n                        @enabled=\"setMerge1Status\">\n                    </SubDmd>\n                    <CheckBox v-if=\"settings.optionalInbetweening\" class=\"in-between\" @change=\"setBetween1Status\" :checked=\"true\" label=\"Also apply the planes in between\" ref=\"inBetween1\"></CheckBox>\n                </div>\n            </div>\n        </div>\n        <ModalFooter>\n            <ExportSection @export-main=\"exportCurrentFrame(0)\" @export-blend=\"exportCurrentFrame(1)\" :options=\"options\">\n            </ExportSection>\n        </ModalFooter>\n    </BaseModal>\n</template>\n\n<script>\nimport BaseModal from './BaseModal.vue';\nimport ModalHeader from './ModalHeader.vue';\nimport ModalFooter from './ModalFooter.vue';\nimport ExportSection from '../ExportSection.vue';\nimport MainDmd from '../../dmd/MainDmd.vue';\nimport SubDmd from '../../dmd/SubDmd.vue';\nimport CheckBox from '../../ui/CheckBox.vue';\nimport { toHex } from '../../../helpers/formatting.js';\nimport { storeToRefs } from 'pinia';\nimport store from \"../../../stores/store.js\";\nimport { useMainStore } from '../../../stores/mainStore.js';\n\nconst MainStore = useMainStore(store);\n\nexport default {\n    name: 'SpriteModal',\n    components: { \n        BaseModal,\n        ModalHeader,\n        ModalFooter,\n        ExportSection,\n        MainDmd,\n        SubDmd,\n        CheckBox\n    },\n    setup() {\n        const { exportOption, settings } = storeToRefs(MainStore);\n        return {\n            exportOption,\n            settings\n        }\n    },\n    data() {\n        // fetch the selected export option and create an object to pass the data for the selector\n        const options = new Array();\n        const labels = [\n            'PNG image from render',\n            'Monochrome BMP image',\n            'Monochrome BMP image (inverted)',\n            'Raw byte array'\n        ]\n        for(let i=0;i<labels.length;i++) {\n            const selected = (i == this.exportOption);\n            options.push({value:i,label:labels[i],selected:selected})\n        }\n\n        return {\n            doBlend: true,\n            doMerge0: false,\n            doMerge1: false,\n            offset: 0,\n            blendOffset: 1,\n            merge0Offset: 2,\n            merge1Offset: 3,\n            doInBetween0: true,\n            doInBetween1: true,\n            exportMainDmd: -1,\n            options: options\n        }\n    },\n    props: {\n        show: Boolean,\n        index: Number\n    },\n    computed: {\n        planeIndices() {\n            const currIndex = Math.max(this.index+this.offset,0);\n            return {\n                current: currIndex,\n                blend: Math.max(currIndex+this.blendOffset,0),\n                merge0: Math.max(currIndex+this.merge0Offset,0),\n                merge1: Math.max(currIndex+this.merge1Offset,0)\n            }\n        },\n        // create strings for labels and titles:\n        currPlaneTitle() {\n            return `This plane, index ${this.planeIndices.current}`;\n        },\n        blendPlaneLabel() {\n            return `Blend with index ${this.planeIndices.blend}`;\n        },\n        merge0Label() {\n            return `Apply index ${this.planeIndices.merge0} on top`;\n        },\n        merge1Label() {\n            return `Apply index ${this.planeIndices.merge1} on top`;\n        },\n        title() {\n            return `Image ${toHex(MainStore.getFullFrameImageAt(this.planeIndices.current).address,6)}`;\n        },\n        subTitle() {\n            return `Table ${toHex(MainStore.getFullFrameImageAt(this.planeIndices.current).tableAddress,6)}`;\n        }\n    },\n    methods: {\n        image0() {\n            return this.mainImage();\n        },\n        image1() {\n            if(this.doBlend) {\n                return this.blendImage();\n            }\n            return this.mainImage();\n        },\n        mainImage() {\n            const indices = this.planeIndices;\n            if(this.doMerge0) { // apply the merge image if checked\n                let image1 = MainStore.getFullFrameImageAt(indices.current).image;\n                if(this.doInBetween0) { // if in-betweening is active (default), figure out the frames between the main frame and the merge frame\n                    for(let i=1; i<=Math.abs(indices.merge0-indices.current); i++) {\n                        if(this.doBlend && i%2!=0) { // if blend is active, only use every second frame (because the other most likely belongs to the blend frame)\n                            continue;\n                        } else {\n                            const plane2 = MainStore.getFullFrameImageAt(indices.current+i);\n                            image1 = MainStore.mergePlanes(image1,plane2);\n                        }\n                    }\n                } else {\n                    const plane2 = MainStore.getFullFrameImageAt(indices.merge0);\n                    image1 = MainStore.mergePlanes(image1,plane2);\n                }\n                return image1;\n            }\n            return MainStore.getFullFrameImageAt(indices.current).image;\n        },\n        blendImage() {\n            const indices = this.planeIndices;\n            let image1 = MainStore.getFullFrameImageAt(indices.blend).image;\n            if(this.doMerge1) { // apply the merge image if checked\n                if(this.doInBetween1) { // if in-betweening is active (default), figure out the frames between the main frame and the merge frame\n                    for(let i=1; i<=Math.abs(indices.merge1-indices.current); i++) {\n                        if(this.doBlend && i%2!=1) { // if blend is active, only use every second frame (because the other most likely belongs to the main frame)\n                            continue;\n                        } else {\n                            const plane2 = MainStore.getFullFrameImageAt(indices.current+i);\n                            image1 = MainStore.mergePlanes(image1,plane2)\n                        }\n                    }\n                } else {\n                    const plane2 = MainStore.getFullFrameImageAt(indices.merge1);\n                    image1 = MainStore.mergePlanes(image1,plane2)\n                }\n                return image1;\n            }\n            return MainStore.getFullFrameImageAt(indices.blend).image;\n        },\n        merge0Image() {\n            const indices = this.planeIndices;\n            return MainStore.getFullFrameImageAt(indices.merge0).image;\n        },\n        merge1Image() {\n            const indices = this.planeIndices;\n            return MainStore.getFullFrameImageAt(indices.merge1).image;\n        },\n        setBlendStatus(state) {\n            if(state == true) {\n                this.doBlend = true;\n            } else if(state == false) {\n                this.doBlend = false;\n            }\n        },\n        setMerge0Status(state) {\n            if(state == true) {\n                this.doMerge0 = true;\n            } else if(state == false) {\n                this.doMerge0 = false;\n            }\n        },\n        setMerge1Status(state) {\n            if(state == true) {\n                this.doMerge1 = true;\n            } else if(state == false) {\n                this.doMerge1 = false;\n            }\n        },\n        setBetween0Status(state) {\n            if(state == true) {\n                this.doInBetween0 = true;\n            } else if(state == false) {\n                this.doInBetween0 = false;\n            }\n        },\n        setBetween1Status(state) {\n            if(state == true) {\n                this.doInBetween1 = true;\n            } else if(state == false) {\n                this.doInBetween1 = false;\n            }\n        },\n        goToNextBlendPlane() {\n            this.blendOffset++;\n        },\n        goToPrevBlendPlane() {\n            this.blendOffset--;\n        },\n        goToNextMerge0Plane() {\n            let offset = 1;\n            if(this.doInBetween0 && this.doBlend) { // in-betweening will only render evey other frame, so we need to skip one\n                offset = 2;\n            }\n            this.merge0Offset += offset;\n            if(this.doBlend) { // syncronize if in blend mode\n                this.merge1Offset += offset;\n            }\n        },\n        goToPrevMerge0Plane() {\n            let offset = 1;\n            if(this.doInBetween0 && this.doBlend) { // in-betweening will only render evey other frame, so we need to skip one\n                offset = 2;\n            }\n            if(this.merge0Offset > 0) {\n               this.merge0Offset-=offset;\n               if(this.doBlend) { // syncronize if in blend mode\n                    this.merge1Offset -= offset;\n                }\n            }\n        },\n        goToNextMerge1Plane() {\n            let offset = 1;\n            if(this.doInBetween1 && this.doBlend) { // in-betweening will only render evey other frame, so we need to skip one\n                offset = 2;\n            }\n            this.merge1Offset+=offset;\n            if(this.doBlend) { // syncronize if in blend mode\n                this.merge0Offset += offset;\n            }\n        },\n        goToPrevMerge1Plane() {\n            let offset = 1;\n            if(this.doInBetween1 && this.doBlend) { // in-betweening will only render evey other frame, so we need to skip one\n                offset = 2;\n            }\n            if(this.merge1Offset > this.blendOffset) {\n                this.merge1Offset -= offset;\n                if(this.doBlend) { // syncronize if in blend mode\n                    this.merge0Offset -= offset;\n                }\n            }\n        },\n        goNext() {\n            this.offset++;\n            this.setInitValues();\n        },\n        goPrev() {\n            if(this.planeIndices.current > 0) {\n                this.offset--;\n            }\n            this.setInitValues();\n        },\n        goN2() {\n            this.offset+=2;\n            this.setInitValues();\n        },\n        goP2() {\n            if(this.planeIndices.current > 0) {\n                this.offset-=2;\n            }\n            this.setInitValues();\n        },\n        setInitValues() {\n            // reset the values\n            this.doMerge0 = false;\n            this.doMerge1 = false;\n            this.blendOffset = 1;\n            this.merge0Offset = 2;\n            this.merge1Offset = 3;\n        },\n        exportCurrentFrame(planeToExport) {\n            let image = this.mainImage();\n            let index = this.planeIndices.current;\n            if(planeToExport == 1) {\n                image = this.blendImge();\n                index = this.planeIndices.blend;\n            }\n            if(this.exportOption == 0) {\n                this.$refs.main.downloadPng();\n            } else if(this.exportOption == 3) {\n                let dataString =  MainStore.exportAsDataArray(image);\n                let link = document.createElement(\"a\");\n                link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(dataString);\n                const filename = \"plane\"+index+\".txt\";\n                link.download = filename;\n                link.style.display = \"none\";\n                document.body.appendChild(link);\n                link.click();\n                link.parentNode.removeChild(link);\n            } else if(this.exportOption == 1 || this.exportOption == 2) {\n                let inverted = false;\n                if(this.exportOption == 2) {\n                    inverted = true;\n                }\n                const bmp = MainStore.exportAs1bitBmp(image,inverted,128,32);\n                let link = document.createElement(\"a\");\n                link.href = 'data:image/bmp;base64,' + bmp;\n                const filename = \"plane\"+index+\".bmp\";\n                link.download = filename;\n                link.style.display = \"none\";\n                document.body.appendChild(link);\n                link.click();\n                link.parentNode.removeChild(link);\n            }\n        }\n    },\n    updated() {\n        this.offset = 0;\n        this.setInitValues();\n    }\n}\n</script>\n\n<style scoped>\n.sub-dmds {\n    margin-top: var(--space-md);\n    display: grid;\n    gap: var(--space-md);\n    grid-template-columns: 1fr 1fr;\n}\n.plane {\n    justify-self: left;\n}\n.modal-body {\n    margin: 0 var(--space-md);\n}\n.in-between {\n    margin-top: var(--space-sm);\n    margin-bottom: var(--space-md);\n}\n</style>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}