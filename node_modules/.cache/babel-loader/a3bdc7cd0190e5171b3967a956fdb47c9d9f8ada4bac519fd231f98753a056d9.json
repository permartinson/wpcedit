{"ast":null,"code":"import { HitTypes, DataTypes, WPC } from \"../resources/Constants.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { Settings } from \"../stores/Settings.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DataParser {\n  constructor() {}\n  static init(romData, dataType) {\n    if (DataParser.instance) {\n      return this.instance;\n    }\n    this.instance = new DataParser();\n    return this.instance;\n  }\n  static initTableAddrs() {\n    let Page;\n    let PageByteIdx;\n    let HitTablePtr;\n    let HitPagePtr;\n    let RomAddr;\n    let WpcAddr;\n    let Ptr = 0;\n    logStr(`Searching ROM for Master Animation Table Address`);\n    for (Page = 0; Page < ROM.totalPages; Page++) {\n      for (PageByteIdx = 0; PageByteIdx < WPC.PageLength; PageByteIdx++) {\n        switch (ROM.byteAtAddr(Ptr++) & 0xFF) {\n          case 0xBE:\n            if (PageByteIdx >= WPC.PageLength - 16) {\n              break;\n            }\n            if ((ROM.byteAtAddr(Ptr + 2) & 0xff) == 0x3a && (ROM.byteAtAddr(Ptr + 3) & 0xff) == 0x58 && (ROM.byteAtAddr(Ptr + 4) & 0xff) == 0x3a && (ROM.byteAtAddr(Ptr + 5) & 0xff) == 0xd6 && (ROM.byteAtAddr(Ptr + 7) & 0xff) == 0x34 && (ROM.byteAtAddr(Ptr + 8) & 0xff) == 0x04 && ((ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xf6 || (ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xbd) && ((ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xbd || (ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xf6)) {\n              HitTablePtr = Ptr;\n              HitPagePtr = Ptr + 2;\n              RomAddr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n              if (RomAddr == -1) {\n                logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Font Table Pointer opcode: ${toHex(HitTablePtr & 0xFF)} ${toHex(HitTablePtr + 1 & 0xFF)}`);\n                return -1;\n              }\n              logStr(`Address in ROM of Font Table Pointer ${toHex(RomAddr)}`);\n              if (Settings.DataType == DataTypes.FontData) {\n                VariableSizedImageData.TableAddress = DataParser.processHitType(HitTypes.AddrAddr, HitTablePtr, HitPagePtr, Ptr);\n                if (VariableSizedImageData.TableAddress == -1) {\n                  logStr(`Error from ProcessHitType while trying to process Font Table Pointer opcode: ${toHex(HitTablePtr & 0xFF)} ${toHex(HitTablePtr + 1 & 0xFF)}`);\n                  break;\n                }\n                logStr(`Found Address in ROM of Font Table ${toHex(VariableSizedImageData.TableAddress)}`);\n              }\n              HitTablePtr = RomAddr;\n              HitPagePtr = RomAddr + 2;\n              WpcAddr = (ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff) & 0xffff;\n              if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom && WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength && ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                RomAddr += 2;\n              } else {\n                RomAddr += 3;\n              }\n              logStr(`Address in ROM of Graphics Table Pointer ${toHex(RomAddr)}`);\n              HitTablePtr = RomAddr;\n              HitPagePtr = RomAddr + 2;\n              FullFrameImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n              if (FullFrameImageData.TableAddress == -1) {\n                logStr(`Error from processHitType while trying to process Graphic Table Pointer: ${toHex(HitTablePtr & 0xFF)} ${toHex(HitTablePtr + 1 & 0xFF)}`);\n                if (Settings.DataType == DataTypes.FontData) {\n                  return 0;\n                }\n                return -1;\n              }\n              logStr(`Found Address in ROM of Graphics Table ${toHex(FullFrameImageData.TableAddress)}`);\n              if (Settings.DataType != DataTypes.AniData) {\n                return 0;\n              }\n              HitTablePtr = ROM.byteAtAddr(RomAddr);\n              HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n              WpcAddr = (ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff) & 0xffff;\n              if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom && WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength && ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                RomAddr += 2;\n              } else {\n                RomAddr += 3;\n              }\n              logStr(`Address in ROM of Animation Table Pointer ${toHex(RomAddr)}`);\n              HitTablePtr = ROM.byteAtAddr(RomAddr);\n              HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n              VariableSizedImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n              if (VariableSizedImageData.TableAddress == -1) {\n                logStr(`Error from processHitType while trying to process Animation Table Pointer: ${HitTablePtr & 0xFF} ${HitTablePtr + 1 & 0xFF}`);\n                return -1;\n              }\n              logStr(`Found Address in ROM of Animation Table ${toHex(VariableSizedImageData.TableAddress)}`);\n              ROM.startPtr = Ptr;\n              return 0;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n  static getFirstImageIndex(TableIndex) {\n    const imageIndex = this.getNextImageIndex(0, TableIndex);\n    if (imageIndex == -1) {\n      return -1;\n    }\n    VariableSizedImageData.CurrentImageIndex = imageIndex;\n    return imageIndex;\n  }\n  static getNextImageIndex(pImageIndex, TableIndex) {\n    let Addr;\n    let Ptr;\n    let ImageIndexMin;\n    let ImageIndexMax;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    Ptr = Addr;\n    while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n      ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n      ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if ((pImageIndex & 0xFF) < (ImageIndexMin & 0xFF)) {\n        return ImageIndexMin;\n      }\n      if ((pImageIndex & 0xFF) < (ImageIndexMax & 0xFF)) {\n        return pImageIndex + 1;\n      }\n    }\n    return -1;\n  }\n  static getLastImageIndex(pImageIndex, TableIndex) {\n    let ImageIndex = 0;\n    let hit = 0;\n    let counter = 0;\n    while (ImageIndex != -1) {\n      ImageIndex = this.getNextImageIndex(ImageIndex, TableIndex);\n      counter++;\n      if (ImageIndex != -1) {\n        pImageIndex = ImageIndex;\n      }\n      hit = 1;\n    }\n    if (hit == 0) {\n      return -1;\n    }\n    return pImageIndex;\n  }\n  static getPrevImageIndex(pImageIndex, TableIndex) {\n    let Addr;\n    let Ptr;\n    let ImageIndexMin;\n    let ImageIndexMax;\n    let windUp;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    if (pImageIndex == null) {\n      return -1;\n    }\n    Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    Ptr = Addr;\n    windUp = 0;\n    while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n      Ptr += 2;\n      windUp++;\n    }\n    while (windUp != 0) {\n      Ptr -= 2;\n      windUp--;\n      ImageIndexMin = ROM.byteAtAddr(Ptr) & 0xFF;\n      ImageIndexMax = ROM.byteAtAddr(Ptr + 1) & 0xFF;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if ((pImageIndex & 0xFF) > (ImageIndexMax & 0xFF)) {\n        pImageIndex = ImageIndexMax;\n        return pImageIndex;\n      }\n      if ((pImageIndex & 0xFF) > (ImageIndexMin & 0xFF)) {\n        pImageIndex = pImageIndex - 1;\n        return pImageIndex;\n      }\n    }\n    return -1;\n  }\n  static getROMAddressOfVariableSizedImageTable(TableIndex) {\n    const result = this.extractWPCAddrAndPageOfImageTable(TableIndex);\n    const Addr = result[0];\n    const Page = result[1];\n    if (Addr == -1) {\n      return -1;\n    }\n    const romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (romAddr == -1) {\n      return -1;\n    }\n    return romAddr;\n  }\n  static extractWPCAddrAndPageOfImageTable(TableIndex) {\n    let romAddr;\n    let Ptr;\n    let Addr;\n    let Page;\n    if (!VariableSizedImageData.TableAddress) {\n      return [-1, -1];\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return [-1, -1];\n    }\n    if (VariableSizedImageData.CurrentTableIndex < VariableSizedImageData.minTableIndex || VariableSizedImageData.CurrentTableIndex > VariableSizedImageData.maxTableIndex) {\n      return [-1, -1];\n    }\n    romAddr = DataParser.getAddrToWPCAddressOfVariableSizedImageTable(TableIndex);\n    if (romAddr == -1) {\n      return [-1, -1];\n    }\n    Ptr = romAddr;\n    Addr = ROM.byteAtAddr(Ptr) & 0xff;\n    Addr = Addr << 8;\n    Addr = Addr | ROM.byteAtAddr(Ptr + 1) & 0xff;\n    Addr = Addr & 0xffff;\n    Page = ROM.byteAtAddr(Ptr + 2) & 0xff;\n    {\n      let TempAddr;\n      let TempPage;\n      romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n      if (romAddr == -1) {\n        return [-1, -1];\n      }\n      Ptr = romAddr;\n      TempAddr = ROM.byteAtAddr(Ptr) & 0xff;\n      TempAddr = TempAddr << 8;\n      TempAddr = TempAddr | ROM.byteAtAddr(Ptr + 1) & 0xff;\n      TempAddr = TempAddr & 0xffff;\n      TempPage = ROM.byteAtAddr(Ptr + 2) & 0xff;\n      logStr(`Testing Tempaddr ${toHex(TempAddr)} and Page ${toHex(TempPage)}`);\n      if (TempAddr >= WPC.BaseCodeAddrPagedRom && TempAddr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) {\n        Addr = TempAddr;\n      }\n      logStr(`extractWPCAddrAndPageOfImageTable() FIXUP, Addr fixed to ${toHex(Addr)},${toHex(Page)}`);\n    }\n    return [Addr, Page];\n  }\n  static getROMAddressFromWPCAddrAndPage(Addr, Page) {\n    let romAddr;\n    if (Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      if (Page != WPC.NonpagedBankIndicator) {\n        logStr(`getROMAddressFromWPCAddrAndPage() Non-banked WPC addr ${Addr} followed by page byte ${Page}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n        Page = WPC.NonpagedBankIndicator;\n      }\n    }\n    if (Page == WPC.NonpagedBankIndicator && Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      romAddr = (ROM.totalPages - 2) * WPC.PageLength + (Addr - WPC.BaseCodeAddrNonpagedRom);\n    } else if (Page >= ROM.basePageIndex && Page < ROM.basePageIndex + ROM.totalPages - 2 && Addr >= WPC.BaseCodeAddrPagedRom && Addr < WPC.BaseCodeAddrNonpagedRom) {\n      romAddr = (Page - ROM.basePageIndex) * WPC.PageLength + (Addr - WPC.BaseCodeAddrPagedRom);\n    } else {\n      logStr(`Invalid WPC Addr and Page, ${toHex(Addr)},${toHex(Page)}, BasePage ${toHex(ROM.basePageIndex)}, TotalPages ${ROM.totalPages}`);\n      return -1;\n    }\n    if (romAddr >= ROM.size) {\n      logStr(`Unexpected: Calculated addr in ROM ${romAddr} is greater than determined ROM size ${ROM.size}`);\n      return -1;\n    }\n    return romAddr;\n  }\n  static getAddrToWPCAddressOfVariableSizedImageTable(TableIndex) {\n    let romAddr;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    romAddr = VariableSizedImageData.TableAddress + 3 * TableIndex;\n    if (romAddr >= ROM.size) {\n      return -1;\n    }\n    return romAddr;\n  }\n  static getROMAddressFromAddrOf3ByteWPCAddrPage(pSrc) {\n    let Addr;\n    let Page;\n    const result = DataParser.extractWPCAddrAndPageFromBuffer(pSrc);\n    Addr = result[0];\n    Page = result[1];\n    if (Addr == -1) {\n      logStr(`Error from ExtractWPCAddrAndPageFromBuffer(), Passed it ptr to: ${ROM.byteAtAddr(pSrc) & 0xFF} ${ROM.byteAtAddr(pSrc + 1) & 0xFF} ${ROM.byteAtAddr(pSrc + 2) & 0xFF}`);\n      return -1;\n    }\n    logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() WPC TableAddress ${toHex(Addr)},${toHex(Page)}`);\n    Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (Addr == -1) {\n      logStr(`Error from getROMAddressFromWPCAddrAndPage(), Passed it WPC Addr ${Addr},${Page}`);\n      return -1;\n    }\n    logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() ROM TableAddress ${toHex(Addr)}`);\n    return Addr;\n  }\n  static getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex) {\n    let Addr;\n    let Page;\n    let Ptr;\n    let TableHeight;\n    let TableSpacing;\n    let ImageIndexMin, ImageIndexMax, ImageNum, ImageFound;\n    Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    if (Addr >= ROM.size) {\n      return -1;\n    }\n    Ptr = Addr;\n    ImageNum = ImageFound = 0;\n    while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n      ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n      ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if (ImageFound == 0) {\n        while (ImageIndexMin <= ImageIndexMax) {\n          if (ImageIndex <= ImageIndexMin) {\n            logStr(`getROMAddressOfVariableSizedImageIndex() ImageFound, ImageNum ${ImageNum}, ImageIndexMin ${ImageIndexMin}, ImageIndexMax ${ImageIndexMax}`);\n            ImageFound = 1;\n            break;\n          }\n          ImageNum++;\n          ImageIndexMin++;\n        }\n      }\n    }\n    Ptr++;\n    TableHeight = ROM.byteAtAddr(Ptr++);\n    TableSpacing = ROM.byteAtAddr(Ptr++);\n    Ptr += ImageNum * 2;\n    Addr = ROM.byteAtAddr(Ptr) & 0xFF;\n    Addr = Addr << 8;\n    Addr |= ROM.byteAtAddr(Ptr + 1) & 0xFF;\n    Addr &= 0xFFFF;\n    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n    Page = result[1];\n    if (Page == -1) {\n      return -1;\n    }\n    Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (Addr == -1) {\n      return -1;\n    }\n    logStr(`getROMAddressOfVariableSizedImageIndex() TableHeight ${TableHeight}, TableSpacing ${TableSpacing} ImageIndex ${ImageIndex} at ${Addr}`);\n    return Addr;\n  }\n  static extractWPCAddrAndPageFromBuffer(pSrc) {\n    let Addr;\n    let Page;\n    Addr = ROM.byteAtAddr(pSrc) & 0xff;\n    Addr = Addr << 8;\n    Addr = Addr | ROM.byteAtAddr(pSrc + 1) & 0xff;\n    Addr = Addr & 0xffff;\n    Page = ROM.byteAtAddr(pSrc + 2) & 0xff;\n    if (Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      if (Page != WPC.NonpagedBankIndicator) {\n        logStr(`extractWPCAddrAndPageFromBuffer() Non-banked WPC addr ${toHex(Addr)} followed by page byte ${toHex(Page)}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n        Page = WPC.NonpagedBankIndicator;\n      }\n    }\n    if (Addr != null) {\n      if (Addr >= WPC.BaseCodeAddrPagedRom && Addr < WPC.BaseCodeAddrPagedRom + WPC.PageLength || Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {} else {\n        logStr(`Expected a WPC Addr, but read ${toHex(Addr)}`);\n        return [-1, -1];\n      }\n    }\n    if (Page != null) {\n      if (Page >= ROM.basePageIndex && Page < ROM.basePageIndex + ROM.totalPages || Page == WPC.NonpagedBankIndicator) {} else {\n        logStr(`Expected a WPC Page Number, but read ${Page}, Base is ${ROM.basePageIndex}, Total Pages ${ROM.totalPages}`);\n        return [-1, -1];\n      }\n    }\n    return [Addr, Page];\n  }\n  static processHitType(HitType, HitTablePtr, HitPagePtr, Ptr) {\n    let Addr;\n    let HitBuf = [0, 0, 0];\n    let pTbl;\n    switch (HitType) {\n      case HitTypes.AddrAddrAddr:\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xFF)}`);\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n        if (Addr == -1) {\n          logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xFF} ${HitTablePtr + 1 & 0xFF}`);\n          return -1;\n        }\n        logStr(`HitTypes.AddrAddrAddr derived ROM TableAddressAddress ${Addr}, going to HitTypes.AddrAddr`);\n        HitTablePtr = ROM.byteAtAddr(Addr);\n      case HitTypes.AddrAddr:\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xFF)}`);\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n        if (Addr == -1) {\n          logStr(`Error from GetROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xFF} ${HitTablePtr + 1 & 0xFF}`);\n          return -1;\n        }\n        logStr(`HitTypes.AddrAddr derived TableAddress of ${toHex(Addr)} going to HitTypes.Addr`);\n        HitTablePtr = Addr;\n        HitPagePtr = Addr + 2;\n      case HitTypes.Addr:\n        if (HitTablePtr == null) {\n          logStr(\"HitTypes.Addr, but HitTablePtr is NULL\");\n          return -1;\n        }\n        HitBuf[0] = HitTablePtr;\n        HitBuf[1] = HitTablePtr + 1;\n        if (HitPagePtr == null) {\n          let Addr;\n          Addr = HitBuf[0] & 0xff;\n          Addr = Addr << 8;\n          Addr = Addr | HitBuf[1] & 0xff;\n          Addr = Addr & 0xffff;\n          if (!(Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n            logStr(`HitTypes.Addr, but HitPagePtr is NULL, and Addr is in paged ROM`);\n            return -1;\n          }\n          HitBuf[2] = WPC.NonpagedBankIndicator;\n        } else {\n          HitBuf[2] = ROM.byteAtAddr(HitPagePtr);\n        }\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitBuf[0]) & 0xFF)} ${toHex(ROM.byteAtAddr(HitBuf[1]) & 0xFF)} ${toHex(HitBuf[2] & 0xFF)}`);\n        pTbl = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitBuf[0]);\n        if (pTbl != -1) {\n          logStr(\"Table Found!\");\n          return pTbl;\n        }\n        logStr(`Error deriving table addr from hit, HitType ${Ptr - 1 & 0xFF}, HitBytes ${HitBuf[0] & 0xFF} ${HitBuf[1] & 0xFF} ${HitBuf[2] & 0xFF}. Will keep looking. May need to debug by opening window while pressing <shift>`);\n        break;\n      case HitTypes.None:\n        return 0;\n      default:\n        logStr(\"Unexpected HitType\");\n        break;\n    }\n    return -1;\n  }\n  static preAnalyzeVariableSizedImageTable() {\n    let Ptr;\n    let Addr;\n    let TableCount = 0;\n    if (!VariableSizedImageData.TableAddress) {\n      logStr(`Unexpected NULL ${VariableSizedImageData.TableAddress}`);\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      logStr(`Unexpected table address ${VariableSizedImageData.TableAddress} is >= ${ROM.size}`);\n    }\n    Ptr = VariableSizedImageData.TableAddress;\n    let continueLooping = true;\n    while (continueLooping) {\n      Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Ptr);\n      if (Addr == -1) {\n        continueLooping = false;\n      } else {\n        VariableSizedImageData.maxTableIndex++;\n        if (DataParser.getLastImageIndex(-1, VariableSizedImageData.maxTableIndex - 1) == -1) {\n          VariableSizedImageData.maxTableIndex--;\n          logStr(`Stopped looking for image tables due to getLastImageIndex() error on TableIndex ${VariableSizedImageData.maxTableIndex}`);\n          continueLooping = false;\n        }\n        Ptr += 3;\n        TableCount++;\n      }\n    }\n    logStr(`Determined TableCount: ${TableCount}%d`);\n    if (TableCount == 0) {\n      logStr(\"Found 0 table entries\");\n      return -1;\n    }\n    VariableSizedImageData.minTableIndex = 0;\n    VariableSizedImageData.maxTableIndex = TableCount - 1;\n    VariableSizedImageData.maxImageIndex = DataParser.getLastImageIndex(VariableSizedImageData.maxImageIndex, VariableSizedImageData.maxTableIndex);\n    if (VariableSizedImageData.maxImageIndex == -1) {\n      logStr(`Error looking up max image index for last table index ${VariableSizedImageData.maxTableIndex}`);\n      return -1;\n    }\n    VariableSizedImageData.minImageIndex = DataParser.getFirstImageIndex(VariableSizedImageData.minTableIndex);\n    if (VariableSizedImageData.minTableIndex == -1) {\n      logStr(`Error looking up min image index for first table index ${VariableSizedImageData.maxTableIndex})`);\n      return -1;\n    }\n    logStr(`Determined maxTableIndex ${VariableSizedImageData.maxTableIndex}, maxImageIndex ${VariableSizedImageData.maxImageIndex}`);\n    return 0;\n  }\n  static getVariableSizedImageTableMetadata(TableIndex) {\n    let Addr;\n    let Ptr;\n    let TableHeight;\n    let TableSpacing;\n    Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return [-1, -1];\n    }\n    if (Addr >= ROM.size) {\n      return [-1, -1];\n    }\n    Ptr = Addr;\n    while ((ROM.byteAtAddr(Ptr++) & 0xFF) != 0x00);\n    TableHeight = ROM.byteAtAddr(Ptr++);\n    TableSpacing = ROM.byteAtAddr(Ptr++);\n    return [TableHeight, TableSpacing];\n  }\n}","map":{"version":3,"names":["HitTypes","DataTypes","WPC","toHex","logStr","Settings","VariableSizedImageData","FullFrameImageData","ROM","DataParser","constructor","init","romData","dataType","instance","initTableAddrs","Page","PageByteIdx","HitTablePtr","HitPagePtr","RomAddr","WpcAddr","Ptr","totalPages","PageLength","byteAtAddr","getROMAddressFromAddrOf3ByteWPCAddrPage","DataType","FontData","TableAddress","processHitType","AddrAddr","BaseCodeAddrNonpagedRom","NonpagedLength","NonpagedBankIndicator","Addr","AniData","startPtr","getFirstImageIndex","TableIndex","imageIndex","getNextImageIndex","CurrentImageIndex","pImageIndex","ImageIndexMin","ImageIndexMax","size","minTableIndex","maxTableIndex","getROMAddressOfVariableSizedImageTable","getLastImageIndex","ImageIndex","hit","counter","getPrevImageIndex","windUp","result","extractWPCAddrAndPageOfImageTable","romAddr","getROMAddressFromWPCAddrAndPage","CurrentTableIndex","getAddrToWPCAddressOfVariableSizedImageTable","TempAddr","TempPage","BaseCodeAddrPagedRom","basePageIndex","pSrc","extractWPCAddrAndPageFromBuffer","getROMAddressOfVariableSizedImageIndex","TableHeight","TableSpacing","ImageNum","ImageFound","HitType","HitBuf","pTbl","AddrAddrAddr","None","preAnalyzeVariableSizedImageTable","TableCount","continueLooping","maxImageIndex","minImageIndex","getVariableSizedImageTableMetadata"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/node_modules/wpcedit/dist/src/classes/DataParser.js"],"sourcesContent":["import { HitTypes, DataTypes, WPC } from \"../resources/Constants.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { Settings } from \"../stores/Settings.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DataParser {\n    constructor() {\n    }\n    static init(romData, dataType) {\n        if (DataParser.instance) {\n            return this.instance;\n        }\n        this.instance = new DataParser();\n        return this.instance;\n    }\n    static initTableAddrs() {\n        let Page;\n        let PageByteIdx;\n        let HitTablePtr;\n        let HitPagePtr;\n        let RomAddr;\n        let WpcAddr;\n        let Ptr = 0;\n        logStr(`Searching ROM for Master Animation Table Address`);\n        for (Page = 0; Page < ROM.totalPages; Page++) {\n            for (PageByteIdx = 0; PageByteIdx < WPC.PageLength; PageByteIdx++) {\n                switch (ROM.byteAtAddr(Ptr++) & 0xFF) {\n                    case 0xBE:\n                        if (PageByteIdx >= WPC.PageLength - 16) {\n                            break;\n                        }\n                        if ((ROM.byteAtAddr(Ptr + 2) & 0xff) == 0x3a &&\n                            (ROM.byteAtAddr(Ptr + 3) & 0xff) == 0x58 &&\n                            (ROM.byteAtAddr(Ptr + 4) & 0xff) == 0x3a &&\n                            (ROM.byteAtAddr(Ptr + 5) & 0xff) == 0xd6 &&\n                            (ROM.byteAtAddr(Ptr + 7) & 0xff) == 0x34 &&\n                            (ROM.byteAtAddr(Ptr + 8) & 0xff) == 0x04 &&\n                            ((ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xf6 || (ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xbd) &&\n                            ((ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xbd || (ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xf6)) {\n                            HitTablePtr = Ptr;\n                            HitPagePtr = Ptr + 2;\n                            RomAddr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                            if (RomAddr == -1) {\n                                logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Font Table Pointer opcode: ${toHex((HitTablePtr) & 0xFF)} ${toHex(((HitTablePtr + 1)) & 0xFF)}`);\n                                return -1;\n                            }\n                            logStr(`Address in ROM of Font Table Pointer ${toHex(RomAddr)}`);\n                            if (Settings.DataType == DataTypes.FontData) {\n                                VariableSizedImageData.TableAddress = DataParser.processHitType(HitTypes.AddrAddr, HitTablePtr, HitPagePtr, Ptr);\n                                if (VariableSizedImageData.TableAddress == -1) {\n                                    logStr(`Error from ProcessHitType while trying to process Font Table Pointer opcode: ${toHex((HitTablePtr) & 0xFF)} ${toHex(((HitTablePtr + 1)) & 0xFF)}`);\n                                    break;\n                                }\n                                logStr(`Found Address in ROM of Font Table ${toHex(VariableSizedImageData.TableAddress)}`);\n                            }\n                            HitTablePtr = RomAddr;\n                            HitPagePtr = RomAddr + 2;\n                            WpcAddr =\n                                ((ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff)) &\n                                    0xffff;\n                            if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom &&\n                                WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength &&\n                                ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                                RomAddr += 2;\n                            }\n                            else {\n                                RomAddr += 3;\n                            }\n                            logStr(`Address in ROM of Graphics Table Pointer ${toHex(RomAddr)}`);\n                            HitTablePtr = (RomAddr);\n                            HitPagePtr = (RomAddr + 2);\n                            FullFrameImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n                            if (FullFrameImageData.TableAddress == -1) {\n                                logStr(`Error from processHitType while trying to process Graphic Table Pointer: ${toHex((HitTablePtr) & 0xFF)} ${toHex(((HitTablePtr + 1)) & 0xFF)}`);\n                                if (Settings.DataType == DataTypes.FontData) {\n                                    return 0;\n                                }\n                                return -1;\n                            }\n                            logStr(`Found Address in ROM of Graphics Table ${toHex(FullFrameImageData.TableAddress)}`);\n                            if (Settings.DataType != DataTypes.AniData) {\n                                return 0;\n                            }\n                            HitTablePtr = ROM.byteAtAddr(RomAddr);\n                            HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n                            WpcAddr =\n                                ((ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff)) &\n                                    0xffff;\n                            if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom &&\n                                WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength &&\n                                ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                                RomAddr += 2;\n                            }\n                            else {\n                                RomAddr += 3;\n                            }\n                            logStr(`Address in ROM of Animation Table Pointer ${toHex(RomAddr)}`);\n                            HitTablePtr = ROM.byteAtAddr(RomAddr);\n                            HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n                            VariableSizedImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n                            if (VariableSizedImageData.TableAddress == -1) {\n                                logStr(`Error from processHitType while trying to process Animation Table Pointer: ${(HitTablePtr) & 0xFF} ${((HitTablePtr + 1)) & 0xFF}`);\n                                return -1;\n                            }\n                            logStr(`Found Address in ROM of Animation Table ${toHex(VariableSizedImageData.TableAddress)}`);\n                            ROM.startPtr = Ptr;\n                            return 0;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n    static getFirstImageIndex(TableIndex) {\n        const imageIndex = this.getNextImageIndex(0, TableIndex);\n        if (imageIndex == -1) {\n            return -1;\n        }\n        VariableSizedImageData.CurrentImageIndex = imageIndex;\n        return imageIndex;\n    }\n    static getNextImageIndex(pImageIndex, TableIndex) {\n        let Addr;\n        let Ptr;\n        let ImageIndexMin;\n        let ImageIndexMax;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if ((TableIndex < VariableSizedImageData.minTableIndex) || (TableIndex > VariableSizedImageData.maxTableIndex)) {\n            return -1;\n        }\n        Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        Ptr = Addr;\n        while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n            ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n            ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if ((pImageIndex & 0xFF) < (ImageIndexMin & 0xFF)) {\n                return ImageIndexMin;\n            }\n            if ((pImageIndex & 0xFF) < (ImageIndexMax & 0xFF)) {\n                return pImageIndex + 1;\n            }\n        }\n        return -1;\n    }\n    static getLastImageIndex(pImageIndex, TableIndex) {\n        let ImageIndex = 0;\n        let hit = 0;\n        let counter = 0;\n        while ((ImageIndex != -1)) {\n            ImageIndex = this.getNextImageIndex(ImageIndex, TableIndex);\n            counter++;\n            if (ImageIndex != -1) {\n                pImageIndex = ImageIndex;\n            }\n            hit = 1;\n        }\n        if (hit == 0) {\n            return -1;\n        }\n        return pImageIndex;\n    }\n    static getPrevImageIndex(pImageIndex, TableIndex) {\n        let Addr;\n        let Ptr;\n        let ImageIndexMin;\n        let ImageIndexMax;\n        let windUp;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if ((TableIndex < VariableSizedImageData.minTableIndex) || (TableIndex > VariableSizedImageData.maxTableIndex)) {\n            return -1;\n        }\n        if (pImageIndex == null) {\n            return -1;\n        }\n        Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        Ptr = Addr;\n        windUp = 0;\n        while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n            Ptr += 2;\n            windUp++;\n        }\n        while (windUp != 0) {\n            Ptr -= 2;\n            windUp--;\n            ImageIndexMin = ROM.byteAtAddr(Ptr) & 0xFF;\n            ImageIndexMax = ROM.byteAtAddr((Ptr + 1)) & 0xFF;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if (((pImageIndex) & 0xFF) > (ImageIndexMax & 0xFF)) {\n                pImageIndex = ImageIndexMax;\n                return pImageIndex;\n            }\n            if (((pImageIndex) & 0xFF) > (ImageIndexMin & 0xFF)) {\n                pImageIndex = (pImageIndex) - 1;\n                return pImageIndex;\n            }\n        }\n        return -1;\n    }\n    static getROMAddressOfVariableSizedImageTable(TableIndex) {\n        const result = this.extractWPCAddrAndPageOfImageTable(TableIndex);\n        const Addr = result[0];\n        const Page = result[1];\n        if (Addr == -1) {\n            return -1;\n        }\n        const romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (romAddr == -1) {\n            return -1;\n        }\n        return romAddr;\n    }\n    static extractWPCAddrAndPageOfImageTable(TableIndex) {\n        let romAddr;\n        let Ptr;\n        let Addr;\n        let Page;\n        if (!VariableSizedImageData.TableAddress) {\n            return [-1, -1];\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return [-1, -1];\n        }\n        if (VariableSizedImageData.CurrentTableIndex <\n            VariableSizedImageData.minTableIndex ||\n            VariableSizedImageData.CurrentTableIndex >\n                VariableSizedImageData.maxTableIndex) {\n            return [-1, -1];\n        }\n        romAddr = DataParser.getAddrToWPCAddressOfVariableSizedImageTable(TableIndex);\n        if (romAddr == -1) {\n            return [-1, -1];\n        }\n        Ptr = romAddr;\n        Addr = ROM.byteAtAddr(Ptr) & 0xff;\n        Addr = Addr << 8;\n        Addr = Addr | (ROM.byteAtAddr(Ptr + 1) & 0xff);\n        Addr = Addr & 0xffff;\n        Page = ROM.byteAtAddr(Ptr + 2) & 0xff;\n        {\n            let TempAddr;\n            let TempPage;\n            romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n            if (romAddr == -1) {\n                return [-1, -1];\n            }\n            Ptr = romAddr;\n            TempAddr = ROM.byteAtAddr(Ptr) & 0xff;\n            TempAddr = TempAddr << 8;\n            TempAddr = TempAddr | (ROM.byteAtAddr(Ptr + 1) & 0xff);\n            TempAddr = TempAddr & 0xffff;\n            TempPage = ROM.byteAtAddr(Ptr + 2) & 0xff;\n            logStr(`Testing Tempaddr ${toHex(TempAddr)} and Page ${toHex(TempPage)}`);\n            if (TempAddr >= WPC.BaseCodeAddrPagedRom &&\n                TempAddr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) {\n                Addr = TempAddr;\n            }\n            logStr(`extractWPCAddrAndPageOfImageTable() FIXUP, Addr fixed to ${toHex(Addr)},${toHex(Page)}`);\n        }\n        return [Addr, Page];\n    }\n    static getROMAddressFromWPCAddrAndPage(Addr, Page) {\n        let romAddr;\n        if (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            if (Page != WPC.NonpagedBankIndicator) {\n                logStr(`getROMAddressFromWPCAddrAndPage() Non-banked WPC addr ${Addr} followed by page byte ${Page}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n                Page = WPC.NonpagedBankIndicator;\n            }\n        }\n        if (Page == WPC.NonpagedBankIndicator &&\n            Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            romAddr =\n                (ROM.totalPages - 2) * WPC.PageLength +\n                    (Addr - WPC.BaseCodeAddrNonpagedRom);\n        }\n        else if (Page >= ROM.basePageIndex &&\n            Page < ROM.basePageIndex + ROM.totalPages - 2 &&\n            Addr >= WPC.BaseCodeAddrPagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom) {\n            romAddr =\n                (Page - ROM.basePageIndex) * WPC.PageLength +\n                    (Addr - WPC.BaseCodeAddrPagedRom);\n        }\n        else {\n            logStr(`Invalid WPC Addr and Page, ${toHex(Addr)},${toHex(Page)}, BasePage ${toHex(ROM.basePageIndex)}, TotalPages ${ROM.totalPages}`);\n            return -1;\n        }\n        if (romAddr >= ROM.size) {\n            logStr(`Unexpected: Calculated addr in ROM ${romAddr} is greater than determined ROM size ${ROM.size}`);\n            return -1;\n        }\n        return romAddr;\n    }\n    static getAddrToWPCAddressOfVariableSizedImageTable(TableIndex) {\n        let romAddr;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if (TableIndex < VariableSizedImageData.minTableIndex ||\n            TableIndex > VariableSizedImageData.maxTableIndex) {\n            return -1;\n        }\n        romAddr = VariableSizedImageData.TableAddress + 3 * TableIndex;\n        if (romAddr >= ROM.size) {\n            return -1;\n        }\n        return romAddr;\n    }\n    static getROMAddressFromAddrOf3ByteWPCAddrPage(pSrc) {\n        let Addr;\n        let Page;\n        const result = DataParser.extractWPCAddrAndPageFromBuffer((pSrc));\n        Addr = result[0];\n        Page = result[1];\n        if (Addr == -1) {\n            logStr(`Error from ExtractWPCAddrAndPageFromBuffer(), Passed it ptr to: ${ROM.byteAtAddr(pSrc) & 0xFF} ${(ROM.byteAtAddr(pSrc + 1)) & 0xFF} ${(ROM.byteAtAddr(pSrc + 2)) & 0xFF}`);\n            return -1;\n        }\n        logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() WPC TableAddress ${toHex(Addr)},${toHex(Page)}`);\n        Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (Addr == -1) {\n            logStr(`Error from getROMAddressFromWPCAddrAndPage(), Passed it WPC Addr ${Addr},${Page}`);\n            return -1;\n        }\n        logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() ROM TableAddress ${toHex(Addr)}`);\n        return Addr;\n    }\n    static getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex) {\n        let Addr;\n        let Page;\n        let Ptr;\n        let TableHeight;\n        let TableSpacing;\n        let ImageIndexMin, ImageIndexMax, ImageNum, ImageFound;\n        Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        if (Addr >= ROM.size) {\n            return -1;\n        }\n        Ptr = Addr;\n        ImageNum = ImageFound = 0;\n        while ((ROM.byteAtAddr(Ptr) & 0xFF) != 0x00) {\n            ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xFF;\n            ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xFF;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if (ImageFound == 0) {\n                while (ImageIndexMin <= ImageIndexMax) {\n                    if (ImageIndex <= ImageIndexMin) {\n                        logStr(`getROMAddressOfVariableSizedImageIndex() ImageFound, ImageNum ${ImageNum}, ImageIndexMin ${ImageIndexMin}, ImageIndexMax ${ImageIndexMax}`);\n                        ImageFound = 1;\n                        break;\n                    }\n                    ImageNum++;\n                    ImageIndexMin++;\n                }\n            }\n        }\n        Ptr++;\n        TableHeight = ROM.byteAtAddr(Ptr++);\n        TableSpacing = ROM.byteAtAddr(Ptr++);\n        Ptr += (ImageNum * 2);\n        Addr = (ROM.byteAtAddr(Ptr)) & 0xFF;\n        Addr = Addr << 8;\n        Addr |= (ROM.byteAtAddr(Ptr + 1)) & 0xFF;\n        Addr &= 0xFFFF;\n        const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n        Page = result[1];\n        if (Page == -1) {\n            return -1;\n        }\n        Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (Addr == -1) {\n            return -1;\n        }\n        logStr(`getROMAddressOfVariableSizedImageIndex() TableHeight ${TableHeight}, TableSpacing ${TableSpacing} ImageIndex ${ImageIndex} at ${Addr}`);\n        return Addr;\n    }\n    static extractWPCAddrAndPageFromBuffer(pSrc) {\n        let Addr;\n        let Page;\n        Addr = ROM.byteAtAddr(pSrc) & 0xff;\n        Addr = Addr << 8;\n        Addr = Addr | ROM.byteAtAddr(pSrc + 1) & 0xff;\n        Addr = Addr & 0xffff;\n        Page = ROM.byteAtAddr(pSrc + 2) & 0xff;\n        if (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            if (Page != WPC.NonpagedBankIndicator) {\n                logStr(`extractWPCAddrAndPageFromBuffer() Non-banked WPC addr ${toHex(Addr)} followed by page byte ${toHex(Page)}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n                Page = WPC.NonpagedBankIndicator;\n            }\n        }\n        if (Addr != null) {\n            if ((Addr >= WPC.BaseCodeAddrPagedRom &&\n                Addr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) ||\n                (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n                    Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n            }\n            else {\n                logStr(`Expected a WPC Addr, but read ${toHex(Addr)}`);\n                return [-1, -1];\n            }\n        }\n        if (Page != null) {\n            if ((Page >= ROM.basePageIndex &&\n                Page < ROM.basePageIndex + ROM.totalPages) ||\n                Page == WPC.NonpagedBankIndicator) {\n            }\n            else {\n                logStr(`Expected a WPC Page Number, but read ${Page}, Base is ${ROM.basePageIndex}, Total Pages ${ROM.totalPages}`);\n                return [-1, -1];\n            }\n        }\n        return [Addr, Page];\n    }\n    static processHitType(HitType, HitTablePtr, HitPagePtr, Ptr) {\n        let Addr;\n        let HitBuf = [0, 0, 0];\n        let pTbl;\n        switch (HitType) {\n            case HitTypes.AddrAddrAddr:\n                logStr(`Potential Match. HitType ${toHex((ROM.byteAtAddr(Ptr - 1)) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex(ROM.byteAtAddr((HitTablePtr + 1)) & 0xFF)}`);\n                Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                if (Addr == -1) {\n                    logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${((HitTablePtr) & 0xFF)} ${((HitTablePtr + 1)) & 0xFF}`);\n                    return -1;\n                }\n                logStr(`HitTypes.AddrAddrAddr derived ROM TableAddressAddress ${Addr}, going to HitTypes.AddrAddr`);\n                HitTablePtr = ROM.byteAtAddr(Addr);\n            case HitTypes.AddrAddr:\n                logStr(`Potential Match. HitType ${toHex((ROM.byteAtAddr(Ptr - 1)) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xFF)} ${toHex((ROM.byteAtAddr(HitTablePtr + 1)) & 0xFF)}`);\n                Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                if (Addr == -1) {\n                    logStr(`Error from GetROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${(HitTablePtr) & 0xFF} ${((HitTablePtr + 1)) & 0xFF}`);\n                    return -1;\n                }\n                logStr(`HitTypes.AddrAddr derived TableAddress of ${toHex(Addr)} going to HitTypes.Addr`);\n                HitTablePtr = Addr;\n                HitPagePtr = Addr + 2;\n            case HitTypes.Addr:\n                if (HitTablePtr == null) {\n                    logStr(\"HitTypes.Addr, but HitTablePtr is NULL\");\n                    return -1;\n                }\n                HitBuf[0] = (HitTablePtr);\n                HitBuf[1] = (HitTablePtr + 1);\n                if (HitPagePtr == null) {\n                    let Addr;\n                    Addr = HitBuf[0] & 0xff;\n                    Addr = Addr << 8;\n                    Addr = Addr | (HitBuf[1] & 0xff);\n                    Addr = Addr & 0xffff;\n                    if (!(Addr >= WPC.BaseCodeAddrNonpagedRom &&\n                        Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n                        logStr(`HitTypes.Addr, but HitPagePtr is NULL, and Addr is in paged ROM`);\n                        return -1;\n                    }\n                    HitBuf[2] = WPC.NonpagedBankIndicator;\n                }\n                else {\n                    HitBuf[2] = ROM.byteAtAddr(HitPagePtr);\n                }\n                logStr(`Potential Match. HitType ${toHex((ROM.byteAtAddr(Ptr - 1)) & 0xFF)}, HitBytes ${toHex(ROM.byteAtAddr(HitBuf[0]) & 0xFF)} ${toHex(ROM.byteAtAddr((HitBuf[1])) & 0xFF)} ${toHex(((HitBuf[2])) & 0xFF)}`);\n                pTbl = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitBuf[0]);\n                if (pTbl != -1) {\n                    logStr(\"Table Found!\");\n                    return pTbl;\n                }\n                logStr(`Error deriving table addr from hit, HitType ${((Ptr - 1)) & 0xFF}, HitBytes ${(HitBuf[0]) & 0xFF} ${((HitBuf[1])) & 0xFF} ${((HitBuf[2])) & 0xFF}. Will keep looking. May need to debug by opening window while pressing <shift>`);\n                break;\n            case HitTypes.None:\n                return 0;\n            default:\n                logStr(\"Unexpected HitType\");\n                break;\n        }\n        return -1;\n    }\n    static preAnalyzeVariableSizedImageTable() {\n        let Ptr;\n        let Addr;\n        let TableCount = 0;\n        if (!VariableSizedImageData.TableAddress) {\n            logStr(`Unexpected NULL ${VariableSizedImageData.TableAddress}`);\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            logStr(`Unexpected table address ${VariableSizedImageData.TableAddress} is >= ${ROM.size}`);\n        }\n        Ptr = VariableSizedImageData.TableAddress;\n        let continueLooping = true;\n        while (continueLooping) {\n            Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Ptr);\n            if (Addr == -1) {\n                continueLooping = false;\n            }\n            else {\n                VariableSizedImageData.maxTableIndex++;\n                if (DataParser.getLastImageIndex(-1, (VariableSizedImageData.maxTableIndex - 1)) == -1) {\n                    VariableSizedImageData.maxTableIndex--;\n                    logStr(`Stopped looking for image tables due to getLastImageIndex() error on TableIndex ${VariableSizedImageData.maxTableIndex}`);\n                    continueLooping = false;\n                }\n                Ptr += 3;\n                TableCount++;\n            }\n        }\n        logStr(`Determined TableCount: ${TableCount}%d`);\n        if (TableCount == 0) {\n            logStr(\"Found 0 table entries\");\n            return -1;\n        }\n        VariableSizedImageData.minTableIndex = 0;\n        VariableSizedImageData.maxTableIndex = (TableCount - 1);\n        VariableSizedImageData.maxImageIndex = DataParser.getLastImageIndex(VariableSizedImageData.maxImageIndex, VariableSizedImageData.maxTableIndex);\n        if (VariableSizedImageData.maxImageIndex == -1) {\n            logStr(`Error looking up max image index for last table index ${VariableSizedImageData.maxTableIndex}`);\n            return -1;\n        }\n        VariableSizedImageData.minImageIndex = DataParser.getFirstImageIndex(VariableSizedImageData.minTableIndex);\n        if (VariableSizedImageData.minTableIndex == -1) {\n            logStr(`Error looking up min image index for first table index ${VariableSizedImageData.maxTableIndex})`);\n            return -1;\n        }\n        logStr(`Determined maxTableIndex ${VariableSizedImageData.maxTableIndex}, maxImageIndex ${VariableSizedImageData.maxImageIndex}`);\n        return 0;\n    }\n    static getVariableSizedImageTableMetadata(TableIndex) {\n        let Addr;\n        let Ptr;\n        let TableHeight;\n        let TableSpacing;\n        Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return [-1, -1];\n        }\n        if (Addr >= ROM.size) {\n            return [-1, -1];\n        }\n        Ptr = (Addr);\n        while ((ROM.byteAtAddr(Ptr++) & 0xFF) != 0x00)\n            ;\n        TableHeight = ROM.byteAtAddr(Ptr++);\n        TableSpacing = ROM.byteAtAddr(Ptr++);\n        return [TableHeight, TableSpacing];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}