{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*!\n * @pixi/filter-kawase-blur - v5.1.1\n * Compiled Wed, 11 Jan 2023 23:10:33 UTC\n *\n * @pixi/filter-kawase-blur is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Filter as m, Point as h } from \"@pixi/core\";\nvar c = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`,\n  v = `\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}`,\n  y = `\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n`;\nclass _ extends m {\n  constructor(e = 4, t = 3, i = !1) {\n    super(c, i ? y : v), this._kernels = [], this._blur = 4, this._quality = 3, this.uniforms.uOffset = new Float32Array(2), this._pixelSize = new h(), this.pixelSize = 1, this._clamp = i, Array.isArray(e) ? this.kernels = e : (this._blur = e, this.quality = t);\n  }\n  apply(e, t, i, o) {\n    const n = this._pixelSize.x / t._frame.width,\n      l = this._pixelSize.y / t._frame.height;\n    let r;\n    if (this._quality === 1 || this._blur === 0) r = this._kernels[0] + .5, this.uniforms.uOffset[0] = r * n, this.uniforms.uOffset[1] = r * l, e.applyFilter(this, t, i, o);else {\n      const x = e.getFilterTexture();\n      let s = t,\n        u = x,\n        f;\n      const p = this._quality - 1;\n      for (let a = 0; a < p; a++) r = this._kernels[a] + .5, this.uniforms.uOffset[0] = r * n, this.uniforms.uOffset[1] = r * l, e.applyFilter(this, s, u, 1), f = s, s = u, u = f;\n      r = this._kernels[p] + .5, this.uniforms.uOffset[0] = r * n, this.uniforms.uOffset[1] = r * l, e.applyFilter(this, s, i, o), e.returnFilterTexture(x);\n    }\n  }\n  _updatePadding() {\n    this.padding = Math.ceil(this._kernels.reduce((e, t) => e + t + .5, 0));\n  }\n  _generateKernels() {\n    const e = this._blur,\n      t = this._quality,\n      i = [e];\n    if (e > 0) {\n      let o = e;\n      const n = e / t;\n      for (let l = 1; l < t; l++) o -= n, i.push(o);\n    }\n    this._kernels = i, this._updatePadding();\n  }\n  get kernels() {\n    return this._kernels;\n  }\n  set kernels(e) {\n    Array.isArray(e) && e.length > 0 ? (this._kernels = e, this._quality = e.length, this._blur = Math.max(...e)) : (this._kernels = [0], this._quality = 1);\n  }\n  get clamp() {\n    return this._clamp;\n  }\n  set pixelSize(e) {\n    typeof e == \"number\" ? (this._pixelSize.x = e, this._pixelSize.y = e) : Array.isArray(e) ? (this._pixelSize.x = e[0], this._pixelSize.y = e[1]) : e instanceof h ? (this._pixelSize.x = e.x, this._pixelSize.y = e.y) : (this._pixelSize.x = 1, this._pixelSize.y = 1);\n  }\n  get pixelSize() {\n    return this._pixelSize;\n  }\n  get quality() {\n    return this._quality;\n  }\n  set quality(e) {\n    this._quality = Math.max(1, Math.round(e)), this._generateKernels();\n  }\n  get blur() {\n    return this._blur;\n  }\n  set blur(e) {\n    this._blur = e, this._generateKernels();\n  }\n}\nexport { _ as KawaseBlurFilter };","map":{"version":3,"mappings":"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","names":["KawaseBlurFilter","Filter","constructor","blur","quality","clamp","vertex","fragmentClamp","fragment","_kernels","_blur","_quality","uniforms","uOffset","Float32Array","_pixelSize","Point","pixelSize","_clamp","Array","isArray","kernels","apply","filterManager","input","output","clear","uvX","x","_frame","width","uvY","y","height","offset","applyFilter","renderTarget","getFilterTexture","source","target","tmp","last","i","returnFilterTexture","_updatePadding","padding","Math","ceil","reduce","acc","v","_generateKernels","k","step","push","value","length","max","round"],"sources":["../src/KawaseBlurFilter.ts"],"sourcesContent":["import { vertex } from '@tools/fragments';\nimport fragment from './kawase-blur.frag';\nimport fragmentClamp from './kawase-blur-clamp.frag';\nimport { Filter, Point } from '@pixi/core';\nimport type { IPoint, CLEAR_MODES, FilterSystem, RenderTexture } from '@pixi/core';\n\ntype PixelSizeValue = IPoint | number[] | number;\n\n/**\n * A much faster blur than Gaussian blur, but more complicated to use.<br>\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/kawase-blur.png)\n *\n * @see https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms\n * @class\n * @extends PIXI.Filter\n * @see {@link https://www.npmjs.com/package/@pixi/filter-kawase-blur|@pixi/filter-kawase-blur}\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n */\nclass KawaseBlurFilter extends Filter\n{\n    private _pixelSize: Point;\n    private _clamp: boolean;\n    private _kernels: number[] = [];\n    private _blur = 4;\n    private _quality = 3;\n\n    /**\n     * @param {number|number[]} [blur=4] - The blur of the filter. Should be greater than `0`. If\n     *        value is an Array, setting kernels.\n     * @param {number} [quality=3] - The quality of the filter. Should be an integer greater than `1`.\n     * @param {boolean} [clamp=false] - Clamp edges, useful for removing dark edges\n     *        from fullscreen filters or bleeding to the edge of filterArea.\n     */\n    constructor(blur: number | number[] = 4, quality = 3, clamp = false)\n    {\n        super(vertex, clamp ? fragmentClamp : fragment);\n        this.uniforms.uOffset = new Float32Array(2);\n\n        this._pixelSize = new Point();\n        this.pixelSize = 1;\n        this._clamp = clamp;\n\n        // if `blur` is array , as kernels\n        if (Array.isArray(blur))\n        {\n            this.kernels = blur;\n        }\n        else\n        {\n            this._blur = blur;\n            this.quality = quality;\n        }\n    }\n\n    /**\n     * Overrides apply\n     * @private\n     */\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clear: CLEAR_MODES): void\n    {\n        const uvX = this._pixelSize.x / input._frame.width;\n        const uvY = this._pixelSize.y / input._frame.height;\n        let offset;\n\n        if (this._quality === 1 || this._blur === 0)\n        {\n            offset = this._kernels[0] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, input, output, clear);\n        }\n        else\n        {\n            const renderTarget = filterManager.getFilterTexture();\n\n            let source = input;\n            let target = renderTarget;\n            let tmp;\n\n            const last = this._quality - 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                offset = this._kernels[i] + 0.5;\n                this.uniforms.uOffset[0] = offset * uvX;\n                this.uniforms.uOffset[1] = offset * uvY;\n                filterManager.applyFilter(this, source, target, 1);\n\n                tmp = source;\n                source = target;\n                target = tmp;\n            }\n            offset = this._kernels[last] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, source, output, clear);\n\n            filterManager.returnFilterTexture(renderTarget);\n        }\n    }\n\n    private _updatePadding()\n    {\n        this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n    }\n\n    /**\n     * Auto generate kernels by blur & quality\n     * @private\n     */\n    private _generateKernels()\n    {\n        const blur = this._blur;\n        const quality = this._quality;\n        const kernels: number[] = [blur];\n\n        if (blur > 0)\n        {\n            let k = blur;\n            const step = blur / quality;\n\n            for (let i = 1; i < quality; i++)\n            {\n                k -= step;\n                kernels.push(k);\n            }\n        }\n\n        this._kernels = kernels;\n\n        this._updatePadding();\n    }\n\n    /**\n     * The kernel size of the blur filter, for advanced usage.\n     * @default [0]\n     */\n    get kernels(): number[]\n    {\n        return this._kernels;\n    }\n    set kernels(value: number[])\n    {\n        if (Array.isArray(value) && value.length > 0)\n        {\n            this._kernels = value;\n            this._quality = value.length;\n            this._blur = Math.max(...value);\n        }\n        else\n        {\n            // if value is invalid , set default value\n            this._kernels = [0];\n            this._quality = 1;\n        }\n    }\n\n    /**\n     * Get the if the filter is clampped.\n     *\n     * @readonly\n     * @default false\n     */\n    get clamp(): boolean\n    {\n        return this._clamp;\n    }\n\n    /**\n     * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.\n     *\n     * @member {PIXI.Point|number[]}\n     * @default [1, 1]\n     */\n    set pixelSize(value: PixelSizeValue)\n    {\n        if (typeof value === 'number')\n        {\n            this._pixelSize.x = value;\n            this._pixelSize.y = value;\n        }\n        else if (Array.isArray(value))\n        {\n            this._pixelSize.x = value[0];\n            this._pixelSize.y = value[1];\n        }\n        else if (value instanceof Point)\n        {\n            this._pixelSize.x = value.x;\n            this._pixelSize.y = value.y;\n        }\n        else\n        {\n            // if value is invalid , set default value\n            this._pixelSize.x = 1;\n            this._pixelSize.y = 1;\n        }\n    }\n    get pixelSize(): PixelSizeValue\n    {\n        return this._pixelSize;\n    }\n\n    /**\n     * The quality of the filter, integer greater than `1`.\n     * @default 3\n     */\n    get quality(): number\n    {\n        return this._quality;\n    }\n    set quality(value: number)\n    {\n        this._quality = Math.max(1, Math.round(value));\n        this._generateKernels();\n    }\n\n    /**\n     * The amount of blur, value greater than `0`.\n     * @default 4\n     */\n    get blur(): number\n    {\n        return this._blur;\n    }\n    set blur(value: number)\n    {\n        this._blur = value;\n        this._generateKernels();\n    }\n}\n\nexport { KawaseBlurFilter };\nexport type { PixelSizeValue };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}