{"ast":null,"code":"import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n  constructor() {\n    this.PreviousPlaneDataPane0 = new Uint8Array();\n    this.PreviousPlaneDataPane1 = new Uint8Array();\n  }\n  init() {}\n  static decodeNextIndex(count, dataType) {\n    switch (dataType) {\n      case DataTypes.Graphics:\n        while (count--) {\n          {\n            FullFrameImageData.CurrentImageIndex++;\n          }\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageXShift + WPC.DmdCols < VariableSizedImageData.CurrentImageXSize) {\n            VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount * count;\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageYShift + WPC.DmdRows < VariableSizedImageData.CurrentImageYSize) {\n            VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount * count;\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {\n            logStr(`Unexpected error advancing image indexes`);\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0];\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xFF) < (tmpImageIndex & 0xFF)) {\n      pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n      pTableIndex++;\n      pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [0, 0];\n  }\n  static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xFF) > (tmpImageIndex & 0xFF)) {\n      pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex > VariableSizedImageData.minTableIndex) {\n      pTableIndex = pTableIndex - 1;\n      if (DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0] != 0) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [pTableIndex, pImageIndex];\n  }\n  static decodePreviousIndex(count, dataType) {\n    switch (dataType) {\n      case DataTypes.Graphics:\n        while (count-- && FullFrameImageData.CurrentImageIndex) {\n          FullFrameImageData.CurrentImageIndex--;\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageYShift > 0) {\n            VariableSizedImageData.CurrentImageYShift -= WPC.ImageShiftYPixelCount * count;\n            if (VariableSizedImageData.CurrentImageYShift < 0) {\n              VariableSizedImageData.CurrentImageYShift = 0;\n            }\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageXShift > 0) {\n            VariableSizedImageData.CurrentImageXShift -= WPC.ImageShiftXPixelCount * count;\n            if (VariableSizedImageData.CurrentImageXShift < 0) {\n              VariableSizedImageData.CurrentImageXShift = 0;\n            }\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {}\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static decodeFullFrameGraphic(GraphicIndex) {\n    FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n    FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane(GraphicIndex + 1);\n  }\n  static decodeVariableSizedImageData() {\n    const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n    VariableSizedImageData.Planes = result[1];\n    if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n      VariableSizedImageData.CurrentImageXSize = 0;\n      VariableSizedImageData.CurrentImageYSize = 0;\n      VariableSizedImageData.CurrentImageXShift = 0;\n      VariableSizedImageData.CurrentImageYShift = 0;\n    }\n  }\n  static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n    let DataPtr;\n    let Addr;\n    const defaultPlane = {\n      Plane_Status: 0,\n      Plane_Size: 0,\n      Plane_Data: new Uint8Array(WPC.DmdPageBytes),\n      Plane_Skipped: new Uint8Array(WPC.DmdPageBytes),\n      Plane_XorFlags: new Uint8Array(WPC.DmdPageBytes),\n      Plane_XorBits: new Uint8Array(WPC.DmdPageBytes),\n      Plane_Encoding: 255\n    };\n    let pPlanes = {\n      Plane0: defaultPlane,\n      Plane1: defaultPlane\n    };\n    pPlanes.Plane0 = DmdDecoder.decodePlaneInit();\n    pPlanes.Plane1 = DmdDecoder.decodePlaneInit();\n    VariableSizedImageData.CurrentImageXSize = 0;\n    VariableSizedImageData.CurrentImageYSize = 0;\n    Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n    if (Addr == -1) {\n      pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n      pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n      return [-1, pPlanes];\n    }\n    DataPtr = Addr;\n    pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n    let TableHeight;\n    let TableSpacing;\n    let ch = ROM.byteAtAddr(Source);\n    const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n    TableHeight = result[0];\n    TableSpacing = result[1];\n    if (TableHeight == -1) {\n      logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n      return [-1, pPlanes];\n    }\n    if (ch > 0 && ch <= WPC.DmdCols) {\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n    } else {\n      switch (ch) {\n        case ImageCodes.Monochrome:\n        case ImageCodes.BicolorIndirect:\n        case ImageCodes.BicolorDirect:\n        case ImageCodes.FD:\n          break;\n        default:\n          logStr(`Unrecognized Header Byte ${ch}`);\n          break;\n      }\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n    }\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage_Centered_Old(SourcePtr, Dest, ImageHeight, ImageWidth, Centered = false) {\n    let ch;\n    let WriteCounter = 0;\n    let i, j;\n    let DestPtr = 0;\n    if (SourcePtr >= ROM.endPtr) {\n      return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n    }\n    if (VariableSizedImageData.CurrentImageYShift == -1) {\n      VariableSizedImageData.CurrentImageYShift = 0;\n      while (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift < ImageHeight) {\n        VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n      }\n    }\n    if (VariableSizedImageData.CurrentImageXShift == -1) {\n      VariableSizedImageData.CurrentImageXShift = 0;\n      while (WPC.DmdCols + VariableSizedImageData.CurrentImageXShift < ImageWidth) {\n        VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n      }\n    }\n    for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    for (i = 0; i < WPC.DmdRows && WriteCounter < WPC.DmdPageBytes; i++) {\n      if (ImageHeight < WPC.DmdRows) {\n        if (i < (WPC.DmdRows - ImageHeight) / 2 || i >= (WPC.DmdRows - ImageHeight) / 2 + ImageHeight) {\n          for (j = 0; j < WPC.DmdCols / 8; j++) {\n            const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n            DestPtr = result[0];\n            Dest = result[1];\n            WriteCounter = result[2];\n          }\n          continue;\n        }\n      }\n      if (ImageHeight > WPC.DmdRows) {\n        if (i >= ImageHeight - VariableSizedImageData.CurrentImageYShift) {\n          for (j = 0; j < WPC.DmdCols / 8; j++) {\n            const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n            DestPtr = result[0];\n            Dest = result[1];\n            WriteCounter = result[2];\n          }\n          continue;\n        }\n      }\n      if (ImageWidth < WPC.DmdCols) {\n        for (j = 0; j < Math.ceil((WPC.DmdCols - ImageWidth) / 2 / 8); j++) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n      for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n        ch = ROM.byteAtAddr(SourcePtr);\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8) && j < Math.floor((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift + 7) / 8)) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n      if (ImageWidth < WPC.DmdCols) {\n        for (j = Math.ceil((WPC.DmdCols - ImageWidth) / 2 / 8) + (ImageWidth + 7) / 8; j < WPC.DmdCols / 8; j++) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift); i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    VariableSizedImageData.CurrentImageXSize = ImageWidth;\n    VariableSizedImageData.CurrentImageYSize = ImageHeight;\n    return [PlaneStatuses.Valid, Dest, SourcePtr];\n  }\n  static decodeVariableSizedImage_Centered(SourcePtr, Dest, ImageHeight, ImageWidth, Centered = false) {\n    let ch;\n    let WriteCounter = 0;\n    let i, j;\n    let DestPtr = 0;\n    Dest = new Uint8Array(Math.ceil(Math.ceil(ImageWidth / 8) * 8 * ImageHeight) / 8);\n    if (SourcePtr >= ROM.endPtr) {\n      return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n    }\n    if (VariableSizedImageData.CurrentImageYShift == -1) {\n      VariableSizedImageData.CurrentImageYShift = 0;\n      while (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift < ImageHeight) {\n        VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n      }\n    }\n    if (VariableSizedImageData.CurrentImageXShift == -1) {\n      VariableSizedImageData.CurrentImageXShift = 0;\n      while (WPC.DmdCols + VariableSizedImageData.CurrentImageXShift < ImageWidth) {\n        VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n      }\n    }\n    for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight && WriteCounter < Dest.length; i++) {\n      for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n        ch = ROM.byteAtAddr(SourcePtr);\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8) && j < Math.floor(ImageWidth + VariableSizedImageData.CurrentImageXShift + 7) / 8) {\n          const result = this.writeNext8BitValueAnySize(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows, ImageWidth, ImageHeight);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift); i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    VariableSizedImageData.CurrentImageXSize = ImageWidth;\n    VariableSizedImageData.CurrentImageYSize = ImageHeight;\n    return [PlaneStatuses.Valid, Dest, SourcePtr];\n  }\n  static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane1.Plane_Size = 0;\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    if (SourcePtr++ >= ROM.endPtr) {\n      logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n      return pPlanes;\n    }\n    const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n    pPlanes.Plane0.Plane_Status = result[0];\n    pPlanes.Plane0.Plane_Data = result[1];\n    SourcePtr = result[2];\n    return pPlanes;\n  }\n  static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let HeaderByte;\n    let VerticalOffset;\n    let HorizontalOffset;\n    let ImageHeight;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane0.Plane_Size = 0;\n    HeaderByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    VerticalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageHeight = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    switch (HeaderByte) {\n      case ImageCodes.BicolorDirect:\n        const result1 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n        pPlanes.Plane1.Plane_Status = result1[0];\n        pPlanes.Plane1.Plane_Data = result1[1];\n        const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result0[0];\n        pPlanes.Plane0.Plane_Data = result0[1];\n        break;\n      case ImageCodes.BicolorIndirect:\n        {\n          let Page;\n          let TmpBuf = [0, 0, 0];\n          let Addr;\n          let pBiColor;\n          const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n          Addr = result[0];\n          Page = result[1];\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n            return pPlanes;\n          }\n          TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[2] = Page & 0xFF;\n          Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xFF} ${TmpBuf[1] & 0xFF} ${TmpBuf[2] & 0xFF}`);\n            return pPlanes;\n          }\n          pBiColor = ROM.byteAtAddr(Addr);\n          const result1 = this.decodeVariableSizedImage_Centered(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n          pPlanes.Plane1.Plane_Status = result1[0];\n          pPlanes.Plane1.Plane_Data = result1[1];\n          const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n          pPlanes.Plane0.Plane_Status = result0[0];\n          pPlanes.Plane0.Plane_Data = result0[1];\n        }\n        break;\n      case ImageCodes.FD:\n      default:\n        const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        break;\n    }\n    return pPlanes;\n  }\n  static getImageEncoding(Index) {\n    const pPlane = this.decodeImageToPlane(Index);\n    return pPlane.Plane_Encoding;\n  }\n  static decodeImageToPlane(Index, SkipDecoding = false) {\n    let pPlane;\n    let OriginalDataPtr;\n    let DataPtr;\n    let Addr;\n    let DMDPlane;\n    DMDPlane = DmdDecoder.decodePlaneInit();\n    Addr = FullFrameImageData.TableAddress + Index * 3;\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n    if (Addr == -1) {\n      logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    OriginalDataPtr = DataPtr = Addr;\n    DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane, SkipDecoding);\n    DMDPlane.Plane_Size = DataPtr - OriginalDataPtr;\n    return DMDPlane;\n  }\n  static decodePlaneInit() {\n    let Plane = new Uint8Array(WPC.DmdPageBytes);\n    let pPlane = {\n      Plane_Size: 0,\n      Plane_Data: Plane,\n      Plane_Skipped: Plane,\n      Plane_XorFlags: Plane,\n      Plane_XorBits: Plane,\n      Plane_Status: PlaneStatuses.Valid,\n      Plane_Encoding: 255\n    };\n    return pPlane;\n  }\n  static decodeFullFrameGraphicImage(Source, pPlane, SkipDecoding) {\n    let OriginalDataPtr = Source;\n    let Dest = new Uint8Array(pPlane.Plane_Data);\n    let ch = ROM.byteAtAddr(Source);\n    pPlane.Plane_Encoding = ch & 0x0F;\n    if (SkipDecoding) {\n      return pPlane;\n    }\n    Source++;\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    logStr(`Type ${toHex(ch)}`);\n    switch (ch & 0x0F) {\n      case 0x00:\n        Dest = this.decode_00(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x01:\n        Dest = this.decode_01(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x02:\n        Dest = this.decode_02(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x03:\n        Dest = this.decode_03(Source);\n        pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n        return pPlane;\n      case 0x04:\n        Dest = this.decode_04(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x05:\n        Dest = this.decode_05(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x06:\n        const result_06 = this.decode_06(Source);\n        pPlane.Plane_Data = result_06[0];\n        pPlane.Plane_XorFlags = result_06[1];\n        pPlane.Plane_XorBits = result_06[2];\n        return pPlane;\n      case 0x07:\n        const result_07 = this.decode_07(Source);\n        pPlane.Plane_Data = result_07[0];\n        pPlane.Plane_XorFlags = result_07[1];\n        pPlane.Plane_XorBits = result_07[2];\n        return pPlane;\n      case 0x08:\n        const result_08 = this.decode_08(Source);\n        pPlane.Plane_Data = result_08[0];\n        pPlane.Plane_Skipped = result_08[1];\n        return pPlane;\n        break;\n      case 0x09:\n        const result_09 = this.decode_09(Source);\n        pPlane.Plane_Data = result_09[0];\n        pPlane.Plane_Skipped = result_09[1];\n        return pPlane;\n      case 0x0A:\n        const result_0A = this.decode_0A(Source);\n        pPlane.Plane_Data = result_0A[0];\n        pPlane.Plane_Skipped = result_0A[1];\n        return pPlane;\n      case 0x0B:\n        const result_0B = this.decode_0B(Source);\n        pPlane.Plane_Data = result_0B[0];\n        pPlane.Plane_Skipped = result_0B[1];\n        return pPlane;\n      default:\n        logStr(`Unknown Image Type ${ch}`);\n        pPlane.Plane_Data = Dest;\n        pPlane.Plane_Status = PlaneStatuses.Unknown;\n        pPlane.Plane_Size = OriginalDataPtr - Source;\n        return pPlane;\n    }\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    pPlane.Plane_Status = PlaneStatuses.Valid;\n    return pPlane;\n  }\n  static decode_00(Source) {\n    let Dest = new Uint8Array();\n    let i;\n    for (i = 0; i < WPC.DmdPageBytes; i++) {\n      Dest[i] = ROM.byteAtAddr(Source + i);\n      if (Source + i >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    return Dest;\n  }\n  static decode_01(Source) {\n    return this.decode_01or02(Source, WriteTypes.Columns);\n  }\n  static decode_02(Source) {\n    return this.decode_01or02(Source, WriteTypes.Rows);\n  }\n  static decode_01or02(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    WriteCounter = 0;\n    DestPtr = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return Dest;\n  }\n  static decode_03(Source) {\n    return new Uint8Array();\n  }\n  static decode_04(Source) {\n    return this.decode_04or05(Source, WriteTypes.Columns);\n  }\n  static decode_05(Source) {\n    return this.decode_04or05(Source, WriteTypes.Rows);\n  }\n  static decode_04or05(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n    };\n    let ch;\n    let i;\n    let WriteCounter;\n    WriteCounter = 0;\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    do {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      ch = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == Header.SpecialFlagByte) {\n        const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result1[0];\n        let Value1 = result1[1];\n        SourcePtr = result1[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result2[0];\n        let Value2 = result2[1];\n        SourcePtr = result2[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return Dest;\n  }\n  static decode_06(Source) {\n    return this.decode_06or07(Source, WriteTypes.Columns);\n  }\n  static decode_07(Source) {\n    return this.decode_06or07(Source, WriteTypes.Rows);\n  }\n  static decode_06or07(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n    let XorBits = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let XorFlagsPtr = 0;\n    let XorBitsPtr = 0;\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    let XorFlagsCounter;\n    let XorBitsCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, XorFlags, XorBits];\n    }\n    WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, XorFlags, XorBits];\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xFF, Type);\n          XorFlagsPtr = resultXorFlags[0];\n          XorFlags = resultXorFlags[1];\n          XorFlagsCounter = resultXorFlags[2];\n          const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n          XorBitsPtr = resultXorBits[0];\n          XorBits = resultXorBits[1];\n          XorBitsCounter = resultXorBits[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n        const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n        XorFlagsPtr = resultXorFlags[0];\n        XorFlags = resultXorFlags[1];\n        XorFlagsCounter = resultXorFlags[2];\n        const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n        XorBitsPtr = resultXorBits[0];\n        XorBits = resultXorBits[1];\n        XorBitsCounter = resultXorBits[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return [Dest, XorFlags, XorBits];\n  }\n  static decode_08(Source) {\n    return this.decode_08or09(Source, WriteTypes.Columns);\n  }\n  static decode_09(Source) {\n    return this.decode_08or09(Source, WriteTypes.Rows);\n  }\n  static decode_08or09(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let count;\n    let pattern;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    function repeatSkips() {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n    }\n    count = SourcePtr;\n    count = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    WriteCounter = SkippedCounter = 0;\n    if (!count) {\n      repeatSkips();\n    }\n    while (continueLooping) {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          pattern = ROM.byteAtAddr(SourcePtr);\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      if (continueLooping) {\n        repeatSkips();\n      }\n    }\n    return [Dest, Skipped];\n  }\n  static decode_0A(Source) {\n    return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n  }\n  static decode_0B(Source) {\n    return this.decode_0Aor0B(Source, WriteTypes.Rows);\n  }\n  static decode_0Aor0B(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: 0\n    };\n    let count;\n    let i;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    Header.ReadMask = 0x80;\n    WriteCounter = SkippedCounter = 0;\n    function BulkSkips() {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n        return [Dest, Skipped];\n      }\n      return [Dest, Skipped];\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n    }\n    const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n    Header = result[0];\n    count = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    if (!count) {\n      BulkSkips();\n    }\n    while (continueLooping) {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n          Header = resultRead[0];\n          const Read = resultRead[1];\n          SourcePtr = resultRead[2];\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      BulkSkips();\n    }\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return [Dest, Skipped];\n  }\n  static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n    return DmdDecoder.writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, WPC.DmdCols, WPC.DmdRows);\n  }\n  static writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, cols, rows) {\n    Dest.set([ch], DestPtr);\n    WriteCounterPtr++;\n    if (WriteCounterPtr >= Math.ceil(Math.ceil(cols / 8) * 8 * rows) / 8) {\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (Type == WriteTypes.Rows) {\n      DestPtr++;\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (!(WriteCounterPtr % rows)) {\n      DestPtr -= cols / 8 * (rows - 2) + (cols / 8 - 1);\n    } else {\n      DestPtr += cols / 8;\n    }\n    return [DestPtr, Dest, WriteCounterPtr];\n  }\n  static readNext8BitValue(Header, SourcePtr) {\n    let returnValues;\n    const result = DmdDecoder.readNextBit(Header, SourcePtr);\n    let ch = result[0];\n    Header = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      returnValues = [Header, 0x00, SourcePtr];\n      return returnValues;\n    }\n    let WriteMask;\n    let ReturnValue;\n    let i;\n    if (ch) {\n      let OnesCount = 0;\n      for (i = 0; i < 7; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          OnesCount++;\n        } else {\n          i = 7;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n      }\n      ReturnValue = Header.RepeatBytes[OnesCount];\n    } else {\n      WriteMask = 0x80;\n      ReturnValue = 0x00;\n      for (i = 0; i < 8; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          ReturnValue |= WriteMask;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n        WriteMask >>= 1;\n      }\n    }\n    returnValues = [Header, ReturnValue, SourcePtr];\n    return returnValues;\n  }\n  static readNextBit(Header, SourcePtr) {\n    let returnValues;\n    let ch = ROM.byteAtAddr(SourcePtr) & Header.ReadMask;\n    if (!(Header.ReadMask >>= 1)) {\n      Header.ReadMask = 0x80;\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        returnValues = [0x00, Header, SourcePtr];\n        return returnValues;\n      }\n    }\n    returnValues = [ch, Header, SourcePtr];\n    return returnValues;\n  }\n}","map":{"version":3,"names":["WriteTypes","ImageCodes","DataTypes","PlaneStatuses","WPC","DataParser","toHex","logStr","VariableSizedImageData","FullFrameImageData","ROM","DmdDecoder","constructor","PreviousPlaneDataPane0","Uint8Array","PreviousPlaneDataPane1","init","decodeNextIndex","count","dataType","Graphics","CurrentImageIndex","FontData","AniData","Planes","Plane0","Plane_Status","Valid","CurrentImageXShift","DmdCols","CurrentImageXSize","ImageShiftXPixelCount","CurrentImageYShift","DmdRows","CurrentImageYSize","ImageShiftYPixelCount","result","incrementVariableSizedImageIndex","CurrentTableIndex","pTableIndex","pImageIndex","tmpImageIndex","getLastImageIndex","getNextImageIndex","maxTableIndex","getFirstImageIndex","decrementVariableSizedImageIndex","getPrevImageIndex","minTableIndex","decodePreviousIndex","decodeFullFrameGraphic","GraphicIndex","decodeImageToPlane","Plane1","decodeVariableSizedImageData","decodeVariableSizedImageIndexToPlane","TableIndex","ImageIndex","DataPtr","Addr","defaultPlane","Plane_Size","Plane_Data","DmdPageBytes","Plane_Skipped","Plane_XorFlags","Plane_XorBits","Plane_Encoding","pPlanes","decodePlaneInit","getROMAddressOfVariableSizedImageIndex","BadDimension","decodeVariableSizedImage","Source","TableHeight","TableSpacing","ch","byteAtAddr","getVariableSizedImageTableMetadata","decodeVariableSizedImageIndex_NoHeader","Monochrome","BicolorIndirect","BicolorDirect","FD","decodeVariableSizedImageIndex_Header","decodeVariableSizedImage_Centered_Old","SourcePtr","Dest","ImageHeight","ImageWidth","Centered","WriteCounter","i","j","DestPtr","endPtr","ImageOutOfRange","writeNext8BitValue","Rows","Math","ceil","floor","decodeVariableSizedImage_Centered","length","writeNext8BitValueAnySize","DestPlane0","DestPlane1","Invalid","HeaderByte","VerticalOffset","HorizontalOffset","result1","result0","Page","TmpBuf","pBiColor","extractWPCAddrAndPageOfImageTable","getROMAddressFromAddrOf3ByteWPCAddrPage","getImageEncoding","Index","pPlane","SkipDecoding","OriginalDataPtr","DMDPlane","TableAddress","size","TableEntryOutOfRange","decodeFullFrameGraphicImage","Plane","decode_00","decode_01","decode_02","decode_03","Unimplemented","decode_04","decode_05","result_06","decode_06","result_07","decode_07","result_08","decode_08","result_09","decode_09","result_0A","decode_0A","result_0B","decode_0B","Unknown","decode_01or02","Columns","Type","SpecialFlagByte","Value1","Value2","decode_04or05","Header","ReadMask","RepeatBytes","readNext8BitValue","result2","decode_06or07","XorFlags","XorBits","XorFlagsPtr","XorBitsPtr","XorFlagsCounter","XorBitsCounter","resultXorFlags","resultXorBits","decode_08or09","SkippedPtr","Skipped","pattern","SkippedCounter","continueLooping","repeatSkips","resultSkipped","decode_0Aor0B","BulkSkips","resultRead","Read","WriteCounterPtr","cols","rows","set","returnValues","readNextBit","WriteMask","ReturnValue","OnesCount"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/node_modules/wpcedit/dist/classes/DmdDecoder.js"],"sourcesContent":["import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n    constructor() {\n        this.PreviousPlaneDataPane0 = new Uint8Array();\n        this.PreviousPlaneDataPane1 = new Uint8Array();\n    }\n    init() {\n    }\n    static decodeNextIndex(count, dataType) {\n        switch (dataType) {\n            case DataTypes.Graphics:\n                while (count--) {\n                    {\n                        FullFrameImageData.CurrentImageIndex++;\n                    }\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n                    if ((VariableSizedImageData.CurrentImageXShift + WPC.DmdCols) < VariableSizedImageData.CurrentImageXSize) {\n                        VariableSizedImageData.CurrentImageXShift += (WPC.ImageShiftXPixelCount * count);\n                        break;\n                    }\n                    if ((VariableSizedImageData.CurrentImageYShift + WPC.DmdRows) < VariableSizedImageData.CurrentImageYSize) {\n                        VariableSizedImageData.CurrentImageYShift += (WPC.ImageShiftYPixelCount * count);\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                        logStr(`Unexpected error advancing image indexes`);\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if ((pTableIndex == null) || (pImageIndex == null)) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0];\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if (((pImageIndex) & 0xFF) < (tmpImageIndex & 0xFF)) {\n            pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n            pTableIndex++;\n            pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [0, 0];\n    }\n    static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if ((pTableIndex == null) || (pImageIndex == null)) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if (((pImageIndex) & 0xFF) > (tmpImageIndex & 0xFF)) {\n            pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex > VariableSizedImageData.minTableIndex) {\n            pTableIndex = (pTableIndex) - 1;\n            if (DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0] != 0) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [pTableIndex, pImageIndex];\n    }\n    static decodePreviousIndex(count, dataType) {\n        switch (dataType) {\n            case DataTypes.Graphics:\n                while ((count--) && (FullFrameImageData.CurrentImageIndex)) {\n                    FullFrameImageData.CurrentImageIndex--;\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n                    if (VariableSizedImageData.CurrentImageYShift > 0) {\n                        VariableSizedImageData.CurrentImageYShift -= (WPC.ImageShiftYPixelCount * count);\n                        if (VariableSizedImageData.CurrentImageYShift < 0) {\n                            VariableSizedImageData.CurrentImageYShift = 0;\n                        }\n                        break;\n                    }\n                    if (VariableSizedImageData.CurrentImageXShift > 0) {\n                        VariableSizedImageData.CurrentImageXShift -= (WPC.ImageShiftXPixelCount * count);\n                        if (VariableSizedImageData.CurrentImageXShift < 0) {\n                            VariableSizedImageData.CurrentImageXShift = 0;\n                        }\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static decodeFullFrameGraphic(GraphicIndex) {\n        FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n        FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane((GraphicIndex + 1));\n    }\n    static decodeVariableSizedImageData() {\n        const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n        VariableSizedImageData.Planes = result[1];\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n            VariableSizedImageData.CurrentImageXSize = 0;\n            VariableSizedImageData.CurrentImageYSize = 0;\n            VariableSizedImageData.CurrentImageXShift = 0;\n            VariableSizedImageData.CurrentImageYShift = 0;\n        }\n    }\n    static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n        let DataPtr;\n        let Addr;\n        const defaultPlane = {\n            Plane_Status: 0,\n            Plane_Size: 0,\n            Plane_Data: new Uint8Array(WPC.DmdPageBytes),\n            Plane_Skipped: new Uint8Array(WPC.DmdPageBytes),\n            Plane_XorFlags: new Uint8Array(WPC.DmdPageBytes),\n            Plane_XorBits: new Uint8Array(WPC.DmdPageBytes),\n            Plane_Encoding: 255\n        };\n        let pPlanes = {\n            Plane0: defaultPlane,\n            Plane1: defaultPlane\n        };\n        pPlanes.Plane0 = DmdDecoder.decodePlaneInit();\n        pPlanes.Plane1 = DmdDecoder.decodePlaneInit();\n        VariableSizedImageData.CurrentImageXSize = 0;\n        VariableSizedImageData.CurrentImageYSize = 0;\n        Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n        if (Addr == -1) {\n            pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n            pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n            return [-1, pPlanes];\n        }\n        DataPtr = (Addr);\n        pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n        let TableHeight;\n        let TableSpacing;\n        let ch = ROM.byteAtAddr(Source);\n        const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n        TableHeight = result[0];\n        TableSpacing = result[1];\n        if (TableHeight == -1) {\n            logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n            return [-1, pPlanes];\n        }\n        if ((ch > 0) && (ch <= WPC.DmdCols)) {\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n        }\n        else {\n            switch (ch) {\n                case ImageCodes.Monochrome:\n                case ImageCodes.BicolorIndirect:\n                case ImageCodes.BicolorDirect:\n                case ImageCodes.FD:\n                    break;\n                default:\n                    logStr(`Unrecognized Header Byte ${ch}`);\n                    break;\n            }\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n        }\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage_Centered_Old(SourcePtr, Dest, ImageHeight, ImageWidth, Centered = false) {\n        let ch;\n        let WriteCounter = 0;\n        let i, j;\n        let DestPtr = 0;\n        if ((SourcePtr) >= ROM.endPtr) {\n            return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (VariableSizedImageData.CurrentImageYShift == -1) {\n            VariableSizedImageData.CurrentImageYShift = 0;\n            while ((WPC.DmdRows + VariableSizedImageData.CurrentImageYShift) < ImageHeight) {\n                VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n            }\n        }\n        if (VariableSizedImageData.CurrentImageXShift == -1) {\n            VariableSizedImageData.CurrentImageXShift = 0;\n            while ((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) < ImageWidth) {\n                VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n            }\n        }\n        for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        for (i = 0; ((i < WPC.DmdRows) && (WriteCounter < WPC.DmdPageBytes)); i++) {\n            if (ImageHeight < WPC.DmdRows) {\n                if ((i < ((WPC.DmdRows - ImageHeight) / 2)) ||\n                    (i >= (((WPC.DmdRows - ImageHeight) / 2) + ImageHeight))) {\n                    for (j = 0; j < (WPC.DmdCols / 8); j++) {\n                        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                        DestPtr = result[0];\n                        Dest = result[1];\n                        WriteCounter = result[2];\n                    }\n                    continue;\n                }\n            }\n            if (ImageHeight > WPC.DmdRows) {\n                if (i >= (ImageHeight - VariableSizedImageData.CurrentImageYShift)) {\n                    for (j = 0; j < (WPC.DmdCols / 8); j++) {\n                        const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                        DestPtr = result[0];\n                        Dest = result[1];\n                        WriteCounter = result[2];\n                    }\n                    continue;\n                }\n            }\n            if (ImageWidth < WPC.DmdCols) {\n                for (j = 0; j < Math.ceil(((WPC.DmdCols - ImageWidth) / 2) / 8); j++) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n            for (j = 0; j < Math.floor(((ImageWidth + 7) / 8)); j++) {\n                ch = ROM.byteAtAddr(SourcePtr);\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n                if ((j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8)) && (j < Math.floor(((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) + 7) / 8))) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n            if (ImageWidth < WPC.DmdCols) {\n                for (j = (Math.ceil(((WPC.DmdCols - ImageWidth) / 2) / 8) + ((ImageWidth + 7) / 8)); j < (WPC.DmdCols / 8); j++) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n        }\n        for (i = 0; i < (ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift)); i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        VariableSizedImageData.CurrentImageXSize = ImageWidth;\n        VariableSizedImageData.CurrentImageYSize = ImageHeight;\n        return [PlaneStatuses.Valid, Dest, SourcePtr];\n    }\n    static decodeVariableSizedImage_Centered(SourcePtr, Dest, ImageHeight, ImageWidth, Centered = false) {\n        let ch;\n        let WriteCounter = 0;\n        let i, j;\n        let DestPtr = 0;\n        Dest = new Uint8Array(Math.ceil(Math.ceil(ImageWidth / 8) * 8 * ImageHeight) / 8);\n        if ((SourcePtr) >= ROM.endPtr) {\n            return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (VariableSizedImageData.CurrentImageYShift == -1) {\n            VariableSizedImageData.CurrentImageYShift = 0;\n            while ((WPC.DmdRows + VariableSizedImageData.CurrentImageYShift) < ImageHeight) {\n                VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n            }\n        }\n        if (VariableSizedImageData.CurrentImageXShift == -1) {\n            VariableSizedImageData.CurrentImageXShift = 0;\n            while ((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) < ImageWidth) {\n                VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n            }\n        }\n        for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        for (i = 0; (i < ImageHeight) && (WriteCounter < Dest.length); i++) {\n            for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n                ch = ROM.byteAtAddr(SourcePtr);\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n                if ((j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8)) && (j < Math.floor((ImageWidth + VariableSizedImageData.CurrentImageXShift) + 7) / 8)) {\n                    const result = this.writeNext8BitValueAnySize(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows, ImageWidth, ImageHeight);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n        }\n        for (i = 0; i < (ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift)); i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        VariableSizedImageData.CurrentImageXSize = ImageWidth;\n        VariableSizedImageData.CurrentImageYSize = ImageHeight;\n        return [PlaneStatuses.Valid, Dest, SourcePtr];\n    }\n    static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane1.Plane_Size = 0;\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        if ((SourcePtr++) >= ROM.endPtr) {\n            logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n            return pPlanes;\n        }\n        const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        SourcePtr = result[2];\n        return pPlanes;\n    }\n    static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let HeaderByte;\n        let VerticalOffset;\n        let HorizontalOffset;\n        let ImageHeight;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane0.Plane_Size = 0;\n        HeaderByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        VerticalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageHeight = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        switch (HeaderByte) {\n            case ImageCodes.BicolorDirect:\n                const result1 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n                pPlanes.Plane1.Plane_Status = result1[0];\n                pPlanes.Plane1.Plane_Data = result1[1];\n                const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result0[0];\n                pPlanes.Plane0.Plane_Data = result0[1];\n                break;\n            case ImageCodes.BicolorIndirect:\n                {\n                    let Page;\n                    let TmpBuf = [0, 0, 0];\n                    let Addr;\n                    let pBiColor;\n                    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n                    Addr = result[0];\n                    Page = result[1];\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n                        return pPlanes;\n                    }\n                    TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[2] = (Page & 0xFF);\n                    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xFF} ${(TmpBuf[1] & 0xFF)} ${(TmpBuf[2] & 0xFF)}`);\n                        return pPlanes;\n                    }\n                    pBiColor = ROM.byteAtAddr(Addr);\n                    const result1 = this.decodeVariableSizedImage_Centered(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n                    pPlanes.Plane1.Plane_Status = result1[0];\n                    pPlanes.Plane1.Plane_Data = result1[1];\n                    const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                    pPlanes.Plane0.Plane_Status = result0[0];\n                    pPlanes.Plane0.Plane_Data = result0[1];\n                }\n                break;\n            case ImageCodes.FD:\n            default:\n                const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result[0];\n                pPlanes.Plane0.Plane_Data = result[1];\n                break;\n        }\n        return pPlanes;\n    }\n    static getImageEncoding(Index) {\n        const pPlane = this.decodeImageToPlane(Index);\n        return pPlane.Plane_Encoding;\n    }\n    static decodeImageToPlane(Index, SkipDecoding = false) {\n        let pPlane;\n        let OriginalDataPtr;\n        let DataPtr;\n        let Addr;\n        let DMDPlane;\n        DMDPlane = DmdDecoder.decodePlaneInit();\n        Addr = FullFrameImageData.TableAddress + (Index * 3);\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n        if (Addr == -1) {\n            logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        OriginalDataPtr = DataPtr = Addr;\n        DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane, SkipDecoding);\n        DMDPlane.Plane_Size = (DataPtr - OriginalDataPtr);\n        return DMDPlane;\n    }\n    static decodePlaneInit() {\n        let Plane = new Uint8Array(WPC.DmdPageBytes);\n        let pPlane = {\n            Plane_Size: 0,\n            Plane_Data: Plane,\n            Plane_Skipped: Plane,\n            Plane_XorFlags: Plane,\n            Plane_XorBits: Plane,\n            Plane_Status: PlaneStatuses.Valid,\n            Plane_Encoding: 255\n        };\n        return pPlane;\n    }\n    static decodeFullFrameGraphicImage(Source, pPlane, SkipDecoding) {\n        let OriginalDataPtr = Source;\n        let Dest = new Uint8Array(pPlane.Plane_Data);\n        let ch = ROM.byteAtAddr(Source);\n        pPlane.Plane_Encoding = ch & 0x0F;\n        if (SkipDecoding) {\n            return pPlane;\n        }\n        Source++;\n        if ((Source) >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        logStr(`Type ${toHex(ch)}`);\n        switch (ch & 0x0F) {\n            case 0x00:\n                Dest = this.decode_00(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x01:\n                Dest = this.decode_01(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x02:\n                Dest = this.decode_02(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x03:\n                Dest = this.decode_03(Source);\n                pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n                return pPlane;\n            case 0x04:\n                Dest = this.decode_04(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x05:\n                Dest = this.decode_05(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x06:\n                const result_06 = this.decode_06(Source);\n                pPlane.Plane_Data = result_06[0];\n                pPlane.Plane_XorFlags = result_06[1];\n                pPlane.Plane_XorBits = result_06[2];\n                return pPlane;\n            case 0x07:\n                const result_07 = this.decode_07(Source);\n                pPlane.Plane_Data = result_07[0];\n                pPlane.Plane_XorFlags = result_07[1];\n                pPlane.Plane_XorBits = result_07[2];\n                return pPlane;\n            case 0x08:\n                const result_08 = this.decode_08(Source);\n                pPlane.Plane_Data = result_08[0];\n                pPlane.Plane_Skipped = result_08[1];\n                return pPlane;\n                break;\n            case 0x09:\n                const result_09 = this.decode_09(Source);\n                pPlane.Plane_Data = result_09[0];\n                pPlane.Plane_Skipped = result_09[1];\n                return pPlane;\n            case 0x0A:\n                const result_0A = this.decode_0A(Source);\n                pPlane.Plane_Data = result_0A[0];\n                pPlane.Plane_Skipped = result_0A[1];\n                return pPlane;\n            case 0x0B:\n                const result_0B = this.decode_0B(Source);\n                pPlane.Plane_Data = result_0B[0];\n                pPlane.Plane_Skipped = result_0B[1];\n                return pPlane;\n            default:\n                logStr(`Unknown Image Type ${ch}`);\n                pPlane.Plane_Data = Dest;\n                pPlane.Plane_Status = PlaneStatuses.Unknown;\n                pPlane.Plane_Size = OriginalDataPtr - Source;\n                return pPlane;\n        }\n        if ((Source) >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        pPlane.Plane_Status = PlaneStatuses.Valid;\n        return pPlane;\n    }\n    static decode_00(Source) {\n        let Dest = new Uint8Array();\n        let i;\n        for (i = 0; i < WPC.DmdPageBytes; i++) {\n            Dest[i] = ROM.byteAtAddr(Source + i);\n            if (Source + i >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        return Dest;\n    }\n    static decode_01(Source) {\n        return this.decode_01or02(Source, WriteTypes.Columns);\n    }\n    static decode_02(Source) {\n        return this.decode_01or02(Source, WriteTypes.Rows);\n    }\n    static decode_01or02(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if ((SourcePtr) >= ROM.endPtr) {\n            return Dest;\n        }\n        WriteCounter = 0;\n        DestPtr = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return Dest;\n    }\n    static decode_03(Source) {\n        return new Uint8Array();\n    }\n    static decode_04(Source) {\n        return this.decode_04or05(Source, WriteTypes.Columns);\n    }\n    static decode_05(Source) {\n        return this.decode_04or05(Source, WriteTypes.Rows);\n    }\n    static decode_04or05(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n        };\n        let ch;\n        let i;\n        let WriteCounter;\n        WriteCounter = 0;\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return Dest;\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        do {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            ch = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == Header.SpecialFlagByte) {\n                const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result1[0];\n                let Value1 = result1[1];\n                SourcePtr = result1[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result2[0];\n                let Value2 = result2[1];\n                SourcePtr = result2[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return Dest;\n    }\n    static decode_06(Source) {\n        return this.decode_06or07(Source, WriteTypes.Columns);\n    }\n    static decode_07(Source) {\n        return this.decode_06or07(Source, WriteTypes.Rows);\n    }\n    static decode_06or07(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n        let XorBits = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let XorFlagsPtr = 0;\n        let XorBitsPtr = 0;\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        let XorFlagsCounter;\n        let XorBitsCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, XorFlags, XorBits];\n        }\n        WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, XorFlags, XorBits];\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xFF, Type);\n                    XorFlagsPtr = resultXorFlags[0];\n                    XorFlags = resultXorFlags[1];\n                    XorFlagsCounter = resultXorFlags[2];\n                    const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n                    XorBitsPtr = resultXorBits[0];\n                    XorBits = resultXorBits[1];\n                    XorBitsCounter = resultXorBits[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n                const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n                XorFlagsPtr = resultXorFlags[0];\n                XorFlags = resultXorFlags[1];\n                XorFlagsCounter = resultXorFlags[2];\n                const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n                XorBitsPtr = resultXorBits[0];\n                XorBits = resultXorBits[1];\n                XorBitsCounter = resultXorBits[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return [Dest, XorFlags, XorBits];\n    }\n    static decode_08(Source) {\n        return this.decode_08or09(Source, WriteTypes.Columns);\n    }\n    static decode_09(Source) {\n        return this.decode_08or09(Source, WriteTypes.Rows);\n    }\n    static decode_08or09(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let count;\n        let pattern;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        function repeatSkips() {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n        }\n        count = SourcePtr;\n        count = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        WriteCounter = SkippedCounter = 0;\n        if (!count) {\n            repeatSkips();\n        }\n        while (continueLooping) {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    pattern = ROM.byteAtAddr(SourcePtr);\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            if (continueLooping) {\n                repeatSkips();\n            }\n        }\n        return [Dest, Skipped];\n    }\n    static decode_0A(Source) {\n        return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n    }\n    static decode_0B(Source) {\n        return this.decode_0Aor0B(Source, WriteTypes.Rows);\n    }\n    static decode_0Aor0B(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: 0\n        };\n        let count;\n        let i;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        Header.ReadMask = 0x80;\n        WriteCounter = SkippedCounter = 0;\n        function BulkSkips() {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n                return [Dest, Skipped];\n            }\n            return [Dest, Skipped];\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n        }\n        const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result[0];\n        count = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        if (!count) {\n            BulkSkips();\n        }\n        while (continueLooping) {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                    Header = resultRead[0];\n                    const Read = resultRead[1];\n                    SourcePtr = resultRead[2];\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            BulkSkips();\n        }\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return [Dest, Skipped];\n    }\n    static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n        return DmdDecoder.writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, WPC.DmdCols, WPC.DmdRows);\n    }\n    static writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, cols, rows) {\n        Dest.set([ch], DestPtr);\n        WriteCounterPtr++;\n        if ((WriteCounterPtr) >= (Math.ceil(Math.ceil(cols / 8) * 8 * rows) / 8)) {\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (Type == WriteTypes.Rows) {\n            DestPtr++;\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (!(WriteCounterPtr % (rows))) {\n            DestPtr -= (((cols / 8) * (rows - 2)) + ((cols / 8) - 1));\n        }\n        else {\n            DestPtr += (cols / 8);\n        }\n        return [DestPtr, Dest, WriteCounterPtr];\n    }\n    static readNext8BitValue(Header, SourcePtr) {\n        let returnValues;\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        let ch = result[0];\n        Header = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            returnValues = [Header, 0x00, SourcePtr];\n            return returnValues;\n        }\n        let WriteMask;\n        let ReturnValue;\n        let i;\n        if (ch) {\n            let OnesCount = 0;\n            for (i = 0; i < 7; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    OnesCount++;\n                }\n                else {\n                    i = 7;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n            }\n            ReturnValue = Header.RepeatBytes[OnesCount];\n        }\n        else {\n            WriteMask = 0x80;\n            ReturnValue = 0x00;\n            for (i = 0; i < 8; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    ReturnValue |= WriteMask;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n                WriteMask >>= 1;\n            }\n        }\n        returnValues = [Header, ReturnValue, SourcePtr];\n        return (returnValues);\n    }\n    static readNextBit(Header, SourcePtr) {\n        let returnValues;\n        let ch = (ROM.byteAtAddr(SourcePtr) & Header.ReadMask);\n        if (!(Header.ReadMask >>= 1)) {\n            Header.ReadMask = 0x80;\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                returnValues = [0x00, Header, SourcePtr];\n                return returnValues;\n            }\n        }\n        returnValues = [ch, Header, SourcePtr];\n        return returnValues;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}