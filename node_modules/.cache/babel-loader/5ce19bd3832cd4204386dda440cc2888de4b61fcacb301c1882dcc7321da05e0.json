{"ast":null,"code":"import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { Settings } from \"../stores/Settings.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n  constructor() {\n    this.PreviousPlaneDataPane0 = new Uint8Array();\n    this.PreviousPlaneDataPane1 = new Uint8Array();\n  }\n  init() {}\n  static decodeNextIndex(count) {\n    switch (Settings.DataType) {\n      case DataTypes.Graphics:\n        while (count--) {\n          {\n            FullFrameImageData.CurrentImageIndex++;\n          }\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageXShift + WPC.DmdCols < VariableSizedImageData.CurrentImageXSize) {\n            VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount * count;\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageYShift + WPC.DmdRows < VariableSizedImageData.CurrentImageYSize) {\n            VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount * count;\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {\n            logStr(`Unexpected error advancing image indexes`);\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex);\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xFF) < (tmpImageIndex & 0xFF)) {\n      pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n      pTableIndex++;\n      pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [0, 0];\n  }\n  static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xFF) > (tmpImageIndex & 0xFF)) {\n      pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex > VariableSizedImageData.minTableIndex) {\n      pTableIndex = pTableIndex - 1;\n      if (DataParser.getLastImageIndex(pImageIndex, pTableIndex) != 0) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [pTableIndex, pImageIndex];\n  }\n  static decodePreviousIndex(count) {\n    switch (Settings.DataType) {\n      case DataTypes.Graphics:\n        while (count-- && FullFrameImageData.CurrentImageIndex) {\n          FullFrameImageData.CurrentImageIndex--;\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageYShift > 0) {\n            VariableSizedImageData.CurrentImageYShift -= WPC.ImageShiftYPixelCount * count;\n            if (VariableSizedImageData.CurrentImageYShift < 0) {\n              VariableSizedImageData.CurrentImageYShift = 0;\n            }\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageXShift > 0) {\n            VariableSizedImageData.CurrentImageXShift -= WPC.ImageShiftXPixelCount * count;\n            if (VariableSizedImageData.CurrentImageXShift < 0) {\n              VariableSizedImageData.CurrentImageXShift = 0;\n            }\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {}\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static decodeFullFrameGraphic(GraphicIndex) {\n    FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n    FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane(GraphicIndex + 1);\n  }\n  static decodeVariableSizedImageData() {\n    const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n    VariableSizedImageData.Planes = result[1];\n    if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n      VariableSizedImageData.CurrentImageXSize = 0;\n      VariableSizedImageData.CurrentImageYSize = 0;\n      VariableSizedImageData.CurrentImageXShift = 0;\n      VariableSizedImageData.CurrentImageYShift = 0;\n    }\n  }\n  static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n    let DataPtr;\n    let Addr;\n    const defaultPlane = {\n      Plane_Status: 0,\n      Plane_Size: 0,\n      Plane_Data: new Uint8Array(WPC.DmdPageBytes),\n      Plane_Skipped: new Uint8Array(WPC.DmdPageBytes),\n      Plane_XorFlags: new Uint8Array(WPC.DmdPageBytes),\n      Plane_XorBits: new Uint8Array(WPC.DmdPageBytes)\n    };\n    let pPlanes = {\n      Plane0: defaultPlane,\n      Plane1: defaultPlane\n    };\n    pPlanes.Plane0 = DmdDecoder.decodePlaneInit();\n    pPlanes.Plane1 = DmdDecoder.decodePlaneInit();\n    VariableSizedImageData.CurrentImageXSize = 0;\n    VariableSizedImageData.CurrentImageYSize = 0;\n    Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n    if (Addr == -1) {\n      pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n      pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n      return [-1, pPlanes];\n    }\n    DataPtr = Addr;\n    pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n    let TableHeight;\n    let TableSpacing;\n    let ch = ROM.byteAtAddr(Source);\n    const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n    TableHeight = result[0];\n    TableSpacing = result[1];\n    if (TableHeight == -1) {\n      logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n      return [-1, pPlanes];\n    }\n    if (ch > 0 && ch <= WPC.DmdCols) {\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n    } else {\n      switch (ch) {\n        case ImageCodes.Monochrome:\n        case ImageCodes.BicolorIndirect:\n        case ImageCodes.BicolorDirect:\n        case ImageCodes.FD:\n          break;\n        default:\n          logStr(`Unrecognized Header Byte ${ch}`);\n          break;\n      }\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n    }\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage_Centered(SourcePtr, Dest, ImageHeight, ImageWidth) {\n    let ch;\n    let WriteCounter = 0;\n    let i, j;\n    let DestPtr = 0;\n    if (SourcePtr >= ROM.endPtr) {\n      return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n    }\n    if (VariableSizedImageData.CurrentImageYShift == -1) {\n      VariableSizedImageData.CurrentImageYShift = 0;\n      while (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift < ImageHeight) {\n        VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n      }\n    }\n    if (VariableSizedImageData.CurrentImageXShift == -1) {\n      VariableSizedImageData.CurrentImageXShift = 0;\n      while (WPC.DmdCols + VariableSizedImageData.CurrentImageXShift < ImageWidth) {\n        VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n      }\n    }\n    for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    for (i = 0; i < WPC.DmdRows && WriteCounter < WPC.DmdPageBytes; i++) {\n      if (ImageHeight < WPC.DmdRows) {\n        if (i < (WPC.DmdRows - ImageHeight) / 2 || i >= (WPC.DmdRows - ImageHeight) / 2 + ImageHeight) {\n          for (j = 0; j < WPC.DmdCols / 8; j++) {\n            const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n            DestPtr = result[0];\n            Dest = result[1];\n            WriteCounter = result[2];\n          }\n          continue;\n        }\n      }\n      if (ImageHeight > WPC.DmdRows) {\n        if (i >= ImageHeight - VariableSizedImageData.CurrentImageYShift) {\n          for (j = 0; j < WPC.DmdCols / 8; j++) {\n            const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n            DestPtr = result[0];\n            Dest = result[1];\n            WriteCounter = result[2];\n          }\n          continue;\n        }\n      }\n      if (ImageWidth < WPC.DmdCols) {\n        for (j = 0; j < Math.ceil((WPC.DmdCols - ImageWidth) / 2 / 8); j++) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n      for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n        ch = ROM.byteAtAddr(SourcePtr);\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8) && j < Math.floor((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift + 7) / 8)) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n      if (ImageWidth < WPC.DmdCols) {\n        for (j = Math.ceil((WPC.DmdCols - ImageWidth) / 2 / 8) + (ImageWidth + 7) / 8; j < WPC.DmdCols / 8; j++) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift); i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    VariableSizedImageData.CurrentImageXSize = ImageWidth;\n    VariableSizedImageData.CurrentImageYSize = ImageHeight;\n    return [PlaneStatuses.Valid, Dest, SourcePtr];\n  }\n  static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane1.Plane_Size = 0;\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    if (SourcePtr++ >= ROM.endPtr) {\n      logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n      return pPlanes;\n    }\n    const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n    pPlanes.Plane0.Plane_Status = result[0];\n    pPlanes.Plane0.Plane_Data = result[1];\n    SourcePtr = result[2];\n    return pPlanes;\n  }\n  static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let HeaderByte;\n    let VerticalOffset;\n    let HorizontalOffset;\n    let ImageHeight;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane0.Plane_Size = 0;\n    HeaderByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    VerticalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageHeight = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    switch (HeaderByte) {\n      case ImageCodes.BicolorDirect:\n        const result1 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n        pPlanes.Plane1.Plane_Status = result1[0];\n        pPlanes.Plane1.Plane_Data = result1[1];\n        const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result0[0];\n        pPlanes.Plane0.Plane_Data = result0[1];\n        break;\n      case ImageCodes.BicolorIndirect:\n        {\n          let Page;\n          let TmpBuf = [0, 0, 0];\n          let Addr;\n          let pBiColor;\n          const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n          Addr = result[0];\n          Page = result[1];\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n            return pPlanes;\n          }\n          TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[2] = Page & 0xFF;\n          Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xFF} ${TmpBuf[1] & 0xFF} ${TmpBuf[2] & 0xFF}`);\n            return pPlanes;\n          }\n          pBiColor = ROM.byteAtAddr(Addr);\n          const result1 = this.decodeVariableSizedImage_Centered(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n          pPlanes.Plane1.Plane_Status = result1[0];\n          pPlanes.Plane1.Plane_Data = result1[1];\n          const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n          pPlanes.Plane0.Plane_Status = result0[0];\n          pPlanes.Plane0.Plane_Data = result0[1];\n        }\n        break;\n      case ImageCodes.FD:\n      default:\n        const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        break;\n    }\n    return pPlanes;\n  }\n  static decodeImageToPlane(Index) {\n    let pPlane;\n    let OriginalDataPtr;\n    let DataPtr;\n    let Addr;\n    let DMDPlane;\n    DMDPlane = DmdDecoder.decodePlaneInit();\n    Addr = FullFrameImageData.TableAddress + Index * 3;\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n    if (Addr == -1) {\n      logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    OriginalDataPtr = DataPtr = Addr;\n    DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane);\n    DMDPlane.Plane_Size = DataPtr - OriginalDataPtr;\n    return DMDPlane;\n  }\n  static decodePlaneInit() {\n    let Plane = new Uint8Array(WPC.DmdPageBytes);\n    let pPlane = {\n      Plane_Size: 0,\n      Plane_Data: Plane,\n      Plane_Skipped: Plane,\n      Plane_XorFlags: Plane,\n      Plane_XorBits: Plane,\n      Plane_Status: PlaneStatuses.Valid\n    };\n    return pPlane;\n  }\n  static decodeFullFrameGraphicImage(Source, pPlane) {\n    let OriginalDataPtr = Source;\n    let Dest = new Uint8Array(pPlane.Plane_Data);\n    let Skipped = pPlane.Plane_Skipped;\n    let XorFlags = pPlane.Plane_XorFlags;\n    let XorBits = pPlane.Plane_XorBits;\n    let ch = ROM.byteAtAddr(Source);\n    Source++;\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    logStr(`Type ${toHex(ch)}`);\n    switch (ch & 0x0F) {\n      case 0x00:\n        Dest = this.decode_00(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x01:\n        Dest = this.decode_01(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x02:\n        Dest = this.decode_02(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x03:\n        Dest = this.decode_03(Source);\n        pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n        return pPlane;\n      case 0x04:\n        Dest = this.decode_04(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x05:\n        Dest = this.decode_05(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x06:\n        const result_06 = this.decode_06(Source);\n        pPlane.Plane_Data = result_06[0];\n        pPlane.Plane_Skipped = result_06[1];\n        pPlane.Plane_XorFlags = result_06[2];\n        pPlane.Plane_XorFlags = result_06[3];\n        return pPlane;\n      case 0x07:\n        const result_07 = this.decode_07(Source);\n        pPlane.Plane_Data = result_07[0];\n        pPlane.Plane_Skipped = result_07[1];\n        pPlane.Plane_XorFlags = result_07[2];\n        pPlane.Plane_XorFlags = result_07[3];\n        return pPlane;\n      case 0x08:\n        const result_08 = this.decode_08(Source);\n        pPlane.Plane_Data = result_08[0];\n        pPlane.Plane_Skipped = result_08[1];\n        return pPlane;\n        break;\n      case 0x09:\n        const result_09 = this.decode_09(Source);\n        pPlane.Plane_Data = result_09[0];\n        pPlane.Plane_Skipped = result_09[1];\n        return pPlane;\n      case 0x0A:\n        const result_0A = this.decode_0A(Source);\n        pPlane.Plane_Data = result_0A[0];\n        pPlane.Plane_Skipped = result_0A[1];\n        return pPlane;\n      case 0x0B:\n        const result_0B = this.decode_0B(Source);\n        pPlane.Plane_Data = result_0B[0];\n        pPlane.Plane_Skipped = result_0B[1];\n        return pPlane;\n      default:\n        logStr(`Unknown Image Type ${ch}`);\n        pPlane.Plane_Data = Dest;\n        pPlane.Plane_Status = PlaneStatuses.Unknown;\n        pPlane.Plane_Size = OriginalDataPtr - Source;\n        return pPlane;\n    }\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    pPlane.Plane_Status = PlaneStatuses.Valid;\n    return pPlane;\n  }\n  static decode_00(Source) {\n    let Dest = new Uint8Array();\n    let i;\n    for (i = 0; i < WPC.DmdPageBytes; i++) {\n      Dest[i] = ROM.byteAtAddr(Source + i);\n      if (Source + i >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    return Dest;\n  }\n  static decode_01(Source) {\n    return this.decode_01or02(Source, WriteTypes.Columns);\n  }\n  static decode_02(Source) {\n    return this.decode_01or02(Source, WriteTypes.Rows);\n  }\n  static decode_01or02(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    WriteCounter = 0;\n    DestPtr = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return Dest;\n  }\n  static decode_03(Source) {\n    return new Uint8Array();\n  }\n  static decode_04(Source) {\n    return this.decode_04or05(Source, WriteTypes.Columns);\n  }\n  static decode_05(Source) {\n    return this.decode_04or05(Source, WriteTypes.Rows);\n  }\n  static decode_04or05(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n    };\n    let ch;\n    let i;\n    let WriteCounter;\n    WriteCounter = 0;\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    do {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      ch = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == Header.SpecialFlagByte) {\n        const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result1[0];\n        let Value1 = result1[1];\n        SourcePtr = result1[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result2[0];\n        let Value2 = result2[1];\n        SourcePtr = result2[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return Dest;\n  }\n  static decode_06(Source) {\n    return this.decode_06or07(Source, WriteTypes.Columns);\n  }\n  static decode_07(Source) {\n    return this.decode_06or07(Source, WriteTypes.Rows);\n  }\n  static decode_06or07(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n    let XorBits = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let XorFlagsPtr = 0;\n    let XorBitsPtr = 0;\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    let XorFlagsCounter;\n    let XorBitsCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, XorFlags, XorBits];\n    }\n    WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, XorFlags, XorBits];\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xFF, Type);\n          XorFlagsPtr = resultXorFlags[0];\n          XorFlags = resultXorFlags[1];\n          XorFlagsCounter = resultXorFlags[2];\n          const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n          XorBitsPtr = resultXorBits[0];\n          XorBits = resultXorBits[1];\n          XorBitsCounter = resultXorBits[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n        const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n        XorFlagsPtr = resultXorFlags[0];\n        XorFlags = resultXorFlags[1];\n        XorFlagsCounter = resultXorFlags[2];\n        const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n        XorBitsPtr = resultXorBits[0];\n        XorBits = resultXorBits[1];\n        XorBitsCounter = resultXorBits[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return [Dest, XorFlags, XorBits];\n  }\n  static decode_08(Source) {\n    return this.decode_08or09(Source, WriteTypes.Columns);\n  }\n  static decode_09(Source) {\n    return this.decode_08or09(Source, WriteTypes.Rows);\n  }\n  static decode_08or09(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let count;\n    let pattern;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    function repeatSkips() {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n    }\n    count = SourcePtr;\n    count = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    WriteCounter = SkippedCounter = 0;\n    if (!count) {\n      repeatSkips();\n    }\n    while (continueLooping) {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          pattern = ROM.byteAtAddr(SourcePtr);\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      if (continueLooping) {\n        repeatSkips();\n      }\n    }\n    return [Dest, Skipped];\n  }\n  static decode_0A(Source) {\n    return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n  }\n  static decode_0B(Source) {\n    return this.decode_0Aor0B(Source, WriteTypes.Rows);\n  }\n  static decode_0Aor0B(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: 0\n    };\n    let count;\n    let i;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    Header.ReadMask = 0x80;\n    WriteCounter = SkippedCounter = 0;\n    function BulkSkips() {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n        return [Dest, Skipped];\n      }\n      return [Dest, Skipped];\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n    }\n    const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n    Header = result[0];\n    count = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    if (!count) {\n      BulkSkips();\n    }\n    while (continueLooping) {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n          Header = resultRead[0];\n          const Read = resultRead[1];\n          SourcePtr = resultRead[2];\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      BulkSkips();\n    }\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return [Dest, Skipped];\n  }\n  static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n    Dest.set([ch], DestPtr);\n    WriteCounterPtr++;\n    if (WriteCounterPtr >= WPC.DmdPageBytes) {\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (Type == WriteTypes.Rows) {\n      DestPtr++;\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (!(WriteCounterPtr % WPC.DmdRows)) {\n      DestPtr -= WPC.DmdCols / 8 * (WPC.DmdRows - 2) + (WPC.DmdCols / 8 - 1);\n    } else {\n      DestPtr += WPC.DmdCols / 8;\n    }\n    return [DestPtr, Dest, WriteCounterPtr];\n  }\n  static readNext8BitValue(Header, SourcePtr) {\n    let returnValues;\n    const result = DmdDecoder.readNextBit(Header, SourcePtr);\n    let ch = result[0];\n    Header = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      returnValues = [Header, 0x00, SourcePtr];\n      return returnValues;\n    }\n    let WriteMask;\n    let ReturnValue;\n    let i;\n    if (ch) {\n      let OnesCount = 0;\n      for (i = 0; i < 7; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          OnesCount++;\n        } else {\n          i = 7;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n      }\n      ReturnValue = Header.RepeatBytes[OnesCount];\n    } else {\n      WriteMask = 0x80;\n      ReturnValue = 0x00;\n      for (i = 0; i < 8; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          ReturnValue |= WriteMask;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n        WriteMask >>= 1;\n      }\n    }\n    returnValues = [Header, ReturnValue, SourcePtr];\n    return returnValues;\n  }\n  static readNextBit(Header, SourcePtr) {\n    let returnValues;\n    let ch = ROM.byteAtAddr(SourcePtr) & Header.ReadMask;\n    if (!(Header.ReadMask >>= 1)) {\n      Header.ReadMask = 0x80;\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        returnValues = [0x00, Header, SourcePtr];\n        return returnValues;\n      }\n    }\n    returnValues = [ch, Header, SourcePtr];\n    return returnValues;\n  }\n}","map":{"version":3,"names":["WriteTypes","ImageCodes","DataTypes","PlaneStatuses","WPC","DataParser","toHex","logStr","Settings","VariableSizedImageData","FullFrameImageData","ROM","DmdDecoder","constructor","PreviousPlaneDataPane0","Uint8Array","PreviousPlaneDataPane1","init","decodeNextIndex","count","DataType","Graphics","CurrentImageIndex","FontData","AniData","Planes","Plane0","Plane_Status","Valid","CurrentImageXShift","DmdCols","CurrentImageXSize","ImageShiftXPixelCount","CurrentImageYShift","DmdRows","CurrentImageYSize","ImageShiftYPixelCount","result","incrementVariableSizedImageIndex","CurrentTableIndex","pTableIndex","pImageIndex","tmpImageIndex","getLastImageIndex","getNextImageIndex","maxTableIndex","getFirstImageIndex","decrementVariableSizedImageIndex","getPrevImageIndex","minTableIndex","decodePreviousIndex","decodeFullFrameGraphic","GraphicIndex","decodeImageToPlane","Plane1","decodeVariableSizedImageData","decodeVariableSizedImageIndexToPlane","TableIndex","ImageIndex","DataPtr","Addr","defaultPlane","Plane_Size","Plane_Data","DmdPageBytes","Plane_Skipped","Plane_XorFlags","Plane_XorBits","pPlanes","decodePlaneInit","getROMAddressOfVariableSizedImageIndex","BadDimension","decodeVariableSizedImage","Source","TableHeight","TableSpacing","ch","byteAtAddr","getVariableSizedImageTableMetadata","decodeVariableSizedImageIndex_NoHeader","Monochrome","BicolorIndirect","BicolorDirect","FD","decodeVariableSizedImageIndex_Header","decodeVariableSizedImage_Centered","SourcePtr","Dest","ImageHeight","ImageWidth","WriteCounter","i","j","DestPtr","endPtr","ImageOutOfRange","writeNext8BitValue","Rows","Math","ceil","floor","DestPlane0","DestPlane1","Invalid","HeaderByte","VerticalOffset","HorizontalOffset","result1","result0","Page","TmpBuf","pBiColor","extractWPCAddrAndPageOfImageTable","getROMAddressFromAddrOf3ByteWPCAddrPage","Index","pPlane","OriginalDataPtr","DMDPlane","TableAddress","size","TableEntryOutOfRange","decodeFullFrameGraphicImage","Plane","Skipped","XorFlags","XorBits","decode_00","decode_01","decode_02","decode_03","Unimplemented","decode_04","decode_05","result_06","decode_06","result_07","decode_07","result_08","decode_08","result_09","decode_09","result_0A","decode_0A","result_0B","decode_0B","Unknown","decode_01or02","Columns","Type","SpecialFlagByte","Value1","Value2","decode_04or05","Header","ReadMask","RepeatBytes","readNext8BitValue","result2","decode_06or07","XorFlagsPtr","XorBitsPtr","XorFlagsCounter","XorBitsCounter","resultXorFlags","resultXorBits","decode_08or09","SkippedPtr","pattern","SkippedCounter","continueLooping","repeatSkips","resultSkipped","decode_0Aor0B","BulkSkips","resultRead","Read","WriteCounterPtr","set","returnValues","readNextBit","WriteMask","ReturnValue","OnesCount"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/node_modules/wpcedit/dist/src/classes/DmdDecoder.js"],"sourcesContent":["import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { Settings } from \"../stores/Settings.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n    constructor() {\n        this.PreviousPlaneDataPane0 = new Uint8Array();\n        this.PreviousPlaneDataPane1 = new Uint8Array();\n    }\n    init() {\n    }\n    static decodeNextIndex(count) {\n        switch (Settings.DataType) {\n            case DataTypes.Graphics:\n                while (count--) {\n                    {\n                        FullFrameImageData.CurrentImageIndex++;\n                    }\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n                    if ((VariableSizedImageData.CurrentImageXShift + WPC.DmdCols) < VariableSizedImageData.CurrentImageXSize) {\n                        VariableSizedImageData.CurrentImageXShift += (WPC.ImageShiftXPixelCount * count);\n                        break;\n                    }\n                    if ((VariableSizedImageData.CurrentImageYShift + WPC.DmdRows) < VariableSizedImageData.CurrentImageYSize) {\n                        VariableSizedImageData.CurrentImageYShift += (WPC.ImageShiftYPixelCount * count);\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                        logStr(`Unexpected error advancing image indexes`);\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if ((pTableIndex == null) || (pImageIndex == null)) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex);\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if (((pImageIndex) & 0xFF) < (tmpImageIndex & 0xFF)) {\n            pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n            pTableIndex++;\n            pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [0, 0];\n    }\n    static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if ((pTableIndex == null) || (pImageIndex == null)) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if (((pImageIndex) & 0xFF) > (tmpImageIndex & 0xFF)) {\n            pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex > VariableSizedImageData.minTableIndex) {\n            pTableIndex = (pTableIndex) - 1;\n            if (DataParser.getLastImageIndex(pImageIndex, pTableIndex) != 0) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [pTableIndex, pImageIndex];\n    }\n    static decodePreviousIndex(count) {\n        switch (Settings.DataType) {\n            case DataTypes.Graphics:\n                while ((count--) && (FullFrameImageData.CurrentImageIndex)) {\n                    FullFrameImageData.CurrentImageIndex--;\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n                    if (VariableSizedImageData.CurrentImageYShift > 0) {\n                        VariableSizedImageData.CurrentImageYShift -= (WPC.ImageShiftYPixelCount * count);\n                        if (VariableSizedImageData.CurrentImageYShift < 0) {\n                            VariableSizedImageData.CurrentImageYShift = 0;\n                        }\n                        break;\n                    }\n                    if (VariableSizedImageData.CurrentImageXShift > 0) {\n                        VariableSizedImageData.CurrentImageXShift -= (WPC.ImageShiftXPixelCount * count);\n                        if (VariableSizedImageData.CurrentImageXShift < 0) {\n                            VariableSizedImageData.CurrentImageXShift = 0;\n                        }\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static decodeFullFrameGraphic(GraphicIndex) {\n        FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n        FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane((GraphicIndex + 1));\n    }\n    static decodeVariableSizedImageData() {\n        const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n        VariableSizedImageData.Planes = result[1];\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n            VariableSizedImageData.CurrentImageXSize = 0;\n            VariableSizedImageData.CurrentImageYSize = 0;\n            VariableSizedImageData.CurrentImageXShift = 0;\n            VariableSizedImageData.CurrentImageYShift = 0;\n        }\n    }\n    static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n        let DataPtr;\n        let Addr;\n        const defaultPlane = {\n            Plane_Status: 0,\n            Plane_Size: 0,\n            Plane_Data: new Uint8Array(WPC.DmdPageBytes),\n            Plane_Skipped: new Uint8Array(WPC.DmdPageBytes),\n            Plane_XorFlags: new Uint8Array(WPC.DmdPageBytes),\n            Plane_XorBits: new Uint8Array(WPC.DmdPageBytes),\n        };\n        let pPlanes = {\n            Plane0: defaultPlane,\n            Plane1: defaultPlane\n        };\n        pPlanes.Plane0 = DmdDecoder.decodePlaneInit();\n        pPlanes.Plane1 = DmdDecoder.decodePlaneInit();\n        VariableSizedImageData.CurrentImageXSize = 0;\n        VariableSizedImageData.CurrentImageYSize = 0;\n        Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n        if (Addr == -1) {\n            pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n            pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n            return [-1, pPlanes];\n        }\n        DataPtr = (Addr);\n        pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n        let TableHeight;\n        let TableSpacing;\n        let ch = ROM.byteAtAddr(Source);\n        const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n        TableHeight = result[0];\n        TableSpacing = result[1];\n        if (TableHeight == -1) {\n            logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n            return [-1, pPlanes];\n        }\n        if ((ch > 0) && (ch <= WPC.DmdCols)) {\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n        }\n        else {\n            switch (ch) {\n                case ImageCodes.Monochrome:\n                case ImageCodes.BicolorIndirect:\n                case ImageCodes.BicolorDirect:\n                case ImageCodes.FD:\n                    break;\n                default:\n                    logStr(`Unrecognized Header Byte ${ch}`);\n                    break;\n            }\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n        }\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage_Centered(SourcePtr, Dest, ImageHeight, ImageWidth) {\n        let ch;\n        let WriteCounter = 0;\n        let i, j;\n        let DestPtr = 0;\n        if ((SourcePtr) >= ROM.endPtr) {\n            return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (VariableSizedImageData.CurrentImageYShift == -1) {\n            VariableSizedImageData.CurrentImageYShift = 0;\n            while ((WPC.DmdRows + VariableSizedImageData.CurrentImageYShift) < ImageHeight) {\n                VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n            }\n        }\n        if (VariableSizedImageData.CurrentImageXShift == -1) {\n            VariableSizedImageData.CurrentImageXShift = 0;\n            while ((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) < ImageWidth) {\n                VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n            }\n        }\n        for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        for (i = 0; ((i < WPC.DmdRows) && (WriteCounter < WPC.DmdPageBytes)); i++) {\n            if (ImageHeight < WPC.DmdRows) {\n                if ((i < ((WPC.DmdRows - ImageHeight) / 2)) ||\n                    (i >= (((WPC.DmdRows - ImageHeight) / 2) + ImageHeight))) {\n                    for (j = 0; j < (WPC.DmdCols / 8); j++) {\n                        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                        DestPtr = result[0];\n                        Dest = result[1];\n                        WriteCounter = result[2];\n                    }\n                    continue;\n                }\n            }\n            if (ImageHeight > WPC.DmdRows) {\n                if (i >= (ImageHeight - VariableSizedImageData.CurrentImageYShift)) {\n                    for (j = 0; j < (WPC.DmdCols / 8); j++) {\n                        const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                        DestPtr = result[0];\n                        Dest = result[1];\n                        WriteCounter = result[2];\n                    }\n                    continue;\n                }\n            }\n            if (ImageWidth < WPC.DmdCols) {\n                for (j = 0; j < Math.ceil(((WPC.DmdCols - ImageWidth) / 2) / 8); j++) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n            for (j = 0; j < Math.floor(((ImageWidth + 7) / 8)); j++) {\n                ch = ROM.byteAtAddr(SourcePtr);\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n                if ((j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8)) && (j < Math.floor(((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) + 7) / 8))) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n            if (ImageWidth < WPC.DmdCols) {\n                for (j = (Math.ceil(((WPC.DmdCols - ImageWidth) / 2) / 8) + ((ImageWidth + 7) / 8)); j < (WPC.DmdCols / 8); j++) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n        }\n        for (i = 0; i < (ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift)); i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        VariableSizedImageData.CurrentImageXSize = ImageWidth;\n        VariableSizedImageData.CurrentImageYSize = ImageHeight;\n        return [PlaneStatuses.Valid, Dest, SourcePtr];\n    }\n    static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane1.Plane_Size = 0;\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        if ((SourcePtr++) >= ROM.endPtr) {\n            logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n            return pPlanes;\n        }\n        const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        SourcePtr = result[2];\n        return pPlanes;\n    }\n    static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let HeaderByte;\n        let VerticalOffset;\n        let HorizontalOffset;\n        let ImageHeight;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane0.Plane_Size = 0;\n        HeaderByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        VerticalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageHeight = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        switch (HeaderByte) {\n            case ImageCodes.BicolorDirect:\n                const result1 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n                pPlanes.Plane1.Plane_Status = result1[0];\n                pPlanes.Plane1.Plane_Data = result1[1];\n                const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result0[0];\n                pPlanes.Plane0.Plane_Data = result0[1];\n                break;\n            case ImageCodes.BicolorIndirect:\n                {\n                    let Page;\n                    let TmpBuf = [0, 0, 0];\n                    let Addr;\n                    let pBiColor;\n                    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n                    Addr = result[0];\n                    Page = result[1];\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n                        return pPlanes;\n                    }\n                    TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[2] = (Page & 0xFF);\n                    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xFF} ${(TmpBuf[1] & 0xFF)} ${(TmpBuf[2] & 0xFF)}`);\n                        return pPlanes;\n                    }\n                    pBiColor = ROM.byteAtAddr(Addr);\n                    const result1 = this.decodeVariableSizedImage_Centered(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n                    pPlanes.Plane1.Plane_Status = result1[0];\n                    pPlanes.Plane1.Plane_Data = result1[1];\n                    const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                    pPlanes.Plane0.Plane_Status = result0[0];\n                    pPlanes.Plane0.Plane_Data = result0[1];\n                }\n                break;\n            case ImageCodes.FD:\n            default:\n                const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result[0];\n                pPlanes.Plane0.Plane_Data = result[1];\n                break;\n        }\n        return pPlanes;\n    }\n    static decodeImageToPlane(Index) {\n        let pPlane;\n        let OriginalDataPtr;\n        let DataPtr;\n        let Addr;\n        let DMDPlane;\n        DMDPlane = DmdDecoder.decodePlaneInit();\n        Addr = FullFrameImageData.TableAddress + (Index * 3);\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n        if (Addr == -1) {\n            logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        OriginalDataPtr = DataPtr = Addr;\n        DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane);\n        DMDPlane.Plane_Size = (DataPtr - OriginalDataPtr);\n        return DMDPlane;\n    }\n    static decodePlaneInit() {\n        let Plane = new Uint8Array(WPC.DmdPageBytes);\n        let pPlane = {\n            Plane_Size: 0,\n            Plane_Data: Plane,\n            Plane_Skipped: Plane,\n            Plane_XorFlags: Plane,\n            Plane_XorBits: Plane,\n            Plane_Status: PlaneStatuses.Valid\n        };\n        return pPlane;\n    }\n    static decodeFullFrameGraphicImage(Source, pPlane) {\n        let OriginalDataPtr = Source;\n        let Dest = new Uint8Array(pPlane.Plane_Data);\n        let Skipped = pPlane.Plane_Skipped;\n        let XorFlags = pPlane.Plane_XorFlags;\n        let XorBits = pPlane.Plane_XorBits;\n        let ch = ROM.byteAtAddr(Source);\n        Source++;\n        if ((Source) >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        logStr(`Type ${toHex(ch)}`);\n        switch (ch & 0x0F) {\n            case 0x00:\n                Dest = this.decode_00(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x01:\n                Dest = this.decode_01(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x02:\n                Dest = this.decode_02(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x03:\n                Dest = this.decode_03(Source);\n                pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n                return pPlane;\n            case 0x04:\n                Dest = this.decode_04(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x05:\n                Dest = this.decode_05(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x06:\n                const result_06 = this.decode_06(Source);\n                pPlane.Plane_Data = result_06[0];\n                pPlane.Plane_Skipped = result_06[1];\n                pPlane.Plane_XorFlags = result_06[2];\n                pPlane.Plane_XorFlags = result_06[3];\n                return pPlane;\n            case 0x07:\n                const result_07 = this.decode_07(Source);\n                pPlane.Plane_Data = result_07[0];\n                pPlane.Plane_Skipped = result_07[1];\n                pPlane.Plane_XorFlags = result_07[2];\n                pPlane.Plane_XorFlags = result_07[3];\n                return pPlane;\n            case 0x08:\n                const result_08 = this.decode_08(Source);\n                pPlane.Plane_Data = result_08[0];\n                pPlane.Plane_Skipped = result_08[1];\n                return pPlane;\n                break;\n            case 0x09:\n                const result_09 = this.decode_09(Source);\n                pPlane.Plane_Data = result_09[0];\n                pPlane.Plane_Skipped = result_09[1];\n                return pPlane;\n            case 0x0A:\n                const result_0A = this.decode_0A(Source);\n                pPlane.Plane_Data = result_0A[0];\n                pPlane.Plane_Skipped = result_0A[1];\n                return pPlane;\n            case 0x0B:\n                const result_0B = this.decode_0B(Source);\n                pPlane.Plane_Data = result_0B[0];\n                pPlane.Plane_Skipped = result_0B[1];\n                return pPlane;\n            default:\n                logStr(`Unknown Image Type ${ch}`);\n                pPlane.Plane_Data = Dest;\n                pPlane.Plane_Status = PlaneStatuses.Unknown;\n                pPlane.Plane_Size = OriginalDataPtr - Source;\n                return pPlane;\n        }\n        if ((Source) >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        pPlane.Plane_Status = PlaneStatuses.Valid;\n        return pPlane;\n    }\n    static decode_00(Source) {\n        let Dest = new Uint8Array();\n        let i;\n        for (i = 0; i < WPC.DmdPageBytes; i++) {\n            Dest[i] = ROM.byteAtAddr(Source + i);\n            if (Source + i >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        return Dest;\n    }\n    static decode_01(Source) {\n        return this.decode_01or02(Source, WriteTypes.Columns);\n    }\n    static decode_02(Source) {\n        return this.decode_01or02(Source, WriteTypes.Rows);\n    }\n    static decode_01or02(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if ((SourcePtr) >= ROM.endPtr) {\n            return Dest;\n        }\n        WriteCounter = 0;\n        DestPtr = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return Dest;\n    }\n    static decode_03(Source) {\n        return new Uint8Array();\n    }\n    static decode_04(Source) {\n        return this.decode_04or05(Source, WriteTypes.Columns);\n    }\n    static decode_05(Source) {\n        return this.decode_04or05(Source, WriteTypes.Rows);\n    }\n    static decode_04or05(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n        };\n        let ch;\n        let i;\n        let WriteCounter;\n        WriteCounter = 0;\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return Dest;\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        do {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            ch = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == Header.SpecialFlagByte) {\n                const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result1[0];\n                let Value1 = result1[1];\n                SourcePtr = result1[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result2[0];\n                let Value2 = result2[1];\n                SourcePtr = result2[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return Dest;\n    }\n    static decode_06(Source) {\n        return this.decode_06or07(Source, WriteTypes.Columns);\n    }\n    static decode_07(Source) {\n        return this.decode_06or07(Source, WriteTypes.Rows);\n    }\n    static decode_06or07(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n        let XorBits = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let XorFlagsPtr = 0;\n        let XorBitsPtr = 0;\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        let XorFlagsCounter;\n        let XorBitsCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, XorFlags, XorBits];\n        }\n        WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, XorFlags, XorBits];\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xFF, Type);\n                    XorFlagsPtr = resultXorFlags[0];\n                    XorFlags = resultXorFlags[1];\n                    XorFlagsCounter = resultXorFlags[2];\n                    const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n                    XorBitsPtr = resultXorBits[0];\n                    XorBits = resultXorBits[1];\n                    XorBitsCounter = resultXorBits[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n                const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n                XorFlagsPtr = resultXorFlags[0];\n                XorFlags = resultXorFlags[1];\n                XorFlagsCounter = resultXorFlags[2];\n                const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n                XorBitsPtr = resultXorBits[0];\n                XorBits = resultXorBits[1];\n                XorBitsCounter = resultXorBits[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return [Dest, XorFlags, XorBits];\n    }\n    static decode_08(Source) {\n        return this.decode_08or09(Source, WriteTypes.Columns);\n    }\n    static decode_09(Source) {\n        return this.decode_08or09(Source, WriteTypes.Rows);\n    }\n    static decode_08or09(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let count;\n        let pattern;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        function repeatSkips() {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n        }\n        count = SourcePtr;\n        count = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        WriteCounter = SkippedCounter = 0;\n        if (!count) {\n            repeatSkips();\n        }\n        while (continueLooping) {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    pattern = ROM.byteAtAddr(SourcePtr);\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            if (continueLooping) {\n                repeatSkips();\n            }\n        }\n        return [Dest, Skipped];\n    }\n    static decode_0A(Source) {\n        return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n    }\n    static decode_0B(Source) {\n        return this.decode_0Aor0B(Source, WriteTypes.Rows);\n    }\n    static decode_0Aor0B(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: 0\n        };\n        let count;\n        let i;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        Header.ReadMask = 0x80;\n        WriteCounter = SkippedCounter = 0;\n        function BulkSkips() {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n                return [Dest, Skipped];\n            }\n            return [Dest, Skipped];\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n        }\n        const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result[0];\n        count = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        if (!count) {\n            BulkSkips();\n        }\n        while (continueLooping) {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                    Header = resultRead[0];\n                    const Read = resultRead[1];\n                    SourcePtr = resultRead[2];\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            BulkSkips();\n        }\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return [Dest, Skipped];\n    }\n    static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n        Dest.set([ch], DestPtr);\n        WriteCounterPtr++;\n        if ((WriteCounterPtr) >= WPC.DmdPageBytes) {\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (Type == WriteTypes.Rows) {\n            DestPtr++;\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (!(WriteCounterPtr % (WPC.DmdRows))) {\n            DestPtr -= (((WPC.DmdCols / 8) * (WPC.DmdRows - 2)) + ((WPC.DmdCols / 8) - 1));\n        }\n        else {\n            DestPtr += (WPC.DmdCols / 8);\n        }\n        return [DestPtr, Dest, WriteCounterPtr];\n    }\n    static readNext8BitValue(Header, SourcePtr) {\n        let returnValues;\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        let ch = result[0];\n        Header = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            returnValues = [Header, 0x00, SourcePtr];\n            return returnValues;\n        }\n        let WriteMask;\n        let ReturnValue;\n        let i;\n        if (ch) {\n            let OnesCount = 0;\n            for (i = 0; i < 7; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    OnesCount++;\n                }\n                else {\n                    i = 7;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n            }\n            ReturnValue = Header.RepeatBytes[OnesCount];\n        }\n        else {\n            WriteMask = 0x80;\n            ReturnValue = 0x00;\n            for (i = 0; i < 8; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    ReturnValue |= WriteMask;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n                WriteMask >>= 1;\n            }\n        }\n        returnValues = [Header, ReturnValue, SourcePtr];\n        return (returnValues);\n    }\n    static readNextBit(Header, SourcePtr) {\n        let returnValues;\n        let ch = (ROM.byteAtAddr(SourcePtr) & Header.ReadMask);\n        if (!(Header.ReadMask >>= 1)) {\n            Header.ReadMask = 0x80;\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                returnValues = [0x00, Header, SourcePtr];\n                return returnValues;\n            }\n        }\n        returnValues = [ch, Header, SourcePtr];\n        return returnValues;\n    }\n}\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,EAAEC,SAAS,EAAEC,aAAa,EAAEC,GAAG,QAAQ,2BAA2B;AACjG,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,KAAK,EAAEC,MAAM,QAAQ,yBAAyB;AACvD,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,sBAAsB,QAAQ,qCAAqC;AAC5E,SAASC,kBAAkB,QAAQ,iCAAiC;AACpE,SAASC,GAAG,QAAQ,kBAAkB;AACtC,OAAO,MAAMC,UAAU,CAAC;EACpBC,WAAW,GAAG;IACV,IAAI,CAACC,sBAAsB,GAAG,IAAIC,UAAU,EAAE;IAC9C,IAAI,CAACC,sBAAsB,GAAG,IAAID,UAAU,EAAE;EAClD;EACAE,IAAI,GAAG,CACP;EACA,OAAOC,eAAe,CAACC,KAAK,EAAE;IAC1B,QAAQX,QAAQ,CAACY,QAAQ;MACrB,KAAKlB,SAAS,CAACmB,QAAQ;QACnB,OAAOF,KAAK,EAAE,EAAE;UACZ;YACIT,kBAAkB,CAACY,iBAAiB,EAAE;UAC1C;QACJ;QACA;MACJ,KAAKpB,SAAS,CAACqB,QAAQ;MACvB,KAAKrB,SAAS,CAACsB,OAAO;QAClB,IAAIf,sBAAsB,CAACgB,MAAM,CAACC,MAAM,CAACC,YAAY,IAAIxB,aAAa,CAACyB,KAAK,EAAE;UAC1E,IAAKnB,sBAAsB,CAACoB,kBAAkB,GAAGzB,GAAG,CAAC0B,OAAO,GAAIrB,sBAAsB,CAACsB,iBAAiB,EAAE;YACtGtB,sBAAsB,CAACoB,kBAAkB,IAAKzB,GAAG,CAAC4B,qBAAqB,GAAGb,KAAM;YAChF;UACJ;UACA,IAAKV,sBAAsB,CAACwB,kBAAkB,GAAG7B,GAAG,CAAC8B,OAAO,GAAIzB,sBAAsB,CAAC0B,iBAAiB,EAAE;YACtG1B,sBAAsB,CAACwB,kBAAkB,IAAK7B,GAAG,CAACgC,qBAAqB,GAAGjB,KAAM;YAChF;UACJ;QACJ;QACAV,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,CAAC;QAC9CpB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,CAAC;QAC9C,OAAOd,KAAK,EAAE,EAAE;UACZ,MAAMkB,MAAM,GAAGzB,UAAU,CAAC0B,gCAAgC,CAAC7B,sBAAsB,CAAC8B,iBAAiB,EAAE9B,sBAAsB,CAACa,iBAAiB,CAAC;UAC9Ib,sBAAsB,CAAC8B,iBAAiB,GAAGF,MAAM,CAAC,CAAC,CAAC;UACpD5B,sBAAsB,CAACa,iBAAiB,GAAGe,MAAM,CAAC,CAAC,CAAC;UACpD,IAAIA,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;YACjB9B,MAAM,CAAE,0CAAyC,CAAC;UACtD;QACJ;QACA;MACJ;QACI;IAAM;EAElB;EACA,OAAO+B,gCAAgC,CAACE,WAAW,EAAEC,WAAW,EAAE;IAC9D,IAAIC,aAAa;IACjB,IAAKF,WAAW,IAAI,IAAI,IAAMC,WAAW,IAAI,IAAK,EAAE;MAChD,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACAC,aAAa,GAAGrC,UAAU,CAACsC,iBAAiB,CAACF,WAAW,EAAED,WAAW,CAAC;IACtE,IAAIE,aAAa,IAAI,CAAC,CAAC,EAAE;MACrB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACA,IAAI,CAAED,WAAW,GAAI,IAAI,KAAKC,aAAa,GAAG,IAAI,CAAC,EAAE;MACjDD,WAAW,GAAGpC,UAAU,CAACuC,iBAAiB,CAACH,WAAW,EAAED,WAAW,CAAC;MACpE,IAAIC,WAAW,IAAI,CAAC,CAAC,EAAE;QACnB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,IAAID,WAAW,GAAG/B,sBAAsB,CAACoC,aAAa,EAAE;MACpDL,WAAW,EAAE;MACbC,WAAW,GAAGpC,UAAU,CAACyC,kBAAkB,CAACN,WAAW,CAAC;MACxD,IAAIC,WAAW,IAAI,CAAC,CAAC,EAAE;QACnB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EACjB;EACA,OAAOM,gCAAgC,CAACP,WAAW,EAAEC,WAAW,EAAE;IAC9D,IAAIC,aAAa;IACjB,IAAKF,WAAW,IAAI,IAAI,IAAMC,WAAW,IAAI,IAAK,EAAE;MAChD,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACAC,aAAa,GAAGrC,UAAU,CAACyC,kBAAkB,CAACN,WAAW,CAAC;IAC1D,IAAIE,aAAa,IAAI,CAAC,CAAC,EAAE;MACrB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACA,IAAI,CAAED,WAAW,GAAI,IAAI,KAAKC,aAAa,GAAG,IAAI,CAAC,EAAE;MACjDD,WAAW,GAAGpC,UAAU,CAAC2C,iBAAiB,CAACP,WAAW,EAAED,WAAW,CAAC;MACpE,IAAIC,WAAW,IAAI,CAAC,CAAC,EAAE;QACnB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,IAAID,WAAW,GAAG/B,sBAAsB,CAACwC,aAAa,EAAE;MACpDT,WAAW,GAAIA,WAAW,GAAI,CAAC;MAC/B,IAAInC,UAAU,CAACsC,iBAAiB,CAACF,WAAW,EAAED,WAAW,CAAC,IAAI,CAAC,EAAE;QAC7D,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACA,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;EACrC;EACA,OAAOS,mBAAmB,CAAC/B,KAAK,EAAE;IAC9B,QAAQX,QAAQ,CAACY,QAAQ;MACrB,KAAKlB,SAAS,CAACmB,QAAQ;QACnB,OAAQF,KAAK,EAAE,IAAMT,kBAAkB,CAACY,iBAAkB,EAAE;UACxDZ,kBAAkB,CAACY,iBAAiB,EAAE;QAC1C;QACA;MACJ,KAAKpB,SAAS,CAACqB,QAAQ;MACvB,KAAKrB,SAAS,CAACsB,OAAO;QAClB,IAAIf,sBAAsB,CAACgB,MAAM,CAACC,MAAM,CAACC,YAAY,IAAIxB,aAAa,CAACyB,KAAK,EAAE;UAC1E,IAAInB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,EAAE;YAC/CxB,sBAAsB,CAACwB,kBAAkB,IAAK7B,GAAG,CAACgC,qBAAqB,GAAGjB,KAAM;YAChF,IAAIV,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,EAAE;cAC/CxB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC;YACjD;YACA;UACJ;UACA,IAAIxB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,EAAE;YAC/CpB,sBAAsB,CAACoB,kBAAkB,IAAKzB,GAAG,CAAC4B,qBAAqB,GAAGb,KAAM;YAChF,IAAIV,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,EAAE;cAC/CpB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC;YACjD;YACA;UACJ;QACJ;QACApB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,CAAC;QAC9CpB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,CAAC;QAC9C,OAAOd,KAAK,EAAE,EAAE;UACZ,MAAMkB,MAAM,GAAGzB,UAAU,CAACmC,gCAAgC,CAACtC,sBAAsB,CAAC8B,iBAAiB,EAAE9B,sBAAsB,CAACa,iBAAiB,CAAC;UAC9Ib,sBAAsB,CAAC8B,iBAAiB,GAAGF,MAAM,CAAC,CAAC,CAAC;UACpD5B,sBAAsB,CAACa,iBAAiB,GAAGe,MAAM,CAAC,CAAC,CAAC;UACpD,IAAIA,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CACrB;QACJ;QACA;MACJ;QACI;IAAM;EAElB;EACA,OAAOc,sBAAsB,CAACC,YAAY,EAAE;IACxC1C,kBAAkB,CAACe,MAAM,CAACC,MAAM,GAAG,IAAI,CAAC2B,kBAAkB,CAACD,YAAY,CAAC;IACxE1C,kBAAkB,CAACe,MAAM,CAAC6B,MAAM,GAAG,IAAI,CAACD,kBAAkB,CAAED,YAAY,GAAG,CAAC,CAAE;EAClF;EACA,OAAOG,4BAA4B,GAAG;IAClC,MAAMlB,MAAM,GAAGzB,UAAU,CAAC4C,oCAAoC,CAAC/C,sBAAsB,CAAC8B,iBAAiB,EAAE9B,sBAAsB,CAACa,iBAAiB,CAAC;IAClJb,sBAAsB,CAACgB,MAAM,GAAGY,MAAM,CAAC,CAAC,CAAC;IACzC,IAAI5B,sBAAsB,CAACgB,MAAM,CAACC,MAAM,CAACC,YAAY,IAAIxB,aAAa,CAACyB,KAAK,EAAE;MAC1EnB,sBAAsB,CAACsB,iBAAiB,GAAG,CAAC;MAC5CtB,sBAAsB,CAAC0B,iBAAiB,GAAG,CAAC;MAC5C1B,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC;MAC7CpB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC;IACjD;EACJ;EACA,OAAOuB,oCAAoC,CAACC,UAAU,EAAEC,UAAU,EAAE;IAChE,IAAIC,OAAO;IACX,IAAIC,IAAI;IACR,MAAMC,YAAY,GAAG;MACjBlC,YAAY,EAAE,CAAC;MACfmC,UAAU,EAAE,CAAC;MACbC,UAAU,EAAE,IAAIhD,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;MAC5CC,aAAa,EAAE,IAAIlD,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;MAC/CE,cAAc,EAAE,IAAInD,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;MAChDG,aAAa,EAAE,IAAIpD,UAAU,CAACX,GAAG,CAAC4D,YAAY;IAClD,CAAC;IACD,IAAII,OAAO,GAAG;MACV1C,MAAM,EAAEmC,YAAY;MACpBP,MAAM,EAAEO;IACZ,CAAC;IACDO,OAAO,CAAC1C,MAAM,GAAGd,UAAU,CAACyD,eAAe,EAAE;IAC7CD,OAAO,CAACd,MAAM,GAAG1C,UAAU,CAACyD,eAAe,EAAE;IAC7C5D,sBAAsB,CAACsB,iBAAiB,GAAG,CAAC;IAC5CtB,sBAAsB,CAAC0B,iBAAiB,GAAG,CAAC;IAC5CyB,IAAI,GAAGvD,UAAU,CAACiE,sCAAsC,CAACb,UAAU,EAAEC,UAAU,CAAC;IAChF,IAAIE,IAAI,IAAI,CAAC,CAAC,EAAE;MACZQ,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGxB,aAAa,CAACoE,YAAY;MACxDH,OAAO,CAACd,MAAM,CAAC3B,YAAY,GAAGxB,aAAa,CAACoE,YAAY;MACxD,OAAO,CAAC,CAAC,CAAC,EAAEH,OAAO,CAAC;IACxB;IACAT,OAAO,GAAIC,IAAK;IAChBQ,OAAO,GAAGxD,UAAU,CAAC4D,wBAAwB,CAACb,OAAO,EAAES,OAAO,EAAEX,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9E,OAAO,CAAC,CAAC,EAAEW,OAAO,CAAC;EACvB;EACA,OAAOI,wBAAwB,CAACC,MAAM,EAAEL,OAAO,EAAEX,UAAU,EAAE;IACzD,IAAIiB,WAAW;IACf,IAAIC,YAAY;IAChB,IAAIC,EAAE,GAAGjE,GAAG,CAACkE,UAAU,CAACJ,MAAM,CAAC;IAC/B,MAAMpC,MAAM,GAAGhC,UAAU,CAACyE,kCAAkC,CAACrB,UAAU,CAAC;IACxEiB,WAAW,GAAGrC,MAAM,CAAC,CAAC,CAAC;IACvBsC,YAAY,GAAGtC,MAAM,CAAC,CAAC,CAAC;IACxB,IAAIqC,WAAW,IAAI,CAAC,CAAC,EAAE;MACnBnE,MAAM,CAAE,4CAA2CkD,UAAW,mBAAkB,CAAC;MACjF,OAAO,CAAC,CAAC,CAAC,EAAEW,OAAO,CAAC;IACxB;IACA,IAAKQ,EAAE,GAAG,CAAC,IAAMA,EAAE,IAAIxE,GAAG,CAAC0B,OAAQ,EAAE;MACjCsC,OAAO,GAAGxD,UAAU,CAACmE,sCAAsC,CAACN,MAAM,EAAEL,OAAO,EAAEM,WAAW,CAAC;IAC7F,CAAC,MACI;MACD,QAAQE,EAAE;QACN,KAAK3E,UAAU,CAAC+E,UAAU;QAC1B,KAAK/E,UAAU,CAACgF,eAAe;QAC/B,KAAKhF,UAAU,CAACiF,aAAa;QAC7B,KAAKjF,UAAU,CAACkF,EAAE;UACd;QACJ;UACI5E,MAAM,CAAE,4BAA2BqE,EAAG,EAAC,CAAC;UACxC;MAAM;MAEdR,OAAO,GAAGxD,UAAU,CAACwE,oCAAoC,CAACX,MAAM,EAAEL,OAAO,EAAEM,WAAW,EAAEjB,UAAU,CAAC;IACvG;IACA,OAAO,CAAC,CAAC,EAAEW,OAAO,CAAC;EACvB;EACA,OAAOiB,iCAAiC,CAACC,SAAS,EAAEC,IAAI,EAAEC,WAAW,EAAEC,UAAU,EAAE;IAC/E,IAAIb,EAAE;IACN,IAAIc,YAAY,GAAG,CAAC;IACpB,IAAIC,CAAC,EAAEC,CAAC;IACR,IAAIC,OAAO,GAAG,CAAC;IACf,IAAKP,SAAS,IAAK3E,GAAG,CAACmF,MAAM,EAAE;MAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;IAC3D;IACA,IAAI7E,sBAAsB,CAACwB,kBAAkB,IAAI,CAAC,CAAC,EAAE;MACjDxB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC;MAC7C,OAAQ7B,GAAG,CAAC8B,OAAO,GAAGzB,sBAAsB,CAACwB,kBAAkB,GAAIuD,WAAW,EAAE;QAC5E/E,sBAAsB,CAACwB,kBAAkB,IAAI7B,GAAG,CAACgC,qBAAqB;MAC1E;IACJ;IACA,IAAI3B,sBAAsB,CAACoB,kBAAkB,IAAI,CAAC,CAAC,EAAE;MACjDpB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC;MAC7C,OAAQzB,GAAG,CAAC0B,OAAO,GAAGrB,sBAAsB,CAACoB,kBAAkB,GAAI4D,UAAU,EAAE;QAC3EhF,sBAAsB,CAACoB,kBAAkB,IAAIzB,GAAG,CAAC4B,qBAAqB;MAC1E;IACJ;IACA,KAAK2D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlF,sBAAsB,CAACwB,kBAAkB,EAAE0D,CAAC,EAAE,EAAE;MAC5D,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAI,CAACH,UAAU,GAAG,CAAC,IAAI,CAAE,EAAEG,CAAC,EAAE,EAAE;QACzC,IAAIN,SAAS,EAAE,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;QAC3D;MACJ;IACJ;IACA,KAAKK,CAAC,GAAG,CAAC,EAAIA,CAAC,GAAGvF,GAAG,CAAC8B,OAAO,IAAMwD,YAAY,GAAGtF,GAAG,CAAC4D,YAAa,EAAG2B,CAAC,EAAE,EAAE;MACvE,IAAIH,WAAW,GAAGpF,GAAG,CAAC8B,OAAO,EAAE;QAC3B,IAAKyD,CAAC,GAAI,CAACvF,GAAG,CAAC8B,OAAO,GAAGsD,WAAW,IAAI,CAAE,IACrCG,CAAC,IAAM,CAACvF,GAAG,CAAC8B,OAAO,GAAGsD,WAAW,IAAI,CAAC,GAAIA,WAAa,EAAE;UAC1D,KAAKI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIxF,GAAG,CAAC0B,OAAO,GAAG,CAAE,EAAE8D,CAAC,EAAE,EAAE;YACpC,MAAMvD,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;YAChGJ,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;YACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;YAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UAC5B;UACA;QACJ;MACJ;MACA,IAAImD,WAAW,GAAGpF,GAAG,CAAC8B,OAAO,EAAE;QAC3B,IAAIyD,CAAC,IAAKH,WAAW,GAAG/E,sBAAsB,CAACwB,kBAAmB,EAAE;UAChE,KAAK2D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIxF,GAAG,CAAC0B,OAAO,GAAG,CAAE,EAAE8D,CAAC,EAAE,EAAE;YACpC,MAAMvD,MAAM,GAAG,IAAI,CAAC2D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;YAC1FJ,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;YACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;YAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UAC5B;UACA;QACJ;MACJ;MACA,IAAIoD,UAAU,GAAGrF,GAAG,CAAC0B,OAAO,EAAE;QAC1B,KAAK8D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,IAAI,CAACC,IAAI,CAAE,CAAC/F,GAAG,CAAC0B,OAAO,GAAG2D,UAAU,IAAI,CAAC,GAAI,CAAC,CAAC,EAAEG,CAAC,EAAE,EAAE;UAClE,MAAMvD,MAAM,GAAG,IAAI,CAAC2D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;UAC1FJ,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;QAC5B;MACJ;MACA,KAAKuD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,IAAI,CAACE,KAAK,CAAE,CAACX,UAAU,GAAG,CAAC,IAAI,CAAC,CAAE,EAAEG,CAAC,EAAE,EAAE;QACrDhB,EAAE,GAAGjE,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;QAC9B,IAAIA,SAAS,EAAE,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;QAC3D;QACA,IAAKM,CAAC,IAAIM,IAAI,CAACE,KAAK,CAAC,CAAC3F,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,IAAI,CAAC,CAAC,IAAM+D,CAAC,GAAGM,IAAI,CAACE,KAAK,CAAC,CAAEhG,GAAG,CAAC0B,OAAO,GAAGrB,sBAAsB,CAACoB,kBAAkB,GAAI,CAAC,IAAI,CAAC,CAAE,EAAE;UACjK,MAAMQ,MAAM,GAAG,IAAI,CAAC2D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAE5E,UAAU,CAACiG,IAAI,CAAC;UACxFJ,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;QAC5B;MACJ;MACA,IAAIoD,UAAU,GAAGrF,GAAG,CAAC0B,OAAO,EAAE;QAC1B,KAAK8D,CAAC,GAAIM,IAAI,CAACC,IAAI,CAAE,CAAC/F,GAAG,CAAC0B,OAAO,GAAG2D,UAAU,IAAI,CAAC,GAAI,CAAC,CAAC,GAAI,CAACA,UAAU,GAAG,CAAC,IAAI,CAAG,EAAEG,CAAC,GAAIxF,GAAG,CAAC0B,OAAO,GAAG,CAAE,EAAE8D,CAAC,EAAE,EAAE;UAC7G,MAAMvD,MAAM,GAAG,IAAI,CAAC2D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;UAC1FJ,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;QAC5B;MACJ;IACJ;IACA,KAAKsD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIH,WAAW,IAAIpF,GAAG,CAAC8B,OAAO,GAAGzB,sBAAsB,CAACwB,kBAAkB,CAAE,EAAE0D,CAAC,EAAE,EAAE;MAC5F,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAI,CAACH,UAAU,GAAG,CAAC,IAAI,CAAE,EAAEG,CAAC,EAAE,EAAE;QACzC,IAAIN,SAAS,EAAE,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;QAC3D;MACJ;IACJ;IACA7E,sBAAsB,CAACsB,iBAAiB,GAAG0D,UAAU;IACrDhF,sBAAsB,CAAC0B,iBAAiB,GAAGqD,WAAW;IACtD,OAAO,CAACrF,aAAa,CAACyB,KAAK,EAAE2D,IAAI,EAAED,SAAS,CAAC;EACjD;EACA,OAAOP,sCAAsC,CAACO,SAAS,EAAElB,OAAO,EAAEM,WAAW,EAAE;IAC3E,IAAI2B,UAAU,GAAGjC,OAAO,CAAC1C,MAAM,CAACqC,UAAU;IAC1C,IAAIuC,UAAU,GAAGlC,OAAO,CAACd,MAAM,CAACS,UAAU;IAC1C,IAAI0B,UAAU;IACdrB,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGxB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAACd,MAAM,CAAC3B,YAAY,GAAGxB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAAC1C,MAAM,CAACoC,UAAU,GAAG,CAAC;IAC7BM,OAAO,CAACd,MAAM,CAACQ,UAAU,GAAG,CAAC;IAC7B2B,UAAU,GAAG9E,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IACtC,IAAKA,SAAS,EAAE,IAAK3E,GAAG,CAACmF,MAAM,EAAE;MAC7BvF,MAAM,CAAE,sEAAqE,CAAC;MAC9E,OAAO6D,OAAO;IAClB;IACA,MAAM/B,MAAM,GAAG,IAAI,CAACgD,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAE3B,WAAW,EAAEe,UAAU,CAAC;IACrGrB,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGU,MAAM,CAAC,CAAC,CAAC;IACvC+B,OAAO,CAAC1C,MAAM,CAACqC,UAAU,GAAG1B,MAAM,CAAC,CAAC,CAAC;IACrCiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;IACrB,OAAO+B,OAAO;EAClB;EACA,OAAOgB,oCAAoC,CAACE,SAAS,EAAElB,OAAO,EAAEM,WAAW,EAAEjB,UAAU,EAAE;IACrF,IAAI4C,UAAU,GAAGjC,OAAO,CAAC1C,MAAM,CAACqC,UAAU;IAC1C,IAAIuC,UAAU,GAAGlC,OAAO,CAACd,MAAM,CAACS,UAAU;IAC1C,IAAIyC,UAAU;IACd,IAAIC,cAAc;IAClB,IAAIC,gBAAgB;IACpB,IAAIlB,WAAW;IACf,IAAIC,UAAU;IACdrB,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGxB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAACd,MAAM,CAAC3B,YAAY,GAAGxB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAAC1C,MAAM,CAACoC,UAAU,GAAG,CAAC;IAC7BM,OAAO,CAAC1C,MAAM,CAACoC,UAAU,GAAG,CAAC;IAC7B0C,UAAU,GAAG7F,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IACtCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAqC,cAAc,GAAG9F,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IAC1CA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAsC,gBAAgB,GAAG/F,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IAC5CA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAoB,WAAW,GAAG7E,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IACvCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAqB,UAAU,GAAG9E,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IACtCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACA,QAAQoC,UAAU;MACd,KAAKvG,UAAU,CAACiF,aAAa;QACzB,MAAMyB,OAAO,GAAG,IAAI,CAACtB,iCAAiC,CAACC,SAAS,EAAEgB,UAAU,EAAEd,WAAW,EAAEC,UAAU,CAAC;QACtGrB,OAAO,CAACd,MAAM,CAAC3B,YAAY,GAAGgF,OAAO,CAAC,CAAC,CAAC;QACxCvC,OAAO,CAACd,MAAM,CAACS,UAAU,GAAG4C,OAAO,CAAC,CAAC,CAAC;QACtC,MAAMC,OAAO,GAAG,IAAI,CAACvB,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAEb,WAAW,EAAEC,UAAU,CAAC;QACtGrB,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGiF,OAAO,CAAC,CAAC,CAAC;QACxCxC,OAAO,CAAC1C,MAAM,CAACqC,UAAU,GAAG6C,OAAO,CAAC,CAAC,CAAC;QACtC;MACJ,KAAK3G,UAAU,CAACgF,eAAe;QAC3B;UACI,IAAI4B,IAAI;UACR,IAAIC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UACtB,IAAIlD,IAAI;UACR,IAAImD,QAAQ;UACZ,MAAM1E,MAAM,GAAGhC,UAAU,CAAC2G,iCAAiC,CAACvD,UAAU,CAAC;UACvEG,IAAI,GAAGvB,MAAM,CAAC,CAAC,CAAC;UAChBwE,IAAI,GAAGxE,MAAM,CAAC,CAAC,CAAC;UAChB,IAAIuB,IAAI,IAAI,CAAC,CAAC,EAAE;YACZrD,MAAM,CAAE,oFAAmFkD,UAAW,WAAU,CAAC;YACjH,OAAOW,OAAO;UAClB;UACA0C,MAAM,CAAC,CAAC,CAAC,GAAGnG,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC,GAAG,IAAI;UAC5CA,SAAS,EAAE;UACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;YACzB,OAAO1B,OAAO;UAClB;UACA0C,MAAM,CAAC,CAAC,CAAC,GAAGnG,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC,GAAG,IAAI;UAC5CA,SAAS,EAAE;UACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;YACzB,OAAO1B,OAAO;UAClB;UACA0C,MAAM,CAAC,CAAC,CAAC,GAAID,IAAI,GAAG,IAAK;UACzBjD,IAAI,GAAGvD,UAAU,CAAC4G,uCAAuC,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC;UACpE,IAAIlD,IAAI,IAAI,CAAC,CAAC,EAAE;YACZrD,MAAM,CAAE,4HAA2HuG,MAAM,CAAC,CAAC,CAAC,GAAG,IAAK,IAAIA,MAAM,CAAC,CAAC,CAAC,GAAG,IAAM,IAAIA,MAAM,CAAC,CAAC,CAAC,GAAG,IAAM,EAAC,CAAC;YAClM,OAAO1C,OAAO;UAClB;UACA2C,QAAQ,GAAGpG,GAAG,CAACkE,UAAU,CAACjB,IAAI,CAAC;UAC/B,MAAM+C,OAAO,GAAG,IAAI,CAACtB,iCAAiC,CAAC0B,QAAQ,EAAET,UAAU,EAAEd,WAAW,EAAEC,UAAU,CAAC;UACrGrB,OAAO,CAACd,MAAM,CAAC3B,YAAY,GAAGgF,OAAO,CAAC,CAAC,CAAC;UACxCvC,OAAO,CAACd,MAAM,CAACS,UAAU,GAAG4C,OAAO,CAAC,CAAC,CAAC;UACtC,MAAMC,OAAO,GAAG,IAAI,CAACvB,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAEb,WAAW,EAAEC,UAAU,CAAC;UACtGrB,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGiF,OAAO,CAAC,CAAC,CAAC;UACxCxC,OAAO,CAAC1C,MAAM,CAACqC,UAAU,GAAG6C,OAAO,CAAC,CAAC,CAAC;QAC1C;QACA;MACJ,KAAK3G,UAAU,CAACkF,EAAE;MAClB;QACI,MAAM9C,MAAM,GAAG,IAAI,CAACgD,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAEb,WAAW,EAAEC,UAAU,CAAC;QACrGrB,OAAO,CAAC1C,MAAM,CAACC,YAAY,GAAGU,MAAM,CAAC,CAAC,CAAC;QACvC+B,OAAO,CAAC1C,MAAM,CAACqC,UAAU,GAAG1B,MAAM,CAAC,CAAC,CAAC;QACrC;IAAM;IAEd,OAAO+B,OAAO;EAClB;EACA,OAAOf,kBAAkB,CAAC6D,KAAK,EAAE;IAC7B,IAAIC,MAAM;IACV,IAAIC,eAAe;IACnB,IAAIzD,OAAO;IACX,IAAIC,IAAI;IACR,IAAIyD,QAAQ;IACZA,QAAQ,GAAGzG,UAAU,CAACyD,eAAe,EAAE;IACvCT,IAAI,GAAGlD,kBAAkB,CAAC4G,YAAY,GAAIJ,KAAK,GAAG,CAAE;IACpD,IAAItD,IAAI,IAAIjD,GAAG,CAAC4G,IAAI,EAAE;MAClBF,QAAQ,CAAC1F,YAAY,GAAGxB,aAAa,CAACqH,oBAAoB;MAC1D,OAAOH,QAAQ;IACnB;IACAzD,IAAI,GAAGvD,UAAU,CAAC4G,uCAAuC,CAACrD,IAAI,CAAC;IAC/D,IAAIA,IAAI,IAAI,CAAC,CAAC,EAAE;MACZrD,MAAM,CAAE,+EAA8E,CAAC;MACvF8G,QAAQ,CAAC1F,YAAY,GAAGxB,aAAa,CAACqH,oBAAoB;MAC1D,OAAOH,QAAQ;IACnB;IACA,IAAIzD,IAAI,IAAIjD,GAAG,CAAC4G,IAAI,EAAE;MAClBF,QAAQ,CAAC1F,YAAY,GAAGxB,aAAa,CAACqH,oBAAoB;MAC1D,OAAOH,QAAQ;IACnB;IACAD,eAAe,GAAGzD,OAAO,GAAGC,IAAI;IAChCyD,QAAQ,GAAG,IAAI,CAACI,2BAA2B,CAAC7D,IAAI,EAAEyD,QAAQ,CAAC;IAC3DA,QAAQ,CAACvD,UAAU,GAAIH,OAAO,GAAGyD,eAAgB;IACjD,OAAOC,QAAQ;EACnB;EACA,OAAOhD,eAAe,GAAG;IACrB,IAAIqD,KAAK,GAAG,IAAI3G,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC5C,IAAImD,MAAM,GAAG;MACTrD,UAAU,EAAE,CAAC;MACbC,UAAU,EAAE2D,KAAK;MACjBzD,aAAa,EAAEyD,KAAK;MACpBxD,cAAc,EAAEwD,KAAK;MACrBvD,aAAa,EAAEuD,KAAK;MACpB/F,YAAY,EAAExB,aAAa,CAACyB;IAChC,CAAC;IACD,OAAOuF,MAAM;EACjB;EACA,OAAOM,2BAA2B,CAAChD,MAAM,EAAE0C,MAAM,EAAE;IAC/C,IAAIC,eAAe,GAAG3C,MAAM;IAC5B,IAAIc,IAAI,GAAG,IAAIxE,UAAU,CAACoG,MAAM,CAACpD,UAAU,CAAC;IAC5C,IAAI4D,OAAO,GAAGR,MAAM,CAAClD,aAAa;IAClC,IAAI2D,QAAQ,GAAGT,MAAM,CAACjD,cAAc;IACpC,IAAI2D,OAAO,GAAGV,MAAM,CAAChD,aAAa;IAClC,IAAIS,EAAE,GAAGjE,GAAG,CAACkE,UAAU,CAACJ,MAAM,CAAC;IAC/BA,MAAM,EAAE;IACR,IAAKA,MAAM,IAAK9D,GAAG,CAACmF,MAAM,EAAE;MACxBqB,MAAM,CAACxF,YAAY,GAAGxB,aAAa,CAAC4F,eAAe;MACnD,OAAOoB,MAAM;IACjB;IACA5G,MAAM,CAAE,QAAOD,KAAK,CAACsE,EAAE,CAAE,EAAC,CAAC;IAC3B,QAAQA,EAAE,GAAG,IAAI;MACb,KAAK,IAAI;QACLW,IAAI,GAAG,IAAI,CAACuC,SAAS,CAACrD,MAAM,CAAC;QAC7B0C,MAAM,CAACpD,UAAU,GAAGwB,IAAI;QACxB,OAAO4B,MAAM;MACjB,KAAK,IAAI;QACL5B,IAAI,GAAG,IAAI,CAACwC,SAAS,CAACtD,MAAM,CAAC;QAC7B0C,MAAM,CAACpD,UAAU,GAAGwB,IAAI;QACxB,OAAO4B,MAAM;MACjB,KAAK,IAAI;QACL5B,IAAI,GAAG,IAAI,CAACyC,SAAS,CAACvD,MAAM,CAAC;QAC7B0C,MAAM,CAACpD,UAAU,GAAGwB,IAAI;QACxB,OAAO4B,MAAM;MACjB,KAAK,IAAI;QACL5B,IAAI,GAAG,IAAI,CAAC0C,SAAS,CAACxD,MAAM,CAAC;QAC7B0C,MAAM,CAACxF,YAAY,GAAGxB,aAAa,CAAC+H,aAAa;QACjD,OAAOf,MAAM;MACjB,KAAK,IAAI;QACL5B,IAAI,GAAG,IAAI,CAAC4C,SAAS,CAAC1D,MAAM,CAAC;QAC7B0C,MAAM,CAACpD,UAAU,GAAGwB,IAAI;QACxB,OAAO4B,MAAM;MACjB,KAAK,IAAI;QACL5B,IAAI,GAAG,IAAI,CAAC6C,SAAS,CAAC3D,MAAM,CAAC;QAC7B0C,MAAM,CAACpD,UAAU,GAAGwB,IAAI;QACxB,OAAO4B,MAAM;MACjB,KAAK,IAAI;QACL,MAAMkB,SAAS,GAAG,IAAI,CAACC,SAAS,CAAC7D,MAAM,CAAC;QACxC0C,MAAM,CAACpD,UAAU,GAAGsE,SAAS,CAAC,CAAC,CAAC;QAChClB,MAAM,CAAClD,aAAa,GAAGoE,SAAS,CAAC,CAAC,CAAC;QACnClB,MAAM,CAACjD,cAAc,GAAGmE,SAAS,CAAC,CAAC,CAAC;QACpClB,MAAM,CAACjD,cAAc,GAAGmE,SAAS,CAAC,CAAC,CAAC;QACpC,OAAOlB,MAAM;MACjB,KAAK,IAAI;QACL,MAAMoB,SAAS,GAAG,IAAI,CAACC,SAAS,CAAC/D,MAAM,CAAC;QACxC0C,MAAM,CAACpD,UAAU,GAAGwE,SAAS,CAAC,CAAC,CAAC;QAChCpB,MAAM,CAAClD,aAAa,GAAGsE,SAAS,CAAC,CAAC,CAAC;QACnCpB,MAAM,CAACjD,cAAc,GAAGqE,SAAS,CAAC,CAAC,CAAC;QACpCpB,MAAM,CAACjD,cAAc,GAAGqE,SAAS,CAAC,CAAC,CAAC;QACpC,OAAOpB,MAAM;MACjB,KAAK,IAAI;QACL,MAAMsB,SAAS,GAAG,IAAI,CAACC,SAAS,CAACjE,MAAM,CAAC;QACxC0C,MAAM,CAACpD,UAAU,GAAG0E,SAAS,CAAC,CAAC,CAAC;QAChCtB,MAAM,CAAClD,aAAa,GAAGwE,SAAS,CAAC,CAAC,CAAC;QACnC,OAAOtB,MAAM;QACb;MACJ,KAAK,IAAI;QACL,MAAMwB,SAAS,GAAG,IAAI,CAACC,SAAS,CAACnE,MAAM,CAAC;QACxC0C,MAAM,CAACpD,UAAU,GAAG4E,SAAS,CAAC,CAAC,CAAC;QAChCxB,MAAM,CAAClD,aAAa,GAAG0E,SAAS,CAAC,CAAC,CAAC;QACnC,OAAOxB,MAAM;MACjB,KAAK,IAAI;QACL,MAAM0B,SAAS,GAAG,IAAI,CAACC,SAAS,CAACrE,MAAM,CAAC;QACxC0C,MAAM,CAACpD,UAAU,GAAG8E,SAAS,CAAC,CAAC,CAAC;QAChC1B,MAAM,CAAClD,aAAa,GAAG4E,SAAS,CAAC,CAAC,CAAC;QACnC,OAAO1B,MAAM;MACjB,KAAK,IAAI;QACL,MAAM4B,SAAS,GAAG,IAAI,CAACC,SAAS,CAACvE,MAAM,CAAC;QACxC0C,MAAM,CAACpD,UAAU,GAAGgF,SAAS,CAAC,CAAC,CAAC;QAChC5B,MAAM,CAAClD,aAAa,GAAG8E,SAAS,CAAC,CAAC,CAAC;QACnC,OAAO5B,MAAM;MACjB;QACI5G,MAAM,CAAE,sBAAqBqE,EAAG,EAAC,CAAC;QAClCuC,MAAM,CAACpD,UAAU,GAAGwB,IAAI;QACxB4B,MAAM,CAACxF,YAAY,GAAGxB,aAAa,CAAC8I,OAAO;QAC3C9B,MAAM,CAACrD,UAAU,GAAGsD,eAAe,GAAG3C,MAAM;QAC5C,OAAO0C,MAAM;IAAC;IAEtB,IAAK1C,MAAM,IAAK9D,GAAG,CAACmF,MAAM,EAAE;MACxBqB,MAAM,CAACxF,YAAY,GAAGxB,aAAa,CAAC4F,eAAe;MACnD,OAAOoB,MAAM;IACjB;IACAA,MAAM,CAACxF,YAAY,GAAGxB,aAAa,CAACyB,KAAK;IACzC,OAAOuF,MAAM;EACjB;EACA,OAAOW,SAAS,CAACrD,MAAM,EAAE;IACrB,IAAIc,IAAI,GAAG,IAAIxE,UAAU,EAAE;IAC3B,IAAI4E,CAAC;IACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvF,GAAG,CAAC4D,YAAY,EAAE2B,CAAC,EAAE,EAAE;MACnCJ,IAAI,CAACI,CAAC,CAAC,GAAGhF,GAAG,CAACkE,UAAU,CAACJ,MAAM,GAAGkB,CAAC,CAAC;MACpC,IAAIlB,MAAM,GAAGkB,CAAC,IAAIhF,GAAG,CAACmF,MAAM,EAAE;QAC1B,OAAOP,IAAI;MACf;IACJ;IACA,OAAOA,IAAI;EACf;EACA,OAAOwC,SAAS,CAACtD,MAAM,EAAE;IACrB,OAAO,IAAI,CAACyE,aAAa,CAACzE,MAAM,EAAEzE,UAAU,CAACmJ,OAAO,CAAC;EACzD;EACA,OAAOnB,SAAS,CAACvD,MAAM,EAAE;IACrB,OAAO,IAAI,CAACyE,aAAa,CAACzE,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAOiD,aAAa,CAAC5D,SAAS,EAAE8D,IAAI,EAAE;IAClC,IAAIvD,OAAO,GAAG,CAAC;IACf,IAAIN,IAAI,GAAG,IAAIxE,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC3C,IAAIY,EAAE;IACN,IAAIyE,eAAe;IACnB,IAAI3D,YAAY;IAChB2D,eAAe,GAAG1I,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IAC3CA,SAAS,EAAE;IACX,IAAKA,SAAS,IAAK3E,GAAG,CAACmF,MAAM,EAAE;MAC3B,OAAOP,IAAI;IACf;IACAG,YAAY,GAAG,CAAC;IAChBG,OAAO,GAAG,CAAC;IACX,GAAG;MACCjB,EAAE,GAAGjE,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;MAC9BA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAOP,IAAI;MACf;MACA,IAAIX,EAAE,IAAIyE,eAAe,EAAE;QACvB,IAAIC,MAAM,GAAG3I,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,IAAIgE,MAAM,GAAG5I,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,GAAG;UACC,MAAMlD,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE0D,MAAM,EAAEH,IAAI,CAAC;UACvFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;QAC5B,CAAC,QAAS,EAAEiH,MAAM,IAAM5D,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC5D,CAAC,MACI;QACD,MAAM3B,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEwE,IAAI,CAAC;QACnFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;QACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;QAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;MAC5B;IACJ,CAAC,QAAQqD,YAAY,GAAGtF,GAAG,CAAC4D,YAAY;IACxC,OAAOuB,IAAI;EACf;EACA,OAAO0C,SAAS,CAACxD,MAAM,EAAE;IACrB,OAAO,IAAI1D,UAAU,EAAE;EAC3B;EACA,OAAOoH,SAAS,CAAC1D,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC+E,aAAa,CAAC/E,MAAM,EAAEzE,UAAU,CAACmJ,OAAO,CAAC;EACzD;EACA,OAAOf,SAAS,CAAC3D,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC+E,aAAa,CAAC/E,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAOuD,aAAa,CAAClE,SAAS,EAAE8D,IAAI,EAAE;IAClC,IAAI7D,IAAI,GAAG,IAAIxE,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC3C,IAAI6B,OAAO,GAAG,CAAC;IACf,IAAI4D,MAAM,GAAG;MACTC,QAAQ,EAAE,IAAI;MACdC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrCN,eAAe,EAAE1I,GAAG,CAACkE,UAAU,CAACS,SAAS;IAC7C,CAAC;IACD,IAAIV,EAAE;IACN,IAAIe,CAAC;IACL,IAAID,YAAY;IAChBA,YAAY,GAAG,CAAC;IAChBJ,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAOP,IAAI;IACf;IACA,KAAKI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACpB8D,MAAM,CAACE,WAAW,CAAChE,CAAC,CAAC,GAAGhF,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;MACjDA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAOP,IAAI;MACf;IACJ;IACA,GAAG;MACC,MAAMlD,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;MAC9DmE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;MAClBuC,EAAE,GAAGvC,MAAM,CAAC,CAAC,CAAC;MACdiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;MACrB,IAAIiD,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAOP,IAAI;MACf;MACA,IAAIX,EAAE,IAAI6E,MAAM,CAACJ,eAAe,EAAE;QAC9B,MAAM1C,OAAO,GAAG/F,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;QAC/DmE,MAAM,GAAG9C,OAAO,CAAC,CAAC,CAAC;QACnB,IAAI2C,MAAM,GAAG3C,OAAO,CAAC,CAAC,CAAC;QACvBrB,SAAS,GAAGqB,OAAO,CAAC,CAAC,CAAC;QACtB,IAAIrB,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,MAAMsE,OAAO,GAAGjJ,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;QAC/DmE,MAAM,GAAGI,OAAO,CAAC,CAAC,CAAC;QACnB,IAAIN,MAAM,GAAGM,OAAO,CAAC,CAAC,CAAC;QACvBvE,SAAS,GAAGuE,OAAO,CAAC,CAAC,CAAC;QACtB,IAAIvE,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,GAAG;UACC,MAAMlD,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE0D,MAAM,EAAEH,IAAI,CAAC;UACvFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;QAC5B,CAAC,QAAS,EAAEiH,MAAM,IAAM5D,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC5D,CAAC,MACI;QACD,MAAM3B,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEwE,IAAI,CAAC;QACnFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;QACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;QAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;MAC5B;IACJ,CAAC,QAAQqD,YAAY,GAAGtF,GAAG,CAAC4D,YAAY;IACxC,IAAIyF,MAAM,CAACC,QAAQ,IAAI,IAAI,EAAE;MACzBpE,SAAS,EAAE;IACf;IACA,OAAOC,IAAI;EACf;EACA,OAAO+C,SAAS,CAAC7D,MAAM,EAAE;IACrB,OAAO,IAAI,CAACqF,aAAa,CAACrF,MAAM,EAAEzE,UAAU,CAACmJ,OAAO,CAAC;EACzD;EACA,OAAOX,SAAS,CAAC/D,MAAM,EAAE;IACrB,OAAO,IAAI,CAACqF,aAAa,CAACrF,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAO6D,aAAa,CAACxE,SAAS,EAAE8D,IAAI,EAAE;IAClC,IAAI7D,IAAI,GAAG,IAAIxE,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC3C,IAAI4D,QAAQ,GAAG,IAAI7G,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC/C,IAAI6D,OAAO,GAAG,IAAI9G,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC9C,IAAI6B,OAAO,GAAG,CAAC;IACf,IAAIkE,WAAW,GAAG,CAAC;IACnB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIpF,EAAE;IACN,IAAIyE,eAAe;IACnB,IAAI3D,YAAY;IAChB,IAAIuE,eAAe;IACnB,IAAIC,cAAc;IAClBb,eAAe,GAAG1I,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IAC3CA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO,CAACP,IAAI,EAAEqC,QAAQ,EAAEC,OAAO,CAAC;IACpC;IACAnC,YAAY,GAAGuE,eAAe,GAAGC,cAAc,GAAG,CAAC;IACnD,GAAG;MACCtF,EAAE,GAAGjE,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;MAC9BA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEqC,QAAQ,EAAEC,OAAO,CAAC;MACpC;MACA,IAAIjD,EAAE,IAAIyE,eAAe,EAAE;QACvB,IAAIC,MAAM,GAAG3I,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzB,OAAO,CAACP,IAAI,EAAEqC,QAAQ,EAAEC,OAAO,CAAC;QACpC;QACA,IAAI0B,MAAM,GAAG5I,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzB,OAAO,CAACP,IAAI,EAAEqC,QAAQ,EAAEC,OAAO,CAAC;QACpC;QACA,GAAG;UACC,MAAMxF,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAEuD,IAAI,CAAC;UACrFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAM8H,cAAc,GAAGvJ,UAAU,CAACoF,kBAAkB,CAACiE,eAAe,EAAErC,QAAQ,EAAEmC,WAAW,EAAE,IAAI,EAAEX,IAAI,CAAC;UACxGW,WAAW,GAAGI,cAAc,CAAC,CAAC,CAAC;UAC/BvC,QAAQ,GAAGuC,cAAc,CAAC,CAAC,CAAC;UAC5BF,eAAe,GAAGE,cAAc,CAAC,CAAC,CAAC;UACnC,MAAMC,aAAa,GAAGxJ,UAAU,CAACoF,kBAAkB,CAACkE,cAAc,EAAErC,OAAO,EAAEmC,UAAU,EAAET,MAAM,EAAEH,IAAI,CAAC;UACtGY,UAAU,GAAGI,aAAa,CAAC,CAAC,CAAC;UAC7BvC,OAAO,GAAGuC,aAAa,CAAC,CAAC,CAAC;UAC1BF,cAAc,GAAGE,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAEd,MAAM,IAAM5D,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC5D,CAAC,MACI;QACD,MAAM3B,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEwE,IAAI,CAAC;QACnFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;QACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;QAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;QACxB,MAAM8H,cAAc,GAAGvJ,UAAU,CAACoF,kBAAkB,CAACiE,eAAe,EAAErC,QAAQ,EAAEmC,WAAW,EAAE,IAAI,EAAEX,IAAI,CAAC;QACxGW,WAAW,GAAGI,cAAc,CAAC,CAAC,CAAC;QAC/BvC,QAAQ,GAAGuC,cAAc,CAAC,CAAC,CAAC;QAC5BF,eAAe,GAAGE,cAAc,CAAC,CAAC,CAAC;QACnC,MAAMC,aAAa,GAAGxJ,UAAU,CAACoF,kBAAkB,CAACkE,cAAc,EAAErC,OAAO,EAAEmC,UAAU,EAAE,IAAI,EAAEZ,IAAI,CAAC;QACpGY,UAAU,GAAGI,aAAa,CAAC,CAAC,CAAC;QAC7BvC,OAAO,GAAGuC,aAAa,CAAC,CAAC,CAAC;QAC1BF,cAAc,GAAGE,aAAa,CAAC,CAAC,CAAC;MACrC;IACJ,CAAC,QAAQ1E,YAAY,GAAGtF,GAAG,CAAC4D,YAAY;IACxC,OAAO,CAACuB,IAAI,EAAEqC,QAAQ,EAAEC,OAAO,CAAC;EACpC;EACA,OAAOa,SAAS,CAACjE,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC4F,aAAa,CAAC5F,MAAM,EAAEzE,UAAU,CAACmJ,OAAO,CAAC;EACzD;EACA,OAAOP,SAAS,CAACnE,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC4F,aAAa,CAAC5F,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAOoE,aAAa,CAAC/E,SAAS,EAAE8D,IAAI,EAAE;IAClC,IAAIvD,OAAO,GAAG,CAAC;IACf,IAAIN,IAAI,GAAG,IAAIxE,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC3C,IAAIsG,UAAU,GAAG,CAAC;IAClB,IAAI3C,OAAO,GAAG,IAAI5G,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC9C,IAAI7C,KAAK;IACT,IAAIoJ,OAAO;IACX,IAAI7E,YAAY;IAChB,IAAI8E,cAAc;IAClB,IAAIC,eAAe,GAAG,IAAI;IAC1B,SAASC,WAAW,GAAG;MACnBvJ,KAAK,GAAGR,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;MACjCA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;MAC1B;MACA,IAAIxG,KAAK,EAAE;QACP,GAAG;UACC,MAAMkB,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAEuD,IAAI,CAAC;UACrFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMsI,aAAa,GAAG/J,UAAU,CAACoF,kBAAkB,CAACwE,cAAc,EAAE7C,OAAO,EAAE2C,UAAU,EAAE,IAAI,EAAElB,IAAI,CAAC;UACpGkB,UAAU,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC7BhD,OAAO,GAAGgD,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAExJ,KAAK,IAAMuE,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC3D;MACA,IAAI0B,YAAY,IAAItF,GAAG,CAAC4D,YAAY,EAAE;QAClCyG,eAAe,GAAG,KAAK;MAC3B;IACJ;IACAtJ,KAAK,GAAGmE,SAAS;IACjBnE,KAAK,GAAGR,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;IACjCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;IAC1B;IACAjC,YAAY,GAAG8E,cAAc,GAAG,CAAC;IACjC,IAAI,CAACrJ,KAAK,EAAE;MACRuJ,WAAW,EAAE;IACjB;IACA,OAAOD,eAAe,EAAE;MACpBtJ,KAAK,GAAGR,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;MACjCA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;MAC1B;MACA,IAAIxG,KAAK,EAAE;QACP,GAAG;UACCoJ,OAAO,GAAG5J,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;UACnCA,SAAS,EAAE;UACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;YACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;UAC1B;UACA,MAAMtF,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE0E,OAAO,EAAEnB,IAAI,CAAC;UACxFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMsI,aAAa,GAAG/J,UAAU,CAACoF,kBAAkB,CAACwE,cAAc,EAAE7C,OAAO,EAAE2C,UAAU,EAAE,IAAI,EAAElB,IAAI,CAAC;UACpGkB,UAAU,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC7BhD,OAAO,GAAGgD,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAExJ,KAAK,IAAMuE,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC3D;MACA,IAAI0B,YAAY,IAAItF,GAAG,CAAC4D,YAAY,EAAE;QAClCyG,eAAe,GAAG,KAAK;MAC3B;MACA,IAAIA,eAAe,EAAE;QACjBC,WAAW,EAAE;MACjB;IACJ;IACA,OAAO,CAACnF,IAAI,EAAEoC,OAAO,CAAC;EAC1B;EACA,OAAOmB,SAAS,CAACrE,MAAM,EAAE;IACrB,OAAO7D,UAAU,CAACgK,aAAa,CAACnG,MAAM,EAAEzE,UAAU,CAACmJ,OAAO,CAAC;EAC/D;EACA,OAAOH,SAAS,CAACvE,MAAM,EAAE;IACrB,OAAO,IAAI,CAACmG,aAAa,CAACnG,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAO2E,aAAa,CAACtF,SAAS,EAAE8D,IAAI,EAAE;IAClC,IAAIvD,OAAO,GAAG,CAAC;IACf,IAAIN,IAAI,GAAG,IAAIxE,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC3C,IAAIsG,UAAU,GAAG,CAAC;IAClB,IAAI3C,OAAO,GAAG,IAAI5G,UAAU,CAACX,GAAG,CAAC4D,YAAY,CAAC;IAC9C,IAAIyF,MAAM,GAAG;MACTC,QAAQ,EAAE,IAAI;MACdC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrCN,eAAe,EAAE;IACrB,CAAC;IACD,IAAIlI,KAAK;IACT,IAAIwE,CAAC;IACL,IAAID,YAAY;IAChB,IAAI8E,cAAc;IAClB,IAAIC,eAAe,GAAG,IAAI;IAC1BhB,MAAM,CAACC,QAAQ,GAAG,IAAI;IACtBhE,YAAY,GAAG8E,cAAc,GAAG,CAAC;IACjC,SAASK,SAAS,GAAG;MACjB,MAAMxI,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;MAC9DmE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;MAClBlB,KAAK,GAAGkB,MAAM,CAAC,CAAC,CAAC;MACjBiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;MACrB,IAAIiD,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;MAC1B;MACA,IAAIxG,KAAK,EAAE;QACP,GAAG;UACC,MAAMkB,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAEuD,IAAI,CAAC;UACrFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMsI,aAAa,GAAG/J,UAAU,CAACoF,kBAAkB,CAACwE,cAAc,EAAE7C,OAAO,EAAE2C,UAAU,EAAE,IAAI,EAAElB,IAAI,CAAC;UACpGkB,UAAU,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC7BhD,OAAO,GAAGgD,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAExJ,KAAK,IAAMuE,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC3D;MACA,IAAI0B,YAAY,IAAItF,GAAG,CAAC4D,YAAY,EAAE;QAClCyG,eAAe,GAAG,KAAK;QACvB,OAAO,CAAClF,IAAI,EAAEoC,OAAO,CAAC;MAC1B;MACA,OAAO,CAACpC,IAAI,EAAEoC,OAAO,CAAC;IAC1B;IACA,KAAKhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACpB8D,MAAM,CAACE,WAAW,CAAChE,CAAC,CAAC,GAAGhF,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC;MACjDA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;MAC1B;IACJ;IACA,MAAMtF,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;IAC9DmE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;IAClBlB,KAAK,GAAGkB,MAAM,CAAC,CAAC,CAAC;IACjBiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;IACrB,IAAIiD,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;IAC1B;IACA,IAAI,CAACxG,KAAK,EAAE;MACR0J,SAAS,EAAE;IACf;IACA,OAAOJ,eAAe,EAAE;MACpB,MAAMpI,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;MAC9DmE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;MAClBlB,KAAK,GAAGkB,MAAM,CAAC,CAAC,CAAC;MACjBiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;MACrB,IAAIiD,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;MAC1B;MACA,IAAIxG,KAAK,EAAE;QACP,GAAG;UACC,MAAM2J,UAAU,GAAGlK,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,CAAC;UAClEmE,MAAM,GAAGqB,UAAU,CAAC,CAAC,CAAC;UACtB,MAAMC,IAAI,GAAGD,UAAU,CAAC,CAAC,CAAC;UAC1BxF,SAAS,GAAGwF,UAAU,CAAC,CAAC,CAAC;UACzB,MAAMzI,MAAM,GAAGzB,UAAU,CAACoF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEkF,IAAI,EAAE3B,IAAI,CAAC;UACrFvD,OAAO,GAAGxD,MAAM,CAAC,CAAC,CAAC;UACnBkD,IAAI,GAAGlD,MAAM,CAAC,CAAC,CAAC;UAChBqD,YAAY,GAAGrD,MAAM,CAAC,CAAC,CAAC;UACxB,IAAIiD,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;YACzB,OAAO,CAACP,IAAI,EAAEoC,OAAO,CAAC;UAC1B;UACA,MAAMgD,aAAa,GAAG/J,UAAU,CAACoF,kBAAkB,CAACwE,cAAc,EAAE7C,OAAO,EAAE2C,UAAU,EAAE,IAAI,EAAElB,IAAI,CAAC;UACpGkB,UAAU,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC7BhD,OAAO,GAAGgD,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAExJ,KAAK,IAAMuE,YAAY,GAAGtF,GAAG,CAAC4D,YAAa;MAC3D;MACA,IAAI0B,YAAY,IAAItF,GAAG,CAAC4D,YAAY,EAAE;QAClCyG,eAAe,GAAG,KAAK;MAC3B;MACAI,SAAS,EAAE;IACf;IACA,IAAIpB,MAAM,CAACC,QAAQ,IAAI,IAAI,EAAE;MACzBpE,SAAS,EAAE;IACf;IACA,OAAO,CAACC,IAAI,EAAEoC,OAAO,CAAC;EAC1B;EACA,OAAO3B,kBAAkB,CAACgF,eAAe,EAAEzF,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEwE,IAAI,EAAE;IAChE7D,IAAI,CAAC0F,GAAG,CAAC,CAACrG,EAAE,CAAC,EAAEiB,OAAO,CAAC;IACvBmF,eAAe,EAAE;IACjB,IAAKA,eAAe,IAAK5K,GAAG,CAAC4D,YAAY,EAAE;MACvC,OAAO,CAAC6B,OAAO,EAAEN,IAAI,EAAEyF,eAAe,CAAC;IAC3C;IACA,IAAI5B,IAAI,IAAIpJ,UAAU,CAACiG,IAAI,EAAE;MACzBJ,OAAO,EAAE;MACT,OAAO,CAACA,OAAO,EAAEN,IAAI,EAAEyF,eAAe,CAAC;IAC3C;IACA,IAAI,EAAEA,eAAe,GAAI5K,GAAG,CAAC8B,OAAQ,CAAC,EAAE;MACpC2D,OAAO,IAAOzF,GAAG,CAAC0B,OAAO,GAAG,CAAC,IAAK1B,GAAG,CAAC8B,OAAO,GAAG,CAAC,CAAC,IAAM9B,GAAG,CAAC0B,OAAO,GAAG,CAAC,GAAI,CAAC,CAAE;IAClF,CAAC,MACI;MACD+D,OAAO,IAAKzF,GAAG,CAAC0B,OAAO,GAAG,CAAE;IAChC;IACA,OAAO,CAAC+D,OAAO,EAAEN,IAAI,EAAEyF,eAAe,CAAC;EAC3C;EACA,OAAOpB,iBAAiB,CAACH,MAAM,EAAEnE,SAAS,EAAE;IACxC,IAAI4F,YAAY;IAChB,MAAM7I,MAAM,GAAGzB,UAAU,CAACuK,WAAW,CAAC1B,MAAM,EAAEnE,SAAS,CAAC;IACxD,IAAIV,EAAE,GAAGvC,MAAM,CAAC,CAAC,CAAC;IAClBoH,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;IAClBiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;IACrB,IAAIiD,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;MACzBoF,YAAY,GAAG,CAACzB,MAAM,EAAE,IAAI,EAAEnE,SAAS,CAAC;MACxC,OAAO4F,YAAY;IACvB;IACA,IAAIE,SAAS;IACb,IAAIC,WAAW;IACf,IAAI1F,CAAC;IACL,IAAIf,EAAE,EAAE;MACJ,IAAI0G,SAAS,GAAG,CAAC;MACjB,KAAK3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACpB,MAAMtD,MAAM,GAAGzB,UAAU,CAACuK,WAAW,CAAC1B,MAAM,EAAEnE,SAAS,CAAC;QACxDmE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;QAClBiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;QACrB,IAAIA,MAAM,CAAC,CAAC,CAAC,EAAE;UACXiJ,SAAS,EAAE;QACf,CAAC,MACI;UACD3F,CAAC,GAAG,CAAC;QACT;QACA,IAAIL,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzBoF,YAAY,GAAG,CAACzB,MAAM,EAAE,IAAI,EAAEnE,SAAS,CAAC;UACxC,OAAO4F,YAAY;QACvB;MACJ;MACAG,WAAW,GAAG5B,MAAM,CAACE,WAAW,CAAC2B,SAAS,CAAC;IAC/C,CAAC,MACI;MACDF,SAAS,GAAG,IAAI;MAChBC,WAAW,GAAG,IAAI;MAClB,KAAK1F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACpB,MAAMtD,MAAM,GAAGzB,UAAU,CAACuK,WAAW,CAAC1B,MAAM,EAAEnE,SAAS,CAAC;QACxDmE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;QAClBiD,SAAS,GAAGjD,MAAM,CAAC,CAAC,CAAC;QACrB,IAAIA,MAAM,CAAC,CAAC,CAAC,EAAE;UACXgJ,WAAW,IAAID,SAAS;QAC5B;QACA,IAAI9F,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;UACzBoF,YAAY,GAAG,CAACzB,MAAM,EAAE,IAAI,EAAEnE,SAAS,CAAC;UACxC,OAAO4F,YAAY;QACvB;QACAE,SAAS,KAAK,CAAC;MACnB;IACJ;IACAF,YAAY,GAAG,CAACzB,MAAM,EAAE4B,WAAW,EAAE/F,SAAS,CAAC;IAC/C,OAAQ4F,YAAY;EACxB;EACA,OAAOC,WAAW,CAAC1B,MAAM,EAAEnE,SAAS,EAAE;IAClC,IAAI4F,YAAY;IAChB,IAAItG,EAAE,GAAIjE,GAAG,CAACkE,UAAU,CAACS,SAAS,CAAC,GAAGmE,MAAM,CAACC,QAAS;IACtD,IAAI,EAAED,MAAM,CAACC,QAAQ,KAAK,CAAC,CAAC,EAAE;MAC1BD,MAAM,CAACC,QAAQ,GAAG,IAAI;MACtBpE,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI3E,GAAG,CAACmF,MAAM,EAAE;QACzBoF,YAAY,GAAG,CAAC,IAAI,EAAEzB,MAAM,EAAEnE,SAAS,CAAC;QACxC,OAAO4F,YAAY;MACvB;IACJ;IACAA,YAAY,GAAG,CAACtG,EAAE,EAAE6E,MAAM,EAAEnE,SAAS,CAAC;IACtC,OAAO4F,YAAY;EACvB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}