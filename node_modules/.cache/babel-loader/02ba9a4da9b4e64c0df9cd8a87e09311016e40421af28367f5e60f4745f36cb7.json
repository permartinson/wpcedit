{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-c0434324\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  class: \"dmd-container\",\n  ref: \"container\"\n};\nconst _hoisted_2 = {\n  key: 0,\n  ref: \"dmd\",\n  width: \"1024\",\n  height: \"256\",\n  class: \"dmd\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [$setup.settings.displayStyle != 0 ? (_openBlock(), _createElementBlock(\"canvas\", _hoisted_2, null, 512 /* NEED_PATCH */)) : _createCommentVNode(\"v-if\", true)], 512 /* NEED_PATCH */);\n}","map":{"version":3,"mappings":";;;EACSA,KAAK,EAAC,eAAe;EAACC,GAAG,EAAC;;;;EACYA,GAAG,EAAC,KAAK;EAACC,KAAK,EAAC,MAAM;EAACC,MAAM,EAAC,KAAK;EAACH,KAAK,EAAC;;;uBADrFI,oBAEM,OAFNC,UAEM,GADUC,eAAQ,CAACC,YAAY,uBAAnCH,oBAAkG,UAAlGI,UAAkG","names":["class","ref","width","height","_createElementBlock","_hoisted_1","$setup","displayStyle","_hoisted_2"],"sourceRoot":"","sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/src/components/dmd/MainDmd.vue"],"sourcesContent":["<template>\n    <div class=\"dmd-container\" ref=\"container\">\n      <canvas v-if=\"settings.displayStyle!= 0\" ref=\"dmd\" width=\"1024\" height=\"256\" class=\"dmd\"></canvas>\n    </div> \n</template>\n\n<script>\nimport * as PIXI from 'pixi.js';\nimport {AdvancedBloomFilter} from '@pixi/filter-advanced-bloom';\nimport {AdjustmentFilter} from '@pixi/filter-adjustment';\nimport { storeToRefs } from 'pinia';\nimport store from \"../../stores/store.js\";\nimport { useMainStore } from '../../stores/mainStore.js';\n\nconst MainStore = useMainStore(store);\n\nexport default {\n  name: 'MainDmd',\n  props: {\n    image0: Uint8Array,\n    image1: Uint8Array,\n    index: Number\n  },\n  data() {\n    return {\n        pixiApp: new PIXI.Application({ background: '#0C0C0C', width: 1024+32, height: 256+32 }),\n        doExport: false\n    }\n  },\n  setup() {\n        const { settings } = storeToRefs(MainStore);\n        return {\n            settings\n        }\n    },\n  methods: {\n    drawImage() {\n      if(this.settings.displayStyle == 0) {\n        this.drawPlasmaStyle();\n      } else {\n        this.drawPlain(this.settings.displayStyle);\n      }\n    },\n    drawPlasmaStyle() {\n        const DISPLAY_W = 1024;\n        const DISPLAY_H = 256;\n        const DOT_SIZE = 8;\n        const DISPLAY_MARGIN = 2*DOT_SIZE;\n        const IMAGE_SIZE = 128*32;\n\n        const level0 = this.getDotTeture(0);\n        const level1 = this.getDotTeture(1);\n        const level2 = this.getDotTeture(2);\n        const level3 = this.getDotTeture(3);\n\n        const texture0 = PIXI.Texture.from(level0);\n        const texture1 = PIXI.Texture.from(level1);\n        const texture2 = PIXI.Texture.from(level2);\n        const texture3 = PIXI.Texture.from(level3);\n\n        const dmdDiv = this.$refs.container;\n        dmdDiv.appendChild(this.pixiApp.view);\n        this.pixiApp.view.style.width = \"100%\";\n        const container = new PIXI.Container();\n        this.pixiApp.stage.addChild(container);\n        var graphics = new PIXI.Graphics();\n        graphics.beginFill(0xF0C0C0C);\n\n        // draw a background rectangle. without it, the bloom effect will appear \"cut off\" at the edge of the dmd area\n        graphics.drawRect(0, 0, DISPLAY_W+2*DISPLAY_MARGIN, DISPLAY_H+2*DISPLAY_MARGIN);\n        graphics.zIndex = 1;\n        container.addChild(graphics);\n\n        for (let i = 0; i < IMAGE_SIZE; i++) {\n            let level = 0;\n            level = this.getDotLevel(this.image0,this.image1,i);\n            let dot = new PIXI.Sprite(texture0);\n            if(level==1) {\n                dot = new PIXI.Sprite(texture3);\n            } else if(level==0.6) {\n                dot = new PIXI.Sprite(texture2);\n            } else if(level==0.4) {\n                dot = new PIXI.Sprite(texture1);\n            }\n            dot.width = 8;\n            dot.height = 8;\n            dot.x = (i % 128) * DOT_SIZE + DISPLAY_MARGIN;\n            dot.y = Math.floor(i / 128) * DOT_SIZE + DISPLAY_MARGIN;\n            dot.zIndex = 1000;\n            container.addChild(dot);\n        }\n        // defining the post-effect filters for the display\n        const blur = new PIXI.BlurFilter(1.5);\n        const bloom = new AdvancedBloomFilter({blur:2,brightness:1.2,threshold:0.15,bloomScale:0.3});\n        const bloom2 = new AdvancedBloomFilter({blur:6,brightness:1,threshold:0.25,bloomScale:1.1});\n        const adj = new AdjustmentFilter({blue:0.55,green:0.75,gamma:0.8,saturation:0.85});\n\n        this.pixiApp.stage.filters = [blur, bloom, bloom2, adj];\n    },\n    drawPlain(style) {\n      let color =  \"225, 225, 225\";\n      if(style == 1 || style == 2) {\n        color =  \"220, 133, 33\";\n      }\n      const canvas = this.$refs.dmd;\n      const DOT_SIZE = 8;\n      const IMAGE_SIZE = 128*32;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.beginPath();\n      ctx.rect(0, 0, 1024, 256);\n      ctx.fillStyle = \"rgba(0,0,0,1)\";\n      ctx.fill();\n      for(let i=0; i<IMAGE_SIZE; i++) {\n          const offset = DOT_SIZE/2;\n          const dotX = (i % 128) * DOT_SIZE;\n          const dotY = Math.floor(i / 128) * DOT_SIZE;\n          const dotVal = this.getDotLevel(this.image0,this.image1,i);\n          ctx.beginPath();\n          if(style == 1 || style == 3) {\n            ctx.arc(dotX+offset, dotY+offset, offset*0.9, 0, 2 * Math.PI, false);\n          } else {\n            ctx.rect(dotX, dotY, DOT_SIZE, DOT_SIZE);\n          }\n          ctx.fillStyle = `rgba(${color}, ${dotVal*1})`;\n          ctx.fill();\n      }\n    },\n    getDotLevel(image0Data,image1Data,index) {\n        const width = 128;\n        const col = index % width;\n        const byte = Math.floor(index/8);\n        const bitPos = (col % 8);\n        // get the values of the bits of this pixel index\n        const image0Bit =  ( image0Data[byte] & 0xFF ) >>(bitPos) & 0x01;\n        const image1Bit =  ( image1Data[byte] & 0xFF ) >>(bitPos) & 0x01;\n        // if both planes are 1, the brightness is 100%\n        let level = image0Bit * 0.6 + image1Bit * 0.4;\n        return level;\n    },\n    getDotTeture(level) {\n        switch(level){\n            case 1: \n                return require('@/assets/graphics/dmd-sprites/plasma/1.svg');\n            case 2: \n                return require('@/assets/graphics/dmd-sprites/plasma/2.svg');\n            case 3: \n                return require('@/assets/graphics/dmd-sprites/plasma/3.svg');\n            default:\n                return require('@/assets/graphics/dmd-sprites/plasma/0.svg');\n        }\n    },\n    downloadPng() {\n      this.pixiApp.render();\n      const promise = this.pixiApp.renderer.plugins.extract.base64();\n        promise.then(\n          (image) => {\n            let link = document.createElement(\"a\");\n            link.href = image;\n            let filename = \"plane.png\"\n            if(this.index) {\n              filename = \"plane\"+this.index+\".png\";\n            }\n            link.download = filename;\n            link.style.display = \"none\";\n            document.body.appendChild(link);\n            link.click();\n            link.parentNode.removeChild(link);\n          }\n        )\n    }\n  },\n  mounted() {\n    this.drawImage();\n  },\n  updated() {\n    this.drawImage();\n  },\n  beforeUpdate() {\n  },\n  beforeUnmount() {\n    this.pixiApp.destroy();\n  }\n}\n\n</script>\n\n<style scoped>\n\n.dmd {\n   width: 100%;\n}\n\n.dmd-container canvas {\n}\n</style>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}