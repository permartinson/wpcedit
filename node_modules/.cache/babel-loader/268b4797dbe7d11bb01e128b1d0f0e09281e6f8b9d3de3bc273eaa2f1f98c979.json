{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Texture, BaseTexture, utils, Rectangle } from '@pixi/core';\nconst _Spritesheet = class {\n  constructor(texture, data, resolutionFilename = null) {\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  _updateResolution(resolutionFilename = null) {\n    const {\n      scale\n    } = this.data.meta;\n    let resolution = utils.getResolutionOfUrl(resolutionFilename, null);\n    if (resolution === null) {\n      resolution = parseFloat(scale ?? \"1\");\n    }\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n    return resolution;\n  }\n  parse() {\n    return new Promise(resolve => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n        Texture.addToCache(this.textures[i], i);\n      }\n      frameIndex++;\n    }\n  }\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.baseTexture.destroy();\n    }\n    this._texture = null;\n    this.baseTexture = null;\n    this.linkedSheets = [];\n  }\n};\nlet Spritesheet = _Spritesheet;\nSpritesheet.BATCH_SIZE = 1e3;\nexport { Spritesheet };","map":{"version":3,"mappings":"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","names":["_Spritesheet","constructor","data","linkedSheets","texture","baseTexture","BaseTexture","_texture","textures","animations","resolution","resolutionFilename","resource","url","_frameKeys","keys","_frames","_batchIndex","_callback","_updateResolution","scale","getResolutionOfUrl","setResolution","parse","Promise","resolve","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","rect","frame","trim","trimmed","sourceSize","orig","Rectangle","floor","Math","h","rotated","y","w","spriteSourceSize","x","Texture","anchor","addToCache","i","animName","push","frameName","callback","setTimeout","destroy","destroyBase","Spritesheet"],"sources":["../src/Spritesheet.ts"],"sourcesContent":["import { BaseTexture, Rectangle, Texture, utils } from '@pixi/core';\n\nimport type { ImageResource, IPointData } from '@pixi/core';\n\n/** Represents the JSON data for a spritesheet atlas. */\nexport interface ISpritesheetFrameData\n{\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    trimmed?: boolean;\n    rotated?: boolean;\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    spriteSourceSize?: {\n        x: number;\n        y: number;\n    };\n    anchor?: IPointData;\n}\n\n/** Atlas format. */\nexport interface ISpritesheetData\n{\n    frames: utils.Dict<ISpritesheetFrameData>;\n    animations?: utils.Dict<string[]>;\n    meta: {\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /** The maximum number of Textures to build per process. */\n    static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet[] = [];\n\n    /** Reference to ths source texture. */\n    public baseTexture: BaseTexture;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: utils.Dict<Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: utils.Dict<Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: ISpritesheetData;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: utils.Dict<ISpritesheetFrameData>;\n\n    /** Collection of frame names. */\n    private _frameKeys: string[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: utils.Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     * @param resolutionFilename - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(texture: BaseTexture | Texture, data: ISpritesheetData, resolutionFilename: string = null)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n\n        const resource = this.baseTexture.resource as ImageResource;\n\n        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     * @param resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @returns Resolution to use for spritesheet.\n     */\n    private _updateResolution(resolutionFilename: string = null): number\n    {\n        const { scale } = this.data.meta;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = utils.getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = parseFloat(scale ?? '1');\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     * @method PIXI.Spritesheet#parse\n     */\n    public parse(): Promise<utils.Dict<Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.baseTexture.destroy();\n        }\n        this._texture = null;\n        this.baseTexture = null;\n        this.linkedSheets = [];\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}