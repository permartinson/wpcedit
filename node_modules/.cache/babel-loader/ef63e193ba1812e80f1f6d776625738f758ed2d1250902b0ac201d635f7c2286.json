{"ast":null,"code":"import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n  constructor() {\n    this.PreviousPlaneDataPane0 = new Uint8Array();\n    this.PreviousPlaneDataPane1 = new Uint8Array();\n  }\n  init() {}\n  static decodeNextIndex(count, dataType) {\n    switch (dataType) {\n      case DataTypes.Graphics:\n        while (count--) {\n          {\n            FullFrameImageData.CurrentImageIndex++;\n          }\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageXShift + WPC.DmdCols < VariableSizedImageData.CurrentImageXSize) {\n            VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount * count;\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageYShift + WPC.DmdRows < VariableSizedImageData.CurrentImageYSize) {\n            VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount * count;\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {\n            logStr(`Unexpected error advancing image indexes`);\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex);\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xFF) < (tmpImageIndex & 0xFF)) {\n      pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n      pTableIndex++;\n      pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [0, 0];\n  }\n  static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xFF) > (tmpImageIndex & 0xFF)) {\n      pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex > VariableSizedImageData.minTableIndex) {\n      pTableIndex = pTableIndex - 1;\n      if (DataParser.getLastImageIndex(pImageIndex, pTableIndex) != 0) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [pTableIndex, pImageIndex];\n  }\n  static decodePreviousIndex(count, dataType) {\n    switch (dataType) {\n      case DataTypes.Graphics:\n        while (count-- && FullFrameImageData.CurrentImageIndex) {\n          FullFrameImageData.CurrentImageIndex--;\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageYShift > 0) {\n            VariableSizedImageData.CurrentImageYShift -= WPC.ImageShiftYPixelCount * count;\n            if (VariableSizedImageData.CurrentImageYShift < 0) {\n              VariableSizedImageData.CurrentImageYShift = 0;\n            }\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageXShift > 0) {\n            VariableSizedImageData.CurrentImageXShift -= WPC.ImageShiftXPixelCount * count;\n            if (VariableSizedImageData.CurrentImageXShift < 0) {\n              VariableSizedImageData.CurrentImageXShift = 0;\n            }\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {}\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static decodeFullFrameGraphic(GraphicIndex) {\n    FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n    FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane(GraphicIndex + 1);\n  }\n  static decodeVariableSizedImageData() {\n    const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n    VariableSizedImageData.Planes = result[1];\n    if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n      VariableSizedImageData.CurrentImageXSize = 0;\n      VariableSizedImageData.CurrentImageYSize = 0;\n      VariableSizedImageData.CurrentImageXShift = 0;\n      VariableSizedImageData.CurrentImageYShift = 0;\n    }\n  }\n  static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n    let DataPtr;\n    let Addr;\n    const defaultPlane = {\n      Plane_Status: 0,\n      Plane_Size: 0,\n      Plane_Data: new Uint8Array(WPC.DmdPageBytes),\n      Plane_Skipped: new Uint8Array(WPC.DmdPageBytes),\n      Plane_XorFlags: new Uint8Array(WPC.DmdPageBytes),\n      Plane_XorBits: new Uint8Array(WPC.DmdPageBytes),\n      Plane_Encoding: 255\n    };\n    let pPlanes = {\n      Plane0: defaultPlane,\n      Plane1: defaultPlane\n    };\n    pPlanes.Plane0 = DmdDecoder.decodePlaneInit();\n    pPlanes.Plane1 = DmdDecoder.decodePlaneInit();\n    VariableSizedImageData.CurrentImageXSize = 0;\n    VariableSizedImageData.CurrentImageYSize = 0;\n    Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n    if (Addr == -1) {\n      pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n      pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n      return [-1, pPlanes];\n    }\n    DataPtr = Addr;\n    pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n    let TableHeight;\n    let TableSpacing;\n    let ch = ROM.byteAtAddr(Source);\n    const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n    TableHeight = result[0];\n    TableSpacing = result[1];\n    if (TableHeight == -1) {\n      logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n      return [-1, pPlanes];\n    }\n    if (ch > 0 && ch <= WPC.DmdCols) {\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n    } else {\n      switch (ch) {\n        case ImageCodes.Monochrome:\n        case ImageCodes.BicolorIndirect:\n        case ImageCodes.BicolorDirect:\n        case ImageCodes.FD:\n          break;\n        default:\n          logStr(`Unrecognized Header Byte ${ch}`);\n          break;\n      }\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n    }\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage_Centered(SourcePtr, Dest, ImageHeight, ImageWidth) {\n    let ch;\n    let WriteCounter = 0;\n    let i, j;\n    let DestPtr = 0;\n    if (SourcePtr >= ROM.endPtr) {\n      return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n    }\n    if (VariableSizedImageData.CurrentImageYShift == -1) {\n      VariableSizedImageData.CurrentImageYShift = 0;\n      while (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift < ImageHeight) {\n        VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n      }\n    }\n    if (VariableSizedImageData.CurrentImageXShift == -1) {\n      VariableSizedImageData.CurrentImageXShift = 0;\n      while (WPC.DmdCols + VariableSizedImageData.CurrentImageXShift < ImageWidth) {\n        VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n      }\n    }\n    for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    for (i = 0; i < WPC.DmdRows && WriteCounter < WPC.DmdPageBytes; i++) {\n      if (ImageHeight < WPC.DmdRows) {\n        if (i < (WPC.DmdRows - ImageHeight) / 2 || i >= (WPC.DmdRows - ImageHeight) / 2 + ImageHeight) {\n          for (j = 0; j < WPC.DmdCols / 8; j++) {\n            const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n            DestPtr = result[0];\n            Dest = result[1];\n            WriteCounter = result[2];\n          }\n          continue;\n        }\n      }\n      if (ImageHeight > WPC.DmdRows) {\n        if (i >= ImageHeight - VariableSizedImageData.CurrentImageYShift) {\n          for (j = 0; j < WPC.DmdCols / 8; j++) {\n            const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n            DestPtr = result[0];\n            Dest = result[1];\n            WriteCounter = result[2];\n          }\n          continue;\n        }\n      }\n      if (ImageWidth < WPC.DmdCols) {\n        for (j = 0; j < Math.ceil((WPC.DmdCols - ImageWidth) / 2 / 8); j++) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n      for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n        ch = ROM.byteAtAddr(SourcePtr);\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8) && j < Math.floor((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift + 7) / 8)) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n      if (ImageWidth < WPC.DmdCols) {\n        for (j = Math.ceil((WPC.DmdCols - ImageWidth) / 2 / 8) + (ImageWidth + 7) / 8; j < WPC.DmdCols / 8; j++) {\n          const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift); i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    VariableSizedImageData.CurrentImageXSize = ImageWidth;\n    VariableSizedImageData.CurrentImageYSize = ImageHeight;\n    return [PlaneStatuses.Valid, Dest, SourcePtr];\n  }\n  static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane1.Plane_Size = 0;\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    if (SourcePtr++ >= ROM.endPtr) {\n      logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n      return pPlanes;\n    }\n    const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n    pPlanes.Plane0.Plane_Status = result[0];\n    pPlanes.Plane0.Plane_Data = result[1];\n    SourcePtr = result[2];\n    return pPlanes;\n  }\n  static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let HeaderByte;\n    let VerticalOffset;\n    let HorizontalOffset;\n    let ImageHeight;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane0.Plane_Size = 0;\n    HeaderByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    VerticalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageHeight = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    switch (HeaderByte) {\n      case ImageCodes.BicolorDirect:\n        const result1 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n        pPlanes.Plane1.Plane_Status = result1[0];\n        pPlanes.Plane1.Plane_Data = result1[1];\n        const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result0[0];\n        pPlanes.Plane0.Plane_Data = result0[1];\n        break;\n      case ImageCodes.BicolorIndirect:\n        {\n          let Page;\n          let TmpBuf = [0, 0, 0];\n          let Addr;\n          let pBiColor;\n          const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n          Addr = result[0];\n          Page = result[1];\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n            return pPlanes;\n          }\n          TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[2] = Page & 0xFF;\n          Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xFF} ${TmpBuf[1] & 0xFF} ${TmpBuf[2] & 0xFF}`);\n            return pPlanes;\n          }\n          pBiColor = ROM.byteAtAddr(Addr);\n          const result1 = this.decodeVariableSizedImage_Centered(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n          pPlanes.Plane1.Plane_Status = result1[0];\n          pPlanes.Plane1.Plane_Data = result1[1];\n          const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n          pPlanes.Plane0.Plane_Status = result0[0];\n          pPlanes.Plane0.Plane_Data = result0[1];\n        }\n        break;\n      case ImageCodes.FD:\n      default:\n        const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        break;\n    }\n    return pPlanes;\n  }\n  static getImageEncoding(Index) {\n    const pPlane = this.decodeImageToPlane(Index);\n    return pPlane.Plane_Encoding;\n  }\n  static decodeImageToPlane(Index, SkipDecoding = false) {\n    let pPlane;\n    let OriginalDataPtr;\n    let DataPtr;\n    let Addr;\n    let DMDPlane;\n    DMDPlane = DmdDecoder.decodePlaneInit();\n    Addr = FullFrameImageData.TableAddress + Index * 3;\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n    if (Addr == -1) {\n      logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    OriginalDataPtr = DataPtr = Addr;\n    DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane, SkipDecoding);\n    DMDPlane.Plane_Size = DataPtr - OriginalDataPtr;\n    return DMDPlane;\n  }\n  static decodePlaneInit() {\n    let Plane = new Uint8Array(WPC.DmdPageBytes);\n    let pPlane = {\n      Plane_Size: 0,\n      Plane_Data: Plane,\n      Plane_Skipped: Plane,\n      Plane_XorFlags: Plane,\n      Plane_XorBits: Plane,\n      Plane_Status: PlaneStatuses.Valid,\n      Plane_Encoding: 255\n    };\n    return pPlane;\n  }\n  static decodeFullFrameGraphicImage(Source, pPlane, SkipDecoding) {\n    let OriginalDataPtr = Source;\n    let Dest = new Uint8Array(pPlane.Plane_Data);\n    let ch = ROM.byteAtAddr(Source);\n    pPlane.Plane_Encoding = ch & 0x0F;\n    if (SkipDecoding) {\n      return pPlane;\n    }\n    Source++;\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    logStr(`Type ${toHex(ch)}`);\n    switch (ch & 0x0F) {\n      case 0x00:\n        Dest = this.decode_00(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x01:\n        Dest = this.decode_01(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x02:\n        Dest = this.decode_02(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x03:\n        Dest = this.decode_03(Source);\n        pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n        return pPlane;\n      case 0x04:\n        Dest = this.decode_04(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x05:\n        Dest = this.decode_05(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x06:\n        const result_06 = this.decode_06(Source);\n        pPlane.Plane_Data = result_06[0];\n        pPlane.Plane_Skipped = result_06[1];\n        pPlane.Plane_XorFlags = result_06[2];\n        pPlane.Plane_XorFlags = result_06[3];\n        return pPlane;\n      case 0x07:\n        const result_07 = this.decode_07(Source);\n        pPlane.Plane_Data = result_07[0];\n        pPlane.Plane_Skipped = result_07[1];\n        pPlane.Plane_XorFlags = result_07[2];\n        pPlane.Plane_XorFlags = result_07[3];\n        return pPlane;\n      case 0x08:\n        const result_08 = this.decode_08(Source);\n        pPlane.Plane_Data = result_08[0];\n        pPlane.Plane_Skipped = result_08[1];\n        return pPlane;\n        break;\n      case 0x09:\n        const result_09 = this.decode_09(Source);\n        pPlane.Plane_Data = result_09[0];\n        pPlane.Plane_Skipped = result_09[1];\n        return pPlane;\n      case 0x0A:\n        const result_0A = this.decode_0A(Source);\n        pPlane.Plane_Data = result_0A[0];\n        pPlane.Plane_Skipped = result_0A[1];\n        return pPlane;\n      case 0x0B:\n        const result_0B = this.decode_0B(Source);\n        pPlane.Plane_Data = result_0B[0];\n        pPlane.Plane_Skipped = result_0B[1];\n        return pPlane;\n      default:\n        logStr(`Unknown Image Type ${ch}`);\n        pPlane.Plane_Data = Dest;\n        pPlane.Plane_Status = PlaneStatuses.Unknown;\n        pPlane.Plane_Size = OriginalDataPtr - Source;\n        return pPlane;\n    }\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    pPlane.Plane_Status = PlaneStatuses.Valid;\n    return pPlane;\n  }\n  static decode_00(Source) {\n    let Dest = new Uint8Array();\n    let i;\n    for (i = 0; i < WPC.DmdPageBytes; i++) {\n      Dest[i] = ROM.byteAtAddr(Source + i);\n      if (Source + i >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    return Dest;\n  }\n  static decode_01(Source) {\n    return this.decode_01or02(Source, WriteTypes.Columns);\n  }\n  static decode_02(Source) {\n    return this.decode_01or02(Source, WriteTypes.Rows);\n  }\n  static decode_01or02(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    WriteCounter = 0;\n    DestPtr = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return Dest;\n  }\n  static decode_03(Source) {\n    return new Uint8Array();\n  }\n  static decode_04(Source) {\n    return this.decode_04or05(Source, WriteTypes.Columns);\n  }\n  static decode_05(Source) {\n    return this.decode_04or05(Source, WriteTypes.Rows);\n  }\n  static decode_04or05(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n    };\n    let ch;\n    let i;\n    let WriteCounter;\n    WriteCounter = 0;\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    do {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      ch = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == Header.SpecialFlagByte) {\n        const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result1[0];\n        let Value1 = result1[1];\n        SourcePtr = result1[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result2[0];\n        let Value2 = result2[1];\n        SourcePtr = result2[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return Dest;\n  }\n  static decode_06(Source) {\n    return this.decode_06or07(Source, WriteTypes.Columns);\n  }\n  static decode_07(Source) {\n    return this.decode_06or07(Source, WriteTypes.Rows);\n  }\n  static decode_06or07(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n    let XorBits = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let XorFlagsPtr = 0;\n    let XorBitsPtr = 0;\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    let XorFlagsCounter;\n    let XorBitsCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, XorFlags, XorBits];\n    }\n    WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, XorFlags, XorBits];\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xFF, Type);\n          XorFlagsPtr = resultXorFlags[0];\n          XorFlags = resultXorFlags[1];\n          XorFlagsCounter = resultXorFlags[2];\n          const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n          XorBitsPtr = resultXorBits[0];\n          XorBits = resultXorBits[1];\n          XorBitsCounter = resultXorBits[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n        const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n        XorFlagsPtr = resultXorFlags[0];\n        XorFlags = resultXorFlags[1];\n        XorFlagsCounter = resultXorFlags[2];\n        const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n        XorBitsPtr = resultXorBits[0];\n        XorBits = resultXorBits[1];\n        XorBitsCounter = resultXorBits[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return [Dest, XorFlags, XorBits];\n  }\n  static decode_08(Source) {\n    return this.decode_08or09(Source, WriteTypes.Columns);\n  }\n  static decode_09(Source) {\n    return this.decode_08or09(Source, WriteTypes.Rows);\n  }\n  static decode_08or09(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let count;\n    let pattern;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    function repeatSkips() {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n    }\n    count = SourcePtr;\n    count = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    WriteCounter = SkippedCounter = 0;\n    if (!count) {\n      repeatSkips();\n    }\n    while (continueLooping) {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          pattern = ROM.byteAtAddr(SourcePtr);\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      if (continueLooping) {\n        repeatSkips();\n      }\n    }\n    return [Dest, Skipped];\n  }\n  static decode_0A(Source) {\n    return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n  }\n  static decode_0B(Source) {\n    return this.decode_0Aor0B(Source, WriteTypes.Rows);\n  }\n  static decode_0Aor0B(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: 0\n    };\n    let count;\n    let i;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    Header.ReadMask = 0x80;\n    WriteCounter = SkippedCounter = 0;\n    function BulkSkips() {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n        return [Dest, Skipped];\n      }\n      return [Dest, Skipped];\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n    }\n    const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n    Header = result[0];\n    count = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    if (!count) {\n      BulkSkips();\n    }\n    while (continueLooping) {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n          Header = resultRead[0];\n          const Read = resultRead[1];\n          SourcePtr = resultRead[2];\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      BulkSkips();\n    }\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return [Dest, Skipped];\n  }\n  static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n    Dest.set([ch], DestPtr);\n    WriteCounterPtr++;\n    if (WriteCounterPtr >= WPC.DmdPageBytes) {\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (Type == WriteTypes.Rows) {\n      DestPtr++;\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (!(WriteCounterPtr % WPC.DmdRows)) {\n      DestPtr -= WPC.DmdCols / 8 * (WPC.DmdRows - 2) + (WPC.DmdCols / 8 - 1);\n    } else {\n      DestPtr += WPC.DmdCols / 8;\n    }\n    return [DestPtr, Dest, WriteCounterPtr];\n  }\n  static readNext8BitValue(Header, SourcePtr) {\n    let returnValues;\n    const result = DmdDecoder.readNextBit(Header, SourcePtr);\n    let ch = result[0];\n    Header = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      returnValues = [Header, 0x00, SourcePtr];\n      return returnValues;\n    }\n    let WriteMask;\n    let ReturnValue;\n    let i;\n    if (ch) {\n      let OnesCount = 0;\n      for (i = 0; i < 7; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          OnesCount++;\n        } else {\n          i = 7;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n      }\n      ReturnValue = Header.RepeatBytes[OnesCount];\n    } else {\n      WriteMask = 0x80;\n      ReturnValue = 0x00;\n      for (i = 0; i < 8; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          ReturnValue |= WriteMask;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n        WriteMask >>= 1;\n      }\n    }\n    returnValues = [Header, ReturnValue, SourcePtr];\n    return returnValues;\n  }\n  static readNextBit(Header, SourcePtr) {\n    let returnValues;\n    let ch = ROM.byteAtAddr(SourcePtr) & Header.ReadMask;\n    if (!(Header.ReadMask >>= 1)) {\n      Header.ReadMask = 0x80;\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        returnValues = [0x00, Header, SourcePtr];\n        return returnValues;\n      }\n    }\n    returnValues = [ch, Header, SourcePtr];\n    return returnValues;\n  }\n}","map":{"version":3,"names":["WriteTypes","ImageCodes","DataTypes","PlaneStatuses","WPC","DataParser","toHex","logStr","VariableSizedImageData","FullFrameImageData","ROM","DmdDecoder","constructor","PreviousPlaneDataPane0","Uint8Array","PreviousPlaneDataPane1","init","decodeNextIndex","count","dataType","Graphics","CurrentImageIndex","FontData","AniData","Planes","Plane0","Plane_Status","Valid","CurrentImageXShift","DmdCols","CurrentImageXSize","ImageShiftXPixelCount","CurrentImageYShift","DmdRows","CurrentImageYSize","ImageShiftYPixelCount","result","incrementVariableSizedImageIndex","CurrentTableIndex","pTableIndex","pImageIndex","tmpImageIndex","getLastImageIndex","getNextImageIndex","maxTableIndex","getFirstImageIndex","decrementVariableSizedImageIndex","getPrevImageIndex","minTableIndex","decodePreviousIndex","decodeFullFrameGraphic","GraphicIndex","decodeImageToPlane","Plane1","decodeVariableSizedImageData","decodeVariableSizedImageIndexToPlane","TableIndex","ImageIndex","DataPtr","Addr","defaultPlane","Plane_Size","Plane_Data","DmdPageBytes","Plane_Skipped","Plane_XorFlags","Plane_XorBits","Plane_Encoding","pPlanes","decodePlaneInit","getROMAddressOfVariableSizedImageIndex","BadDimension","decodeVariableSizedImage","Source","TableHeight","TableSpacing","ch","byteAtAddr","getVariableSizedImageTableMetadata","decodeVariableSizedImageIndex_NoHeader","Monochrome","BicolorIndirect","BicolorDirect","FD","decodeVariableSizedImageIndex_Header","decodeVariableSizedImage_Centered","SourcePtr","Dest","ImageHeight","ImageWidth","WriteCounter","i","j","DestPtr","endPtr","ImageOutOfRange","writeNext8BitValue","Rows","Math","ceil","floor","DestPlane0","DestPlane1","Invalid","HeaderByte","VerticalOffset","HorizontalOffset","result1","result0","Page","TmpBuf","pBiColor","extractWPCAddrAndPageOfImageTable","getROMAddressFromAddrOf3ByteWPCAddrPage","getImageEncoding","Index","pPlane","SkipDecoding","OriginalDataPtr","DMDPlane","TableAddress","size","TableEntryOutOfRange","decodeFullFrameGraphicImage","Plane","decode_00","decode_01","decode_02","decode_03","Unimplemented","decode_04","decode_05","result_06","decode_06","result_07","decode_07","result_08","decode_08","result_09","decode_09","result_0A","decode_0A","result_0B","decode_0B","Unknown","decode_01or02","Columns","Type","SpecialFlagByte","Value1","Value2","decode_04or05","Header","ReadMask","RepeatBytes","readNext8BitValue","result2","decode_06or07","XorFlags","XorBits","XorFlagsPtr","XorBitsPtr","XorFlagsCounter","XorBitsCounter","resultXorFlags","resultXorBits","decode_08or09","SkippedPtr","Skipped","pattern","SkippedCounter","continueLooping","repeatSkips","resultSkipped","decode_0Aor0B","BulkSkips","resultRead","Read","WriteCounterPtr","set","returnValues","readNextBit","WriteMask","ReturnValue","OnesCount"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/node_modules/wpcedit/dist/classes/DmdDecoder.js"],"sourcesContent":["import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n    constructor() {\n        this.PreviousPlaneDataPane0 = new Uint8Array();\n        this.PreviousPlaneDataPane1 = new Uint8Array();\n    }\n    init() {\n    }\n    static decodeNextIndex(count, dataType) {\n        switch (dataType) {\n            case DataTypes.Graphics:\n                while (count--) {\n                    {\n                        FullFrameImageData.CurrentImageIndex++;\n                    }\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n                    if ((VariableSizedImageData.CurrentImageXShift + WPC.DmdCols) < VariableSizedImageData.CurrentImageXSize) {\n                        VariableSizedImageData.CurrentImageXShift += (WPC.ImageShiftXPixelCount * count);\n                        break;\n                    }\n                    if ((VariableSizedImageData.CurrentImageYShift + WPC.DmdRows) < VariableSizedImageData.CurrentImageYSize) {\n                        VariableSizedImageData.CurrentImageYShift += (WPC.ImageShiftYPixelCount * count);\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                        logStr(`Unexpected error advancing image indexes`);\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if ((pTableIndex == null) || (pImageIndex == null)) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex);\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if (((pImageIndex) & 0xFF) < (tmpImageIndex & 0xFF)) {\n            pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n            pTableIndex++;\n            pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [0, 0];\n    }\n    static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if ((pTableIndex == null) || (pImageIndex == null)) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if (((pImageIndex) & 0xFF) > (tmpImageIndex & 0xFF)) {\n            pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex > VariableSizedImageData.minTableIndex) {\n            pTableIndex = (pTableIndex) - 1;\n            if (DataParser.getLastImageIndex(pImageIndex, pTableIndex) != 0) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [pTableIndex, pImageIndex];\n    }\n    static decodePreviousIndex(count, dataType) {\n        switch (dataType) {\n            case DataTypes.Graphics:\n                while ((count--) && (FullFrameImageData.CurrentImageIndex)) {\n                    FullFrameImageData.CurrentImageIndex--;\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n                    if (VariableSizedImageData.CurrentImageYShift > 0) {\n                        VariableSizedImageData.CurrentImageYShift -= (WPC.ImageShiftYPixelCount * count);\n                        if (VariableSizedImageData.CurrentImageYShift < 0) {\n                            VariableSizedImageData.CurrentImageYShift = 0;\n                        }\n                        break;\n                    }\n                    if (VariableSizedImageData.CurrentImageXShift > 0) {\n                        VariableSizedImageData.CurrentImageXShift -= (WPC.ImageShiftXPixelCount * count);\n                        if (VariableSizedImageData.CurrentImageXShift < 0) {\n                            VariableSizedImageData.CurrentImageXShift = 0;\n                        }\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static decodeFullFrameGraphic(GraphicIndex) {\n        FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n        FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane((GraphicIndex + 1));\n    }\n    static decodeVariableSizedImageData() {\n        const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n        VariableSizedImageData.Planes = result[1];\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n            VariableSizedImageData.CurrentImageXSize = 0;\n            VariableSizedImageData.CurrentImageYSize = 0;\n            VariableSizedImageData.CurrentImageXShift = 0;\n            VariableSizedImageData.CurrentImageYShift = 0;\n        }\n    }\n    static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n        let DataPtr;\n        let Addr;\n        const defaultPlane = {\n            Plane_Status: 0,\n            Plane_Size: 0,\n            Plane_Data: new Uint8Array(WPC.DmdPageBytes),\n            Plane_Skipped: new Uint8Array(WPC.DmdPageBytes),\n            Plane_XorFlags: new Uint8Array(WPC.DmdPageBytes),\n            Plane_XorBits: new Uint8Array(WPC.DmdPageBytes),\n            Plane_Encoding: 255\n        };\n        let pPlanes = {\n            Plane0: defaultPlane,\n            Plane1: defaultPlane\n        };\n        pPlanes.Plane0 = DmdDecoder.decodePlaneInit();\n        pPlanes.Plane1 = DmdDecoder.decodePlaneInit();\n        VariableSizedImageData.CurrentImageXSize = 0;\n        VariableSizedImageData.CurrentImageYSize = 0;\n        Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n        if (Addr == -1) {\n            pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n            pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n            return [-1, pPlanes];\n        }\n        DataPtr = (Addr);\n        pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n        let TableHeight;\n        let TableSpacing;\n        let ch = ROM.byteAtAddr(Source);\n        const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n        TableHeight = result[0];\n        TableSpacing = result[1];\n        if (TableHeight == -1) {\n            logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n            return [-1, pPlanes];\n        }\n        if ((ch > 0) && (ch <= WPC.DmdCols)) {\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n        }\n        else {\n            switch (ch) {\n                case ImageCodes.Monochrome:\n                case ImageCodes.BicolorIndirect:\n                case ImageCodes.BicolorDirect:\n                case ImageCodes.FD:\n                    break;\n                default:\n                    logStr(`Unrecognized Header Byte ${ch}`);\n                    break;\n            }\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n        }\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage_Centered(SourcePtr, Dest, ImageHeight, ImageWidth) {\n        let ch;\n        let WriteCounter = 0;\n        let i, j;\n        let DestPtr = 0;\n        if ((SourcePtr) >= ROM.endPtr) {\n            return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (VariableSizedImageData.CurrentImageYShift == -1) {\n            VariableSizedImageData.CurrentImageYShift = 0;\n            while ((WPC.DmdRows + VariableSizedImageData.CurrentImageYShift) < ImageHeight) {\n                VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n            }\n        }\n        if (VariableSizedImageData.CurrentImageXShift == -1) {\n            VariableSizedImageData.CurrentImageXShift = 0;\n            while ((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) < ImageWidth) {\n                VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n            }\n        }\n        for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        for (i = 0; ((i < WPC.DmdRows) && (WriteCounter < WPC.DmdPageBytes)); i++) {\n            if (ImageHeight < WPC.DmdRows) {\n                if ((i < ((WPC.DmdRows - ImageHeight) / 2)) ||\n                    (i >= (((WPC.DmdRows - ImageHeight) / 2) + ImageHeight))) {\n                    for (j = 0; j < (WPC.DmdCols / 8); j++) {\n                        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                        DestPtr = result[0];\n                        Dest = result[1];\n                        WriteCounter = result[2];\n                    }\n                    continue;\n                }\n            }\n            if (ImageHeight > WPC.DmdRows) {\n                if (i >= (ImageHeight - VariableSizedImageData.CurrentImageYShift)) {\n                    for (j = 0; j < (WPC.DmdCols / 8); j++) {\n                        const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                        DestPtr = result[0];\n                        Dest = result[1];\n                        WriteCounter = result[2];\n                    }\n                    continue;\n                }\n            }\n            if (ImageWidth < WPC.DmdCols) {\n                for (j = 0; j < Math.ceil(((WPC.DmdCols - ImageWidth) / 2) / 8); j++) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n            for (j = 0; j < Math.floor(((ImageWidth + 7) / 8)); j++) {\n                ch = ROM.byteAtAddr(SourcePtr);\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n                if ((j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8)) && (j < Math.floor(((WPC.DmdCols + VariableSizedImageData.CurrentImageXShift) + 7) / 8))) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n            if (ImageWidth < WPC.DmdCols) {\n                for (j = (Math.ceil(((WPC.DmdCols - ImageWidth) / 2) / 8) + ((ImageWidth + 7) / 8)); j < (WPC.DmdCols / 8); j++) {\n                    const result = this.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, WriteTypes.Rows);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n        }\n        for (i = 0; i < (ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift)); i++) {\n            for (j = 0; j < ((ImageWidth + 7) / 8); j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        VariableSizedImageData.CurrentImageXSize = ImageWidth;\n        VariableSizedImageData.CurrentImageYSize = ImageHeight;\n        return [PlaneStatuses.Valid, Dest, SourcePtr];\n    }\n    static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane1.Plane_Size = 0;\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        if ((SourcePtr++) >= ROM.endPtr) {\n            logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n            return pPlanes;\n        }\n        const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        SourcePtr = result[2];\n        return pPlanes;\n    }\n    static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let HeaderByte;\n        let VerticalOffset;\n        let HorizontalOffset;\n        let ImageHeight;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane0.Plane_Size = 0;\n        HeaderByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        VerticalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageHeight = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        switch (HeaderByte) {\n            case ImageCodes.BicolorDirect:\n                const result1 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n                pPlanes.Plane1.Plane_Status = result1[0];\n                pPlanes.Plane1.Plane_Data = result1[1];\n                const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result0[0];\n                pPlanes.Plane0.Plane_Data = result0[1];\n                break;\n            case ImageCodes.BicolorIndirect:\n                {\n                    let Page;\n                    let TmpBuf = [0, 0, 0];\n                    let Addr;\n                    let pBiColor;\n                    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n                    Addr = result[0];\n                    Page = result[1];\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n                        return pPlanes;\n                    }\n                    TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xFF;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[2] = (Page & 0xFF);\n                    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xFF} ${(TmpBuf[1] & 0xFF)} ${(TmpBuf[2] & 0xFF)}`);\n                        return pPlanes;\n                    }\n                    pBiColor = ROM.byteAtAddr(Addr);\n                    const result1 = this.decodeVariableSizedImage_Centered(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n                    pPlanes.Plane1.Plane_Status = result1[0];\n                    pPlanes.Plane1.Plane_Data = result1[1];\n                    const result0 = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                    pPlanes.Plane0.Plane_Status = result0[0];\n                    pPlanes.Plane0.Plane_Data = result0[1];\n                }\n                break;\n            case ImageCodes.FD:\n            default:\n                const result = this.decodeVariableSizedImage_Centered(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result[0];\n                pPlanes.Plane0.Plane_Data = result[1];\n                break;\n        }\n        return pPlanes;\n    }\n    static getImageEncoding(Index) {\n        const pPlane = this.decodeImageToPlane(Index);\n        return pPlane.Plane_Encoding;\n    }\n    static decodeImageToPlane(Index, SkipDecoding = false) {\n        let pPlane;\n        let OriginalDataPtr;\n        let DataPtr;\n        let Addr;\n        let DMDPlane;\n        DMDPlane = DmdDecoder.decodePlaneInit();\n        Addr = FullFrameImageData.TableAddress + (Index * 3);\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n        if (Addr == -1) {\n            logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        OriginalDataPtr = DataPtr = Addr;\n        DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane, SkipDecoding);\n        DMDPlane.Plane_Size = (DataPtr - OriginalDataPtr);\n        return DMDPlane;\n    }\n    static decodePlaneInit() {\n        let Plane = new Uint8Array(WPC.DmdPageBytes);\n        let pPlane = {\n            Plane_Size: 0,\n            Plane_Data: Plane,\n            Plane_Skipped: Plane,\n            Plane_XorFlags: Plane,\n            Plane_XorBits: Plane,\n            Plane_Status: PlaneStatuses.Valid,\n            Plane_Encoding: 255\n        };\n        return pPlane;\n    }\n    static decodeFullFrameGraphicImage(Source, pPlane, SkipDecoding) {\n        let OriginalDataPtr = Source;\n        let Dest = new Uint8Array(pPlane.Plane_Data);\n        let ch = ROM.byteAtAddr(Source);\n        pPlane.Plane_Encoding = ch & 0x0F;\n        if (SkipDecoding) {\n            return pPlane;\n        }\n        Source++;\n        if ((Source) >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        logStr(`Type ${toHex(ch)}`);\n        switch (ch & 0x0F) {\n            case 0x00:\n                Dest = this.decode_00(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x01:\n                Dest = this.decode_01(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x02:\n                Dest = this.decode_02(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x03:\n                Dest = this.decode_03(Source);\n                pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n                return pPlane;\n            case 0x04:\n                Dest = this.decode_04(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x05:\n                Dest = this.decode_05(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x06:\n                const result_06 = this.decode_06(Source);\n                pPlane.Plane_Data = result_06[0];\n                pPlane.Plane_Skipped = result_06[1];\n                pPlane.Plane_XorFlags = result_06[2];\n                pPlane.Plane_XorFlags = result_06[3];\n                return pPlane;\n            case 0x07:\n                const result_07 = this.decode_07(Source);\n                pPlane.Plane_Data = result_07[0];\n                pPlane.Plane_Skipped = result_07[1];\n                pPlane.Plane_XorFlags = result_07[2];\n                pPlane.Plane_XorFlags = result_07[3];\n                return pPlane;\n            case 0x08:\n                const result_08 = this.decode_08(Source);\n                pPlane.Plane_Data = result_08[0];\n                pPlane.Plane_Skipped = result_08[1];\n                return pPlane;\n                break;\n            case 0x09:\n                const result_09 = this.decode_09(Source);\n                pPlane.Plane_Data = result_09[0];\n                pPlane.Plane_Skipped = result_09[1];\n                return pPlane;\n            case 0x0A:\n                const result_0A = this.decode_0A(Source);\n                pPlane.Plane_Data = result_0A[0];\n                pPlane.Plane_Skipped = result_0A[1];\n                return pPlane;\n            case 0x0B:\n                const result_0B = this.decode_0B(Source);\n                pPlane.Plane_Data = result_0B[0];\n                pPlane.Plane_Skipped = result_0B[1];\n                return pPlane;\n            default:\n                logStr(`Unknown Image Type ${ch}`);\n                pPlane.Plane_Data = Dest;\n                pPlane.Plane_Status = PlaneStatuses.Unknown;\n                pPlane.Plane_Size = OriginalDataPtr - Source;\n                return pPlane;\n        }\n        if ((Source) >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        pPlane.Plane_Status = PlaneStatuses.Valid;\n        return pPlane;\n    }\n    static decode_00(Source) {\n        let Dest = new Uint8Array();\n        let i;\n        for (i = 0; i < WPC.DmdPageBytes; i++) {\n            Dest[i] = ROM.byteAtAddr(Source + i);\n            if (Source + i >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        return Dest;\n    }\n    static decode_01(Source) {\n        return this.decode_01or02(Source, WriteTypes.Columns);\n    }\n    static decode_02(Source) {\n        return this.decode_01or02(Source, WriteTypes.Rows);\n    }\n    static decode_01or02(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if ((SourcePtr) >= ROM.endPtr) {\n            return Dest;\n        }\n        WriteCounter = 0;\n        DestPtr = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return Dest;\n    }\n    static decode_03(Source) {\n        return new Uint8Array();\n    }\n    static decode_04(Source) {\n        return this.decode_04or05(Source, WriteTypes.Columns);\n    }\n    static decode_05(Source) {\n        return this.decode_04or05(Source, WriteTypes.Rows);\n    }\n    static decode_04or05(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n        };\n        let ch;\n        let i;\n        let WriteCounter;\n        WriteCounter = 0;\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return Dest;\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        do {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            ch = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == Header.SpecialFlagByte) {\n                const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result1[0];\n                let Value1 = result1[1];\n                SourcePtr = result1[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result2[0];\n                let Value2 = result2[1];\n                SourcePtr = result2[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return Dest;\n    }\n    static decode_06(Source) {\n        return this.decode_06or07(Source, WriteTypes.Columns);\n    }\n    static decode_07(Source) {\n        return this.decode_06or07(Source, WriteTypes.Rows);\n    }\n    static decode_06or07(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n        let XorBits = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let XorFlagsPtr = 0;\n        let XorBitsPtr = 0;\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        let XorFlagsCounter;\n        let XorBitsCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, XorFlags, XorBits];\n        }\n        WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, XorFlags, XorBits];\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xFF, Type);\n                    XorFlagsPtr = resultXorFlags[0];\n                    XorFlags = resultXorFlags[1];\n                    XorFlagsCounter = resultXorFlags[2];\n                    const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n                    XorBitsPtr = resultXorBits[0];\n                    XorBits = resultXorBits[1];\n                    XorBitsCounter = resultXorBits[2];\n                } while ((--Value1) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n                const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n                XorFlagsPtr = resultXorFlags[0];\n                XorFlags = resultXorFlags[1];\n                XorFlagsCounter = resultXorFlags[2];\n                const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n                XorBitsPtr = resultXorBits[0];\n                XorBits = resultXorBits[1];\n                XorBitsCounter = resultXorBits[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return [Dest, XorFlags, XorBits];\n    }\n    static decode_08(Source) {\n        return this.decode_08or09(Source, WriteTypes.Columns);\n    }\n    static decode_09(Source) {\n        return this.decode_08or09(Source, WriteTypes.Rows);\n    }\n    static decode_08or09(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let count;\n        let pattern;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        function repeatSkips() {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n        }\n        count = SourcePtr;\n        count = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        WriteCounter = SkippedCounter = 0;\n        if (!count) {\n            repeatSkips();\n        }\n        while (continueLooping) {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    pattern = ROM.byteAtAddr(SourcePtr);\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            if (continueLooping) {\n                repeatSkips();\n            }\n        }\n        return [Dest, Skipped];\n    }\n    static decode_0A(Source) {\n        return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n    }\n    static decode_0B(Source) {\n        return this.decode_0Aor0B(Source, WriteTypes.Rows);\n    }\n    static decode_0Aor0B(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: 0\n        };\n        let count;\n        let i;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        Header.ReadMask = 0x80;\n        WriteCounter = SkippedCounter = 0;\n        function BulkSkips() {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xFF, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n                return [Dest, Skipped];\n            }\n            return [Dest, Skipped];\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n        }\n        const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result[0];\n        count = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        if (!count) {\n            BulkSkips();\n        }\n        while (continueLooping) {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                    Header = resultRead[0];\n                    const Read = resultRead[1];\n                    SourcePtr = resultRead[2];\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while ((--count) && (WriteCounter < WPC.DmdPageBytes));\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            BulkSkips();\n        }\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return [Dest, Skipped];\n    }\n    static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n        Dest.set([ch], DestPtr);\n        WriteCounterPtr++;\n        if ((WriteCounterPtr) >= WPC.DmdPageBytes) {\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (Type == WriteTypes.Rows) {\n            DestPtr++;\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (!(WriteCounterPtr % (WPC.DmdRows))) {\n            DestPtr -= (((WPC.DmdCols / 8) * (WPC.DmdRows - 2)) + ((WPC.DmdCols / 8) - 1));\n        }\n        else {\n            DestPtr += (WPC.DmdCols / 8);\n        }\n        return [DestPtr, Dest, WriteCounterPtr];\n    }\n    static readNext8BitValue(Header, SourcePtr) {\n        let returnValues;\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        let ch = result[0];\n        Header = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            returnValues = [Header, 0x00, SourcePtr];\n            return returnValues;\n        }\n        let WriteMask;\n        let ReturnValue;\n        let i;\n        if (ch) {\n            let OnesCount = 0;\n            for (i = 0; i < 7; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    OnesCount++;\n                }\n                else {\n                    i = 7;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n            }\n            ReturnValue = Header.RepeatBytes[OnesCount];\n        }\n        else {\n            WriteMask = 0x80;\n            ReturnValue = 0x00;\n            for (i = 0; i < 8; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    ReturnValue |= WriteMask;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n                WriteMask >>= 1;\n            }\n        }\n        returnValues = [Header, ReturnValue, SourcePtr];\n        return (returnValues);\n    }\n    static readNextBit(Header, SourcePtr) {\n        let returnValues;\n        let ch = (ROM.byteAtAddr(SourcePtr) & Header.ReadMask);\n        if (!(Header.ReadMask >>= 1)) {\n            Header.ReadMask = 0x80;\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                returnValues = [0x00, Header, SourcePtr];\n                return returnValues;\n            }\n        }\n        returnValues = [ch, Header, SourcePtr];\n        return returnValues;\n    }\n}\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,EAAEC,SAAS,EAAEC,aAAa,EAAEC,GAAG,QAAQ,2BAA2B;AACjG,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,KAAK,EAAEC,MAAM,QAAQ,yBAAyB;AACvD,SAASC,sBAAsB,QAAQ,qCAAqC;AAC5E,SAASC,kBAAkB,QAAQ,iCAAiC;AACpE,SAASC,GAAG,QAAQ,kBAAkB;AACtC,OAAO,MAAMC,UAAU,CAAC;EACpBC,WAAW,GAAG;IACV,IAAI,CAACC,sBAAsB,GAAG,IAAIC,UAAU,EAAE;IAC9C,IAAI,CAACC,sBAAsB,GAAG,IAAID,UAAU,EAAE;EAClD;EACAE,IAAI,GAAG,CACP;EACA,OAAOC,eAAe,CAACC,KAAK,EAAEC,QAAQ,EAAE;IACpC,QAAQA,QAAQ;MACZ,KAAKjB,SAAS,CAACkB,QAAQ;QACnB,OAAOF,KAAK,EAAE,EAAE;UACZ;YACIT,kBAAkB,CAACY,iBAAiB,EAAE;UAC1C;QACJ;QACA;MACJ,KAAKnB,SAAS,CAACoB,QAAQ;MACvB,KAAKpB,SAAS,CAACqB,OAAO;QAClB,IAAIf,sBAAsB,CAACgB,MAAM,CAACC,MAAM,CAACC,YAAY,IAAIvB,aAAa,CAACwB,KAAK,EAAE;UAC1E,IAAKnB,sBAAsB,CAACoB,kBAAkB,GAAGxB,GAAG,CAACyB,OAAO,GAAIrB,sBAAsB,CAACsB,iBAAiB,EAAE;YACtGtB,sBAAsB,CAACoB,kBAAkB,IAAKxB,GAAG,CAAC2B,qBAAqB,GAAGb,KAAM;YAChF;UACJ;UACA,IAAKV,sBAAsB,CAACwB,kBAAkB,GAAG5B,GAAG,CAAC6B,OAAO,GAAIzB,sBAAsB,CAAC0B,iBAAiB,EAAE;YACtG1B,sBAAsB,CAACwB,kBAAkB,IAAK5B,GAAG,CAAC+B,qBAAqB,GAAGjB,KAAM;YAChF;UACJ;QACJ;QACAV,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,CAAC;QAC9CpB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,CAAC;QAC9C,OAAOd,KAAK,EAAE,EAAE;UACZ,MAAMkB,MAAM,GAAGzB,UAAU,CAAC0B,gCAAgC,CAAC7B,sBAAsB,CAAC8B,iBAAiB,EAAE9B,sBAAsB,CAACa,iBAAiB,CAAC;UAC9Ib,sBAAsB,CAAC8B,iBAAiB,GAAGF,MAAM,CAAC,CAAC,CAAC;UACpD5B,sBAAsB,CAACa,iBAAiB,GAAGe,MAAM,CAAC,CAAC,CAAC;UACpD,IAAIA,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;YACjB7B,MAAM,CAAE,0CAAyC,CAAC;UACtD;QACJ;QACA;MACJ;QACI;IAAM;EAElB;EACA,OAAO8B,gCAAgC,CAACE,WAAW,EAAEC,WAAW,EAAE;IAC9D,IAAIC,aAAa;IACjB,IAAKF,WAAW,IAAI,IAAI,IAAMC,WAAW,IAAI,IAAK,EAAE;MAChD,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACAC,aAAa,GAAGpC,UAAU,CAACqC,iBAAiB,CAACF,WAAW,EAAED,WAAW,CAAC;IACtE,IAAIE,aAAa,IAAI,CAAC,CAAC,EAAE;MACrB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACA,IAAI,CAAED,WAAW,GAAI,IAAI,KAAKC,aAAa,GAAG,IAAI,CAAC,EAAE;MACjDD,WAAW,GAAGnC,UAAU,CAACsC,iBAAiB,CAACH,WAAW,EAAED,WAAW,CAAC;MACpE,IAAIC,WAAW,IAAI,CAAC,CAAC,EAAE;QACnB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,IAAID,WAAW,GAAG/B,sBAAsB,CAACoC,aAAa,EAAE;MACpDL,WAAW,EAAE;MACbC,WAAW,GAAGnC,UAAU,CAACwC,kBAAkB,CAACN,WAAW,CAAC;MACxD,IAAIC,WAAW,IAAI,CAAC,CAAC,EAAE;QACnB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EACjB;EACA,OAAOM,gCAAgC,CAACP,WAAW,EAAEC,WAAW,EAAE;IAC9D,IAAIC,aAAa;IACjB,IAAKF,WAAW,IAAI,IAAI,IAAMC,WAAW,IAAI,IAAK,EAAE;MAChD,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACAC,aAAa,GAAGpC,UAAU,CAACwC,kBAAkB,CAACN,WAAW,CAAC;IAC1D,IAAIE,aAAa,IAAI,CAAC,CAAC,EAAE;MACrB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnB;IACA,IAAI,CAAED,WAAW,GAAI,IAAI,KAAKC,aAAa,GAAG,IAAI,CAAC,EAAE;MACjDD,WAAW,GAAGnC,UAAU,CAAC0C,iBAAiB,CAACP,WAAW,EAAED,WAAW,CAAC;MACpE,IAAIC,WAAW,IAAI,CAAC,CAAC,EAAE;QACnB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,IAAID,WAAW,GAAG/B,sBAAsB,CAACwC,aAAa,EAAE;MACpDT,WAAW,GAAIA,WAAW,GAAI,CAAC;MAC/B,IAAIlC,UAAU,CAACqC,iBAAiB,CAACF,WAAW,EAAED,WAAW,CAAC,IAAI,CAAC,EAAE;QAC7D,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACnB;MACA,OAAO,CAACA,WAAW,EAAEC,WAAW,CAAC;IACrC;IACA,OAAO,CAACD,WAAW,EAAEC,WAAW,CAAC;EACrC;EACA,OAAOS,mBAAmB,CAAC/B,KAAK,EAAEC,QAAQ,EAAE;IACxC,QAAQA,QAAQ;MACZ,KAAKjB,SAAS,CAACkB,QAAQ;QACnB,OAAQF,KAAK,EAAE,IAAMT,kBAAkB,CAACY,iBAAkB,EAAE;UACxDZ,kBAAkB,CAACY,iBAAiB,EAAE;QAC1C;QACA;MACJ,KAAKnB,SAAS,CAACoB,QAAQ;MACvB,KAAKpB,SAAS,CAACqB,OAAO;QAClB,IAAIf,sBAAsB,CAACgB,MAAM,CAACC,MAAM,CAACC,YAAY,IAAIvB,aAAa,CAACwB,KAAK,EAAE;UAC1E,IAAInB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,EAAE;YAC/CxB,sBAAsB,CAACwB,kBAAkB,IAAK5B,GAAG,CAAC+B,qBAAqB,GAAGjB,KAAM;YAChF,IAAIV,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,EAAE;cAC/CxB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC;YACjD;YACA;UACJ;UACA,IAAIxB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,EAAE;YAC/CpB,sBAAsB,CAACoB,kBAAkB,IAAKxB,GAAG,CAAC2B,qBAAqB,GAAGb,KAAM;YAChF,IAAIV,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,EAAE;cAC/CpB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC;YACjD;YACA;UACJ;QACJ;QACApB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,CAAC;QAC9CpB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC,CAAC;QAC9C,OAAOd,KAAK,EAAE,EAAE;UACZ,MAAMkB,MAAM,GAAGzB,UAAU,CAACmC,gCAAgC,CAACtC,sBAAsB,CAAC8B,iBAAiB,EAAE9B,sBAAsB,CAACa,iBAAiB,CAAC;UAC9Ib,sBAAsB,CAAC8B,iBAAiB,GAAGF,MAAM,CAAC,CAAC,CAAC;UACpD5B,sBAAsB,CAACa,iBAAiB,GAAGe,MAAM,CAAC,CAAC,CAAC;UACpD,IAAIA,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CACrB;QACJ;QACA;MACJ;QACI;IAAM;EAElB;EACA,OAAOc,sBAAsB,CAACC,YAAY,EAAE;IACxC1C,kBAAkB,CAACe,MAAM,CAACC,MAAM,GAAG,IAAI,CAAC2B,kBAAkB,CAACD,YAAY,CAAC;IACxE1C,kBAAkB,CAACe,MAAM,CAAC6B,MAAM,GAAG,IAAI,CAACD,kBAAkB,CAAED,YAAY,GAAG,CAAC,CAAE;EAClF;EACA,OAAOG,4BAA4B,GAAG;IAClC,MAAMlB,MAAM,GAAGzB,UAAU,CAAC4C,oCAAoC,CAAC/C,sBAAsB,CAAC8B,iBAAiB,EAAE9B,sBAAsB,CAACa,iBAAiB,CAAC;IAClJb,sBAAsB,CAACgB,MAAM,GAAGY,MAAM,CAAC,CAAC,CAAC;IACzC,IAAI5B,sBAAsB,CAACgB,MAAM,CAACC,MAAM,CAACC,YAAY,IAAIvB,aAAa,CAACwB,KAAK,EAAE;MAC1EnB,sBAAsB,CAACsB,iBAAiB,GAAG,CAAC;MAC5CtB,sBAAsB,CAAC0B,iBAAiB,GAAG,CAAC;MAC5C1B,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC;MAC7CpB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC;IACjD;EACJ;EACA,OAAOuB,oCAAoC,CAACC,UAAU,EAAEC,UAAU,EAAE;IAChE,IAAIC,OAAO;IACX,IAAIC,IAAI;IACR,MAAMC,YAAY,GAAG;MACjBlC,YAAY,EAAE,CAAC;MACfmC,UAAU,EAAE,CAAC;MACbC,UAAU,EAAE,IAAIhD,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;MAC5CC,aAAa,EAAE,IAAIlD,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;MAC/CE,cAAc,EAAE,IAAInD,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;MAChDG,aAAa,EAAE,IAAIpD,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;MAC/CI,cAAc,EAAE;IACpB,CAAC;IACD,IAAIC,OAAO,GAAG;MACV3C,MAAM,EAAEmC,YAAY;MACpBP,MAAM,EAAEO;IACZ,CAAC;IACDQ,OAAO,CAAC3C,MAAM,GAAGd,UAAU,CAAC0D,eAAe,EAAE;IAC7CD,OAAO,CAACf,MAAM,GAAG1C,UAAU,CAAC0D,eAAe,EAAE;IAC7C7D,sBAAsB,CAACsB,iBAAiB,GAAG,CAAC;IAC5CtB,sBAAsB,CAAC0B,iBAAiB,GAAG,CAAC;IAC5CyB,IAAI,GAAGtD,UAAU,CAACiE,sCAAsC,CAACd,UAAU,EAAEC,UAAU,CAAC;IAChF,IAAIE,IAAI,IAAI,CAAC,CAAC,EAAE;MACZS,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGvB,aAAa,CAACoE,YAAY;MACxDH,OAAO,CAACf,MAAM,CAAC3B,YAAY,GAAGvB,aAAa,CAACoE,YAAY;MACxD,OAAO,CAAC,CAAC,CAAC,EAAEH,OAAO,CAAC;IACxB;IACAV,OAAO,GAAIC,IAAK;IAChBS,OAAO,GAAGzD,UAAU,CAAC6D,wBAAwB,CAACd,OAAO,EAAEU,OAAO,EAAEZ,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9E,OAAO,CAAC,CAAC,EAAEY,OAAO,CAAC;EACvB;EACA,OAAOI,wBAAwB,CAACC,MAAM,EAAEL,OAAO,EAAEZ,UAAU,EAAE;IACzD,IAAIkB,WAAW;IACf,IAAIC,YAAY;IAChB,IAAIC,EAAE,GAAGlE,GAAG,CAACmE,UAAU,CAACJ,MAAM,CAAC;IAC/B,MAAMrC,MAAM,GAAG/B,UAAU,CAACyE,kCAAkC,CAACtB,UAAU,CAAC;IACxEkB,WAAW,GAAGtC,MAAM,CAAC,CAAC,CAAC;IACvBuC,YAAY,GAAGvC,MAAM,CAAC,CAAC,CAAC;IACxB,IAAIsC,WAAW,IAAI,CAAC,CAAC,EAAE;MACnBnE,MAAM,CAAE,4CAA2CiD,UAAW,mBAAkB,CAAC;MACjF,OAAO,CAAC,CAAC,CAAC,EAAEY,OAAO,CAAC;IACxB;IACA,IAAKQ,EAAE,GAAG,CAAC,IAAMA,EAAE,IAAIxE,GAAG,CAACyB,OAAQ,EAAE;MACjCuC,OAAO,GAAGzD,UAAU,CAACoE,sCAAsC,CAACN,MAAM,EAAEL,OAAO,EAAEM,WAAW,CAAC;IAC7F,CAAC,MACI;MACD,QAAQE,EAAE;QACN,KAAK3E,UAAU,CAAC+E,UAAU;QAC1B,KAAK/E,UAAU,CAACgF,eAAe;QAC/B,KAAKhF,UAAU,CAACiF,aAAa;QAC7B,KAAKjF,UAAU,CAACkF,EAAE;UACd;QACJ;UACI5E,MAAM,CAAE,4BAA2BqE,EAAG,EAAC,CAAC;UACxC;MAAM;MAEdR,OAAO,GAAGzD,UAAU,CAACyE,oCAAoC,CAACX,MAAM,EAAEL,OAAO,EAAEM,WAAW,EAAElB,UAAU,CAAC;IACvG;IACA,OAAO,CAAC,CAAC,EAAEY,OAAO,CAAC;EACvB;EACA,OAAOiB,iCAAiC,CAACC,SAAS,EAAEC,IAAI,EAAEC,WAAW,EAAEC,UAAU,EAAE;IAC/E,IAAIb,EAAE;IACN,IAAIc,YAAY,GAAG,CAAC;IACpB,IAAIC,CAAC,EAAEC,CAAC;IACR,IAAIC,OAAO,GAAG,CAAC;IACf,IAAKP,SAAS,IAAK5E,GAAG,CAACoF,MAAM,EAAE;MAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;IAC3D;IACA,IAAI9E,sBAAsB,CAACwB,kBAAkB,IAAI,CAAC,CAAC,EAAE;MACjDxB,sBAAsB,CAACwB,kBAAkB,GAAG,CAAC;MAC7C,OAAQ5B,GAAG,CAAC6B,OAAO,GAAGzB,sBAAsB,CAACwB,kBAAkB,GAAIwD,WAAW,EAAE;QAC5EhF,sBAAsB,CAACwB,kBAAkB,IAAI5B,GAAG,CAAC+B,qBAAqB;MAC1E;IACJ;IACA,IAAI3B,sBAAsB,CAACoB,kBAAkB,IAAI,CAAC,CAAC,EAAE;MACjDpB,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC;MAC7C,OAAQxB,GAAG,CAACyB,OAAO,GAAGrB,sBAAsB,CAACoB,kBAAkB,GAAI6D,UAAU,EAAE;QAC3EjF,sBAAsB,CAACoB,kBAAkB,IAAIxB,GAAG,CAAC2B,qBAAqB;MAC1E;IACJ;IACA,KAAK4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnF,sBAAsB,CAACwB,kBAAkB,EAAE2D,CAAC,EAAE,EAAE;MAC5D,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAI,CAACH,UAAU,GAAG,CAAC,IAAI,CAAE,EAAEG,CAAC,EAAE,EAAE;QACzC,IAAIN,SAAS,EAAE,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;QAC3D;MACJ;IACJ;IACA,KAAKK,CAAC,GAAG,CAAC,EAAIA,CAAC,GAAGvF,GAAG,CAAC6B,OAAO,IAAMyD,YAAY,GAAGtF,GAAG,CAAC2D,YAAa,EAAG4B,CAAC,EAAE,EAAE;MACvE,IAAIH,WAAW,GAAGpF,GAAG,CAAC6B,OAAO,EAAE;QAC3B,IAAK0D,CAAC,GAAI,CAACvF,GAAG,CAAC6B,OAAO,GAAGuD,WAAW,IAAI,CAAE,IACrCG,CAAC,IAAM,CAACvF,GAAG,CAAC6B,OAAO,GAAGuD,WAAW,IAAI,CAAC,GAAIA,WAAa,EAAE;UAC1D,KAAKI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIxF,GAAG,CAACyB,OAAO,GAAG,CAAE,EAAE+D,CAAC,EAAE,EAAE;YACpC,MAAMxD,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;YAChGJ,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;YACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;YAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UAC5B;UACA;QACJ;MACJ;MACA,IAAIoD,WAAW,GAAGpF,GAAG,CAAC6B,OAAO,EAAE;QAC3B,IAAI0D,CAAC,IAAKH,WAAW,GAAGhF,sBAAsB,CAACwB,kBAAmB,EAAE;UAChE,KAAK4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIxF,GAAG,CAACyB,OAAO,GAAG,CAAE,EAAE+D,CAAC,EAAE,EAAE;YACpC,MAAMxD,MAAM,GAAG,IAAI,CAAC4D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;YAC1FJ,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;YACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;YAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UAC5B;UACA;QACJ;MACJ;MACA,IAAIqD,UAAU,GAAGrF,GAAG,CAACyB,OAAO,EAAE;QAC1B,KAAK+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,IAAI,CAACC,IAAI,CAAE,CAAC/F,GAAG,CAACyB,OAAO,GAAG4D,UAAU,IAAI,CAAC,GAAI,CAAC,CAAC,EAAEG,CAAC,EAAE,EAAE;UAClE,MAAMxD,MAAM,GAAG,IAAI,CAAC4D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;UAC1FJ,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;QAC5B;MACJ;MACA,KAAKwD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,IAAI,CAACE,KAAK,CAAE,CAACX,UAAU,GAAG,CAAC,IAAI,CAAC,CAAE,EAAEG,CAAC,EAAE,EAAE;QACrDhB,EAAE,GAAGlE,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;QAC9B,IAAIA,SAAS,EAAE,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;QAC3D;QACA,IAAKM,CAAC,IAAIM,IAAI,CAACE,KAAK,CAAC,CAAC5F,sBAAsB,CAACoB,kBAAkB,GAAG,CAAC,IAAI,CAAC,CAAC,IAAMgE,CAAC,GAAGM,IAAI,CAACE,KAAK,CAAC,CAAEhG,GAAG,CAACyB,OAAO,GAAGrB,sBAAsB,CAACoB,kBAAkB,GAAI,CAAC,IAAI,CAAC,CAAE,EAAE;UACjK,MAAMQ,MAAM,GAAG,IAAI,CAAC4D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAE5E,UAAU,CAACiG,IAAI,CAAC;UACxFJ,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;QAC5B;MACJ;MACA,IAAIqD,UAAU,GAAGrF,GAAG,CAACyB,OAAO,EAAE;QAC1B,KAAK+D,CAAC,GAAIM,IAAI,CAACC,IAAI,CAAE,CAAC/F,GAAG,CAACyB,OAAO,GAAG4D,UAAU,IAAI,CAAC,GAAI,CAAC,CAAC,GAAI,CAACA,UAAU,GAAG,CAAC,IAAI,CAAG,EAAEG,CAAC,GAAIxF,GAAG,CAACyB,OAAO,GAAG,CAAE,EAAE+D,CAAC,EAAE,EAAE;UAC7G,MAAMxD,MAAM,GAAG,IAAI,CAAC4D,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAE7F,UAAU,CAACiG,IAAI,CAAC;UAC1FJ,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;QAC5B;MACJ;IACJ;IACA,KAAKuD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIH,WAAW,IAAIpF,GAAG,CAAC6B,OAAO,GAAGzB,sBAAsB,CAACwB,kBAAkB,CAAE,EAAE2D,CAAC,EAAE,EAAE;MAC5F,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAI,CAACH,UAAU,GAAG,CAAC,IAAI,CAAE,EAAEG,CAAC,EAAE,EAAE;QACzC,IAAIN,SAAS,EAAE,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UAC3B,OAAO,CAAC3F,aAAa,CAAC4F,eAAe,EAAER,IAAI,EAAED,SAAS,CAAC;QAC3D;MACJ;IACJ;IACA9E,sBAAsB,CAACsB,iBAAiB,GAAG2D,UAAU;IACrDjF,sBAAsB,CAAC0B,iBAAiB,GAAGsD,WAAW;IACtD,OAAO,CAACrF,aAAa,CAACwB,KAAK,EAAE4D,IAAI,EAAED,SAAS,CAAC;EACjD;EACA,OAAOP,sCAAsC,CAACO,SAAS,EAAElB,OAAO,EAAEM,WAAW,EAAE;IAC3E,IAAI2B,UAAU,GAAGjC,OAAO,CAAC3C,MAAM,CAACqC,UAAU;IAC1C,IAAIwC,UAAU,GAAGlC,OAAO,CAACf,MAAM,CAACS,UAAU;IAC1C,IAAI2B,UAAU;IACdrB,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGvB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAACf,MAAM,CAAC3B,YAAY,GAAGvB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAAC3C,MAAM,CAACoC,UAAU,GAAG,CAAC;IAC7BO,OAAO,CAACf,MAAM,CAACQ,UAAU,GAAG,CAAC;IAC7B4B,UAAU,GAAG/E,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IACtC,IAAKA,SAAS,EAAE,IAAK5E,GAAG,CAACoF,MAAM,EAAE;MAC7BvF,MAAM,CAAE,sEAAqE,CAAC;MAC9E,OAAO6D,OAAO;IAClB;IACA,MAAMhC,MAAM,GAAG,IAAI,CAACiD,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAE3B,WAAW,EAAEe,UAAU,CAAC;IACrGrB,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGU,MAAM,CAAC,CAAC,CAAC;IACvCgC,OAAO,CAAC3C,MAAM,CAACqC,UAAU,GAAG1B,MAAM,CAAC,CAAC,CAAC;IACrCkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;IACrB,OAAOgC,OAAO;EAClB;EACA,OAAOgB,oCAAoC,CAACE,SAAS,EAAElB,OAAO,EAAEM,WAAW,EAAElB,UAAU,EAAE;IACrF,IAAI6C,UAAU,GAAGjC,OAAO,CAAC3C,MAAM,CAACqC,UAAU;IAC1C,IAAIwC,UAAU,GAAGlC,OAAO,CAACf,MAAM,CAACS,UAAU;IAC1C,IAAI0C,UAAU;IACd,IAAIC,cAAc;IAClB,IAAIC,gBAAgB;IACpB,IAAIlB,WAAW;IACf,IAAIC,UAAU;IACdrB,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGvB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAACf,MAAM,CAAC3B,YAAY,GAAGvB,aAAa,CAACoG,OAAO;IACnDnC,OAAO,CAAC3C,MAAM,CAACoC,UAAU,GAAG,CAAC;IAC7BO,OAAO,CAAC3C,MAAM,CAACoC,UAAU,GAAG,CAAC;IAC7B2C,UAAU,GAAG9F,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IACtCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAqC,cAAc,GAAG/F,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IAC1CA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAsC,gBAAgB,GAAGhG,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IAC5CA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAoB,WAAW,GAAG9E,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IACvCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACAqB,UAAU,GAAG/E,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IACtCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO1B,OAAO;IAClB;IACA,QAAQoC,UAAU;MACd,KAAKvG,UAAU,CAACiF,aAAa;QACzB,MAAMyB,OAAO,GAAG,IAAI,CAACtB,iCAAiC,CAACC,SAAS,EAAEgB,UAAU,EAAEd,WAAW,EAAEC,UAAU,CAAC;QACtGrB,OAAO,CAACf,MAAM,CAAC3B,YAAY,GAAGiF,OAAO,CAAC,CAAC,CAAC;QACxCvC,OAAO,CAACf,MAAM,CAACS,UAAU,GAAG6C,OAAO,CAAC,CAAC,CAAC;QACtC,MAAMC,OAAO,GAAG,IAAI,CAACvB,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAEb,WAAW,EAAEC,UAAU,CAAC;QACtGrB,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGkF,OAAO,CAAC,CAAC,CAAC;QACxCxC,OAAO,CAAC3C,MAAM,CAACqC,UAAU,GAAG8C,OAAO,CAAC,CAAC,CAAC;QACtC;MACJ,KAAK3G,UAAU,CAACgF,eAAe;QAC3B;UACI,IAAI4B,IAAI;UACR,IAAIC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UACtB,IAAInD,IAAI;UACR,IAAIoD,QAAQ;UACZ,MAAM3E,MAAM,GAAG/B,UAAU,CAAC2G,iCAAiC,CAACxD,UAAU,CAAC;UACvEG,IAAI,GAAGvB,MAAM,CAAC,CAAC,CAAC;UAChByE,IAAI,GAAGzE,MAAM,CAAC,CAAC,CAAC;UAChB,IAAIuB,IAAI,IAAI,CAAC,CAAC,EAAE;YACZpD,MAAM,CAAE,oFAAmFiD,UAAW,WAAU,CAAC;YACjH,OAAOY,OAAO;UAClB;UACA0C,MAAM,CAAC,CAAC,CAAC,GAAGpG,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC,GAAG,IAAI;UAC5CA,SAAS,EAAE;UACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;YACzB,OAAO1B,OAAO;UAClB;UACA0C,MAAM,CAAC,CAAC,CAAC,GAAGpG,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC,GAAG,IAAI;UAC5CA,SAAS,EAAE;UACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;YACzB,OAAO1B,OAAO;UAClB;UACA0C,MAAM,CAAC,CAAC,CAAC,GAAID,IAAI,GAAG,IAAK;UACzBlD,IAAI,GAAGtD,UAAU,CAAC4G,uCAAuC,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC;UACpE,IAAInD,IAAI,IAAI,CAAC,CAAC,EAAE;YACZpD,MAAM,CAAE,4HAA2HuG,MAAM,CAAC,CAAC,CAAC,GAAG,IAAK,IAAIA,MAAM,CAAC,CAAC,CAAC,GAAG,IAAM,IAAIA,MAAM,CAAC,CAAC,CAAC,GAAG,IAAM,EAAC,CAAC;YAClM,OAAO1C,OAAO;UAClB;UACA2C,QAAQ,GAAGrG,GAAG,CAACmE,UAAU,CAAClB,IAAI,CAAC;UAC/B,MAAMgD,OAAO,GAAG,IAAI,CAACtB,iCAAiC,CAAC0B,QAAQ,EAAET,UAAU,EAAEd,WAAW,EAAEC,UAAU,CAAC;UACrGrB,OAAO,CAACf,MAAM,CAAC3B,YAAY,GAAGiF,OAAO,CAAC,CAAC,CAAC;UACxCvC,OAAO,CAACf,MAAM,CAACS,UAAU,GAAG6C,OAAO,CAAC,CAAC,CAAC;UACtC,MAAMC,OAAO,GAAG,IAAI,CAACvB,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAEb,WAAW,EAAEC,UAAU,CAAC;UACtGrB,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGkF,OAAO,CAAC,CAAC,CAAC;UACxCxC,OAAO,CAAC3C,MAAM,CAACqC,UAAU,GAAG8C,OAAO,CAAC,CAAC,CAAC;QAC1C;QACA;MACJ,KAAK3G,UAAU,CAACkF,EAAE;MAClB;QACI,MAAM/C,MAAM,GAAG,IAAI,CAACiD,iCAAiC,CAACC,SAAS,EAAEe,UAAU,EAAEb,WAAW,EAAEC,UAAU,CAAC;QACrGrB,OAAO,CAAC3C,MAAM,CAACC,YAAY,GAAGU,MAAM,CAAC,CAAC,CAAC;QACvCgC,OAAO,CAAC3C,MAAM,CAACqC,UAAU,GAAG1B,MAAM,CAAC,CAAC,CAAC;QACrC;IAAM;IAEd,OAAOgC,OAAO;EAClB;EACA,OAAO8C,gBAAgB,CAACC,KAAK,EAAE;IAC3B,MAAMC,MAAM,GAAG,IAAI,CAAChE,kBAAkB,CAAC+D,KAAK,CAAC;IAC7C,OAAOC,MAAM,CAACjD,cAAc;EAChC;EACA,OAAOf,kBAAkB,CAAC+D,KAAK,EAAEE,YAAY,GAAG,KAAK,EAAE;IACnD,IAAID,MAAM;IACV,IAAIE,eAAe;IACnB,IAAI5D,OAAO;IACX,IAAIC,IAAI;IACR,IAAI4D,QAAQ;IACZA,QAAQ,GAAG5G,UAAU,CAAC0D,eAAe,EAAE;IACvCV,IAAI,GAAGlD,kBAAkB,CAAC+G,YAAY,GAAIL,KAAK,GAAG,CAAE;IACpD,IAAIxD,IAAI,IAAIjD,GAAG,CAAC+G,IAAI,EAAE;MAClBF,QAAQ,CAAC7F,YAAY,GAAGvB,aAAa,CAACuH,oBAAoB;MAC1D,OAAOH,QAAQ;IACnB;IACA5D,IAAI,GAAGtD,UAAU,CAAC4G,uCAAuC,CAACtD,IAAI,CAAC;IAC/D,IAAIA,IAAI,IAAI,CAAC,CAAC,EAAE;MACZpD,MAAM,CAAE,+EAA8E,CAAC;MACvFgH,QAAQ,CAAC7F,YAAY,GAAGvB,aAAa,CAACuH,oBAAoB;MAC1D,OAAOH,QAAQ;IACnB;IACA,IAAI5D,IAAI,IAAIjD,GAAG,CAAC+G,IAAI,EAAE;MAClBF,QAAQ,CAAC7F,YAAY,GAAGvB,aAAa,CAACuH,oBAAoB;MAC1D,OAAOH,QAAQ;IACnB;IACAD,eAAe,GAAG5D,OAAO,GAAGC,IAAI;IAChC4D,QAAQ,GAAG,IAAI,CAACI,2BAA2B,CAAChE,IAAI,EAAE4D,QAAQ,EAAEF,YAAY,CAAC;IACzEE,QAAQ,CAAC1D,UAAU,GAAIH,OAAO,GAAG4D,eAAgB;IACjD,OAAOC,QAAQ;EACnB;EACA,OAAOlD,eAAe,GAAG;IACrB,IAAIuD,KAAK,GAAG,IAAI9G,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC5C,IAAIqD,MAAM,GAAG;MACTvD,UAAU,EAAE,CAAC;MACbC,UAAU,EAAE8D,KAAK;MACjB5D,aAAa,EAAE4D,KAAK;MACpB3D,cAAc,EAAE2D,KAAK;MACrB1D,aAAa,EAAE0D,KAAK;MACpBlG,YAAY,EAAEvB,aAAa,CAACwB,KAAK;MACjCwC,cAAc,EAAE;IACpB,CAAC;IACD,OAAOiD,MAAM;EACjB;EACA,OAAOO,2BAA2B,CAAClD,MAAM,EAAE2C,MAAM,EAAEC,YAAY,EAAE;IAC7D,IAAIC,eAAe,GAAG7C,MAAM;IAC5B,IAAIc,IAAI,GAAG,IAAIzE,UAAU,CAACsG,MAAM,CAACtD,UAAU,CAAC;IAC5C,IAAIc,EAAE,GAAGlE,GAAG,CAACmE,UAAU,CAACJ,MAAM,CAAC;IAC/B2C,MAAM,CAACjD,cAAc,GAAGS,EAAE,GAAG,IAAI;IACjC,IAAIyC,YAAY,EAAE;MACd,OAAOD,MAAM;IACjB;IACA3C,MAAM,EAAE;IACR,IAAKA,MAAM,IAAK/D,GAAG,CAACoF,MAAM,EAAE;MACxBsB,MAAM,CAAC1F,YAAY,GAAGvB,aAAa,CAAC4F,eAAe;MACnD,OAAOqB,MAAM;IACjB;IACA7G,MAAM,CAAE,QAAOD,KAAK,CAACsE,EAAE,CAAE,EAAC,CAAC;IAC3B,QAAQA,EAAE,GAAG,IAAI;MACb,KAAK,IAAI;QACLW,IAAI,GAAG,IAAI,CAACsC,SAAS,CAACpD,MAAM,CAAC;QAC7B2C,MAAM,CAACtD,UAAU,GAAGyB,IAAI;QACxB,OAAO6B,MAAM;MACjB,KAAK,IAAI;QACL7B,IAAI,GAAG,IAAI,CAACuC,SAAS,CAACrD,MAAM,CAAC;QAC7B2C,MAAM,CAACtD,UAAU,GAAGyB,IAAI;QACxB,OAAO6B,MAAM;MACjB,KAAK,IAAI;QACL7B,IAAI,GAAG,IAAI,CAACwC,SAAS,CAACtD,MAAM,CAAC;QAC7B2C,MAAM,CAACtD,UAAU,GAAGyB,IAAI;QACxB,OAAO6B,MAAM;MACjB,KAAK,IAAI;QACL7B,IAAI,GAAG,IAAI,CAACyC,SAAS,CAACvD,MAAM,CAAC;QAC7B2C,MAAM,CAAC1F,YAAY,GAAGvB,aAAa,CAAC8H,aAAa;QACjD,OAAOb,MAAM;MACjB,KAAK,IAAI;QACL7B,IAAI,GAAG,IAAI,CAAC2C,SAAS,CAACzD,MAAM,CAAC;QAC7B2C,MAAM,CAACtD,UAAU,GAAGyB,IAAI;QACxB,OAAO6B,MAAM;MACjB,KAAK,IAAI;QACL7B,IAAI,GAAG,IAAI,CAAC4C,SAAS,CAAC1D,MAAM,CAAC;QAC7B2C,MAAM,CAACtD,UAAU,GAAGyB,IAAI;QACxB,OAAO6B,MAAM;MACjB,KAAK,IAAI;QACL,MAAMgB,SAAS,GAAG,IAAI,CAACC,SAAS,CAAC5D,MAAM,CAAC;QACxC2C,MAAM,CAACtD,UAAU,GAAGsE,SAAS,CAAC,CAAC,CAAC;QAChChB,MAAM,CAACpD,aAAa,GAAGoE,SAAS,CAAC,CAAC,CAAC;QACnChB,MAAM,CAACnD,cAAc,GAAGmE,SAAS,CAAC,CAAC,CAAC;QACpChB,MAAM,CAACnD,cAAc,GAAGmE,SAAS,CAAC,CAAC,CAAC;QACpC,OAAOhB,MAAM;MACjB,KAAK,IAAI;QACL,MAAMkB,SAAS,GAAG,IAAI,CAACC,SAAS,CAAC9D,MAAM,CAAC;QACxC2C,MAAM,CAACtD,UAAU,GAAGwE,SAAS,CAAC,CAAC,CAAC;QAChClB,MAAM,CAACpD,aAAa,GAAGsE,SAAS,CAAC,CAAC,CAAC;QACnClB,MAAM,CAACnD,cAAc,GAAGqE,SAAS,CAAC,CAAC,CAAC;QACpClB,MAAM,CAACnD,cAAc,GAAGqE,SAAS,CAAC,CAAC,CAAC;QACpC,OAAOlB,MAAM;MACjB,KAAK,IAAI;QACL,MAAMoB,SAAS,GAAG,IAAI,CAACC,SAAS,CAAChE,MAAM,CAAC;QACxC2C,MAAM,CAACtD,UAAU,GAAG0E,SAAS,CAAC,CAAC,CAAC;QAChCpB,MAAM,CAACpD,aAAa,GAAGwE,SAAS,CAAC,CAAC,CAAC;QACnC,OAAOpB,MAAM;QACb;MACJ,KAAK,IAAI;QACL,MAAMsB,SAAS,GAAG,IAAI,CAACC,SAAS,CAAClE,MAAM,CAAC;QACxC2C,MAAM,CAACtD,UAAU,GAAG4E,SAAS,CAAC,CAAC,CAAC;QAChCtB,MAAM,CAACpD,aAAa,GAAG0E,SAAS,CAAC,CAAC,CAAC;QACnC,OAAOtB,MAAM;MACjB,KAAK,IAAI;QACL,MAAMwB,SAAS,GAAG,IAAI,CAACC,SAAS,CAACpE,MAAM,CAAC;QACxC2C,MAAM,CAACtD,UAAU,GAAG8E,SAAS,CAAC,CAAC,CAAC;QAChCxB,MAAM,CAACpD,aAAa,GAAG4E,SAAS,CAAC,CAAC,CAAC;QACnC,OAAOxB,MAAM;MACjB,KAAK,IAAI;QACL,MAAM0B,SAAS,GAAG,IAAI,CAACC,SAAS,CAACtE,MAAM,CAAC;QACxC2C,MAAM,CAACtD,UAAU,GAAGgF,SAAS,CAAC,CAAC,CAAC;QAChC1B,MAAM,CAACpD,aAAa,GAAG8E,SAAS,CAAC,CAAC,CAAC;QACnC,OAAO1B,MAAM;MACjB;QACI7G,MAAM,CAAE,sBAAqBqE,EAAG,EAAC,CAAC;QAClCwC,MAAM,CAACtD,UAAU,GAAGyB,IAAI;QACxB6B,MAAM,CAAC1F,YAAY,GAAGvB,aAAa,CAAC6I,OAAO;QAC3C5B,MAAM,CAACvD,UAAU,GAAGyD,eAAe,GAAG7C,MAAM;QAC5C,OAAO2C,MAAM;IAAC;IAEtB,IAAK3C,MAAM,IAAK/D,GAAG,CAACoF,MAAM,EAAE;MACxBsB,MAAM,CAAC1F,YAAY,GAAGvB,aAAa,CAAC4F,eAAe;MACnD,OAAOqB,MAAM;IACjB;IACAA,MAAM,CAAC1F,YAAY,GAAGvB,aAAa,CAACwB,KAAK;IACzC,OAAOyF,MAAM;EACjB;EACA,OAAOS,SAAS,CAACpD,MAAM,EAAE;IACrB,IAAIc,IAAI,GAAG,IAAIzE,UAAU,EAAE;IAC3B,IAAI6E,CAAC;IACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvF,GAAG,CAAC2D,YAAY,EAAE4B,CAAC,EAAE,EAAE;MACnCJ,IAAI,CAACI,CAAC,CAAC,GAAGjF,GAAG,CAACmE,UAAU,CAACJ,MAAM,GAAGkB,CAAC,CAAC;MACpC,IAAIlB,MAAM,GAAGkB,CAAC,IAAIjF,GAAG,CAACoF,MAAM,EAAE;QAC1B,OAAOP,IAAI;MACf;IACJ;IACA,OAAOA,IAAI;EACf;EACA,OAAOuC,SAAS,CAACrD,MAAM,EAAE;IACrB,OAAO,IAAI,CAACwE,aAAa,CAACxE,MAAM,EAAEzE,UAAU,CAACkJ,OAAO,CAAC;EACzD;EACA,OAAOnB,SAAS,CAACtD,MAAM,EAAE;IACrB,OAAO,IAAI,CAACwE,aAAa,CAACxE,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAOgD,aAAa,CAAC3D,SAAS,EAAE6D,IAAI,EAAE;IAClC,IAAItD,OAAO,GAAG,CAAC;IACf,IAAIN,IAAI,GAAG,IAAIzE,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC3C,IAAIa,EAAE;IACN,IAAIwE,eAAe;IACnB,IAAI1D,YAAY;IAChB0D,eAAe,GAAG1I,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IAC3CA,SAAS,EAAE;IACX,IAAKA,SAAS,IAAK5E,GAAG,CAACoF,MAAM,EAAE;MAC3B,OAAOP,IAAI;IACf;IACAG,YAAY,GAAG,CAAC;IAChBG,OAAO,GAAG,CAAC;IACX,GAAG;MACCjB,EAAE,GAAGlE,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;MAC9BA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAOP,IAAI;MACf;MACA,IAAIX,EAAE,IAAIwE,eAAe,EAAE;QACvB,IAAIC,MAAM,GAAG3I,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,IAAI+D,MAAM,GAAG5I,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,GAAG;UACC,MAAMnD,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEyD,MAAM,EAAEH,IAAI,CAAC;UACvFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;QAC5B,CAAC,QAAS,EAAEiH,MAAM,IAAM3D,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC5D,CAAC,MACI;QACD,MAAM3B,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEuE,IAAI,CAAC;QACnFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;QACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;QAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;MAC5B;IACJ,CAAC,QAAQsD,YAAY,GAAGtF,GAAG,CAAC2D,YAAY;IACxC,OAAOwB,IAAI;EACf;EACA,OAAOyC,SAAS,CAACvD,MAAM,EAAE;IACrB,OAAO,IAAI3D,UAAU,EAAE;EAC3B;EACA,OAAOoH,SAAS,CAACzD,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC8E,aAAa,CAAC9E,MAAM,EAAEzE,UAAU,CAACkJ,OAAO,CAAC;EACzD;EACA,OAAOf,SAAS,CAAC1D,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC8E,aAAa,CAAC9E,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAOsD,aAAa,CAACjE,SAAS,EAAE6D,IAAI,EAAE;IAClC,IAAI5D,IAAI,GAAG,IAAIzE,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC3C,IAAI8B,OAAO,GAAG,CAAC;IACf,IAAI2D,MAAM,GAAG;MACTC,QAAQ,EAAE,IAAI;MACdC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrCN,eAAe,EAAE1I,GAAG,CAACmE,UAAU,CAACS,SAAS;IAC7C,CAAC;IACD,IAAIV,EAAE;IACN,IAAIe,CAAC;IACL,IAAID,YAAY;IAChBA,YAAY,GAAG,CAAC;IAChBJ,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAOP,IAAI;IACf;IACA,KAAKI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACpB6D,MAAM,CAACE,WAAW,CAAC/D,CAAC,CAAC,GAAGjF,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;MACjDA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAOP,IAAI;MACf;IACJ;IACA,GAAG;MACC,MAAMnD,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;MAC9DkE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;MAClBwC,EAAE,GAAGxC,MAAM,CAAC,CAAC,CAAC;MACdkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;MACrB,IAAIkD,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAOP,IAAI;MACf;MACA,IAAIX,EAAE,IAAI4E,MAAM,CAACJ,eAAe,EAAE;QAC9B,MAAMzC,OAAO,GAAGhG,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;QAC/DkE,MAAM,GAAG7C,OAAO,CAAC,CAAC,CAAC;QACnB,IAAI0C,MAAM,GAAG1C,OAAO,CAAC,CAAC,CAAC;QACvBrB,SAAS,GAAGqB,OAAO,CAAC,CAAC,CAAC;QACtB,IAAIrB,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,MAAMqE,OAAO,GAAGjJ,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;QAC/DkE,MAAM,GAAGI,OAAO,CAAC,CAAC,CAAC;QACnB,IAAIN,MAAM,GAAGM,OAAO,CAAC,CAAC,CAAC;QACvBtE,SAAS,GAAGsE,OAAO,CAAC,CAAC,CAAC;QACtB,IAAItE,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzB,OAAOP,IAAI;QACf;QACA,GAAG;UACC,MAAMnD,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEyD,MAAM,EAAEH,IAAI,CAAC;UACvFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;QAC5B,CAAC,QAAS,EAAEiH,MAAM,IAAM3D,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC5D,CAAC,MACI;QACD,MAAM3B,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEuE,IAAI,CAAC;QACnFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;QACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;QAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;MAC5B;IACJ,CAAC,QAAQsD,YAAY,GAAGtF,GAAG,CAAC2D,YAAY;IACxC,IAAIyF,MAAM,CAACC,QAAQ,IAAI,IAAI,EAAE;MACzBnE,SAAS,EAAE;IACf;IACA,OAAOC,IAAI;EACf;EACA,OAAO8C,SAAS,CAAC5D,MAAM,EAAE;IACrB,OAAO,IAAI,CAACoF,aAAa,CAACpF,MAAM,EAAEzE,UAAU,CAACkJ,OAAO,CAAC;EACzD;EACA,OAAOX,SAAS,CAAC9D,MAAM,EAAE;IACrB,OAAO,IAAI,CAACoF,aAAa,CAACpF,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAO4D,aAAa,CAACvE,SAAS,EAAE6D,IAAI,EAAE;IAClC,IAAI5D,IAAI,GAAG,IAAIzE,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC3C,IAAI+F,QAAQ,GAAG,IAAIhJ,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC/C,IAAIgG,OAAO,GAAG,IAAIjJ,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC9C,IAAI8B,OAAO,GAAG,CAAC;IACf,IAAImE,WAAW,GAAG,CAAC;IACnB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIrF,EAAE;IACN,IAAIwE,eAAe;IACnB,IAAI1D,YAAY;IAChB,IAAIwE,eAAe;IACnB,IAAIC,cAAc;IAClBf,eAAe,GAAG1I,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IAC3CA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO,CAACP,IAAI,EAAEuE,QAAQ,EAAEC,OAAO,CAAC;IACpC;IACArE,YAAY,GAAGwE,eAAe,GAAGC,cAAc,GAAG,CAAC;IACnD,GAAG;MACCvF,EAAE,GAAGlE,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;MAC9BA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEuE,QAAQ,EAAEC,OAAO,CAAC;MACpC;MACA,IAAInF,EAAE,IAAIwE,eAAe,EAAE;QACvB,IAAIC,MAAM,GAAG3I,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzB,OAAO,CAACP,IAAI,EAAEuE,QAAQ,EAAEC,OAAO,CAAC;QACpC;QACA,IAAIT,MAAM,GAAG5I,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;QACtCA,SAAS,EAAE;QACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzB,OAAO,CAACP,IAAI,EAAEuE,QAAQ,EAAEC,OAAO,CAAC;QACpC;QACA,GAAG;UACC,MAAM3H,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAEsD,IAAI,CAAC;UACrFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMgI,cAAc,GAAGzJ,UAAU,CAACqF,kBAAkB,CAACkE,eAAe,EAAEJ,QAAQ,EAAEE,WAAW,EAAE,IAAI,EAAEb,IAAI,CAAC;UACxGa,WAAW,GAAGI,cAAc,CAAC,CAAC,CAAC;UAC/BN,QAAQ,GAAGM,cAAc,CAAC,CAAC,CAAC;UAC5BF,eAAe,GAAGE,cAAc,CAAC,CAAC,CAAC;UACnC,MAAMC,aAAa,GAAG1J,UAAU,CAACqF,kBAAkB,CAACmE,cAAc,EAAEJ,OAAO,EAAEE,UAAU,EAAEX,MAAM,EAAEH,IAAI,CAAC;UACtGc,UAAU,GAAGI,aAAa,CAAC,CAAC,CAAC;UAC7BN,OAAO,GAAGM,aAAa,CAAC,CAAC,CAAC;UAC1BF,cAAc,GAAGE,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAEhB,MAAM,IAAM3D,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC5D,CAAC,MACI;QACD,MAAM3B,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEuE,IAAI,CAAC;QACnFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;QACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;QAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;QACxB,MAAMgI,cAAc,GAAGzJ,UAAU,CAACqF,kBAAkB,CAACkE,eAAe,EAAEJ,QAAQ,EAAEE,WAAW,EAAE,IAAI,EAAEb,IAAI,CAAC;QACxGa,WAAW,GAAGI,cAAc,CAAC,CAAC,CAAC;QAC/BN,QAAQ,GAAGM,cAAc,CAAC,CAAC,CAAC;QAC5BF,eAAe,GAAGE,cAAc,CAAC,CAAC,CAAC;QACnC,MAAMC,aAAa,GAAG1J,UAAU,CAACqF,kBAAkB,CAACmE,cAAc,EAAEJ,OAAO,EAAEE,UAAU,EAAE,IAAI,EAAEd,IAAI,CAAC;QACpGc,UAAU,GAAGI,aAAa,CAAC,CAAC,CAAC;QAC7BN,OAAO,GAAGM,aAAa,CAAC,CAAC,CAAC;QAC1BF,cAAc,GAAGE,aAAa,CAAC,CAAC,CAAC;MACrC;IACJ,CAAC,QAAQ3E,YAAY,GAAGtF,GAAG,CAAC2D,YAAY;IACxC,OAAO,CAACwB,IAAI,EAAEuE,QAAQ,EAAEC,OAAO,CAAC;EACpC;EACA,OAAOtB,SAAS,CAAChE,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC6F,aAAa,CAAC7F,MAAM,EAAEzE,UAAU,CAACkJ,OAAO,CAAC;EACzD;EACA,OAAOP,SAAS,CAAClE,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC6F,aAAa,CAAC7F,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAOqE,aAAa,CAAChF,SAAS,EAAE6D,IAAI,EAAE;IAClC,IAAItD,OAAO,GAAG,CAAC;IACf,IAAIN,IAAI,GAAG,IAAIzE,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC3C,IAAIwG,UAAU,GAAG,CAAC;IAClB,IAAIC,OAAO,GAAG,IAAI1J,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC9C,IAAI7C,KAAK;IACT,IAAIuJ,OAAO;IACX,IAAI/E,YAAY;IAChB,IAAIgF,cAAc;IAClB,IAAIC,eAAe,GAAG,IAAI;IAC1B,SAASC,WAAW,GAAG;MACnB1J,KAAK,GAAGR,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;MACjCA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;MAC1B;MACA,IAAItJ,KAAK,EAAE;QACP,GAAG;UACC,MAAMkB,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAEsD,IAAI,CAAC;UACrFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMyI,aAAa,GAAGlK,UAAU,CAACqF,kBAAkB,CAAC0E,cAAc,EAAEF,OAAO,EAAED,UAAU,EAAE,IAAI,EAAEpB,IAAI,CAAC;UACpGoB,UAAU,GAAGM,aAAa,CAAC,CAAC,CAAC;UAC7BL,OAAO,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAE3J,KAAK,IAAMwE,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC3D;MACA,IAAI2B,YAAY,IAAItF,GAAG,CAAC2D,YAAY,EAAE;QAClC4G,eAAe,GAAG,KAAK;MAC3B;IACJ;IACAzJ,KAAK,GAAGoE,SAAS;IACjBpE,KAAK,GAAGR,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;IACjCA,SAAS,EAAE;IACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;IAC1B;IACA9E,YAAY,GAAGgF,cAAc,GAAG,CAAC;IACjC,IAAI,CAACxJ,KAAK,EAAE;MACR0J,WAAW,EAAE;IACjB;IACA,OAAOD,eAAe,EAAE;MACpBzJ,KAAK,GAAGR,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;MACjCA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;MAC1B;MACA,IAAItJ,KAAK,EAAE;QACP,GAAG;UACCuJ,OAAO,GAAG/J,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;UACnCA,SAAS,EAAE;UACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;YACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;UAC1B;UACA,MAAMpI,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE4E,OAAO,EAAEtB,IAAI,CAAC;UACxFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMyI,aAAa,GAAGlK,UAAU,CAACqF,kBAAkB,CAAC0E,cAAc,EAAEF,OAAO,EAAED,UAAU,EAAE,IAAI,EAAEpB,IAAI,CAAC;UACpGoB,UAAU,GAAGM,aAAa,CAAC,CAAC,CAAC;UAC7BL,OAAO,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAE3J,KAAK,IAAMwE,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC3D;MACA,IAAI2B,YAAY,IAAItF,GAAG,CAAC2D,YAAY,EAAE;QAClC4G,eAAe,GAAG,KAAK;MAC3B;MACA,IAAIA,eAAe,EAAE;QACjBC,WAAW,EAAE;MACjB;IACJ;IACA,OAAO,CAACrF,IAAI,EAAEiF,OAAO,CAAC;EAC1B;EACA,OAAO3B,SAAS,CAACpE,MAAM,EAAE;IACrB,OAAO9D,UAAU,CAACmK,aAAa,CAACrG,MAAM,EAAEzE,UAAU,CAACkJ,OAAO,CAAC;EAC/D;EACA,OAAOH,SAAS,CAACtE,MAAM,EAAE;IACrB,OAAO,IAAI,CAACqG,aAAa,CAACrG,MAAM,EAAEzE,UAAU,CAACiG,IAAI,CAAC;EACtD;EACA,OAAO6E,aAAa,CAACxF,SAAS,EAAE6D,IAAI,EAAE;IAClC,IAAItD,OAAO,GAAG,CAAC;IACf,IAAIN,IAAI,GAAG,IAAIzE,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC3C,IAAIwG,UAAU,GAAG,CAAC;IAClB,IAAIC,OAAO,GAAG,IAAI1J,UAAU,CAACV,GAAG,CAAC2D,YAAY,CAAC;IAC9C,IAAIyF,MAAM,GAAG;MACTC,QAAQ,EAAE,IAAI;MACdC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrCN,eAAe,EAAE;IACrB,CAAC;IACD,IAAIlI,KAAK;IACT,IAAIyE,CAAC;IACL,IAAID,YAAY;IAChB,IAAIgF,cAAc;IAClB,IAAIC,eAAe,GAAG,IAAI;IAC1BnB,MAAM,CAACC,QAAQ,GAAG,IAAI;IACtB/D,YAAY,GAAGgF,cAAc,GAAG,CAAC;IACjC,SAASK,SAAS,GAAG;MACjB,MAAM3I,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;MAC9DkE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;MAClBlB,KAAK,GAAGkB,MAAM,CAAC,CAAC,CAAC;MACjBkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;MACrB,IAAIkD,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;MAC1B;MACA,IAAItJ,KAAK,EAAE;QACP,GAAG;UACC,MAAMkB,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAE,IAAI,EAAEsD,IAAI,CAAC;UACrFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UACxB,MAAMyI,aAAa,GAAGlK,UAAU,CAACqF,kBAAkB,CAAC0E,cAAc,EAAEF,OAAO,EAAED,UAAU,EAAE,IAAI,EAAEpB,IAAI,CAAC;UACpGoB,UAAU,GAAGM,aAAa,CAAC,CAAC,CAAC;UAC7BL,OAAO,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAE3J,KAAK,IAAMwE,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC3D;MACA,IAAI2B,YAAY,IAAItF,GAAG,CAAC2D,YAAY,EAAE;QAClC4G,eAAe,GAAG,KAAK;QACvB,OAAO,CAACpF,IAAI,EAAEiF,OAAO,CAAC;MAC1B;MACA,OAAO,CAACjF,IAAI,EAAEiF,OAAO,CAAC;IAC1B;IACA,KAAK7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACpB6D,MAAM,CAACE,WAAW,CAAC/D,CAAC,CAAC,GAAGjF,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC;MACjDA,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;MAC1B;IACJ;IACA,MAAMpI,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;IAC9DkE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;IAClBlB,KAAK,GAAGkB,MAAM,CAAC,CAAC,CAAC;IACjBkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;IACrB,IAAIkD,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;IAC1B;IACA,IAAI,CAACtJ,KAAK,EAAE;MACR6J,SAAS,EAAE;IACf;IACA,OAAOJ,eAAe,EAAE;MACpB,MAAMvI,MAAM,GAAGzB,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;MAC9DkE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;MAClBlB,KAAK,GAAGkB,MAAM,CAAC,CAAC,CAAC;MACjBkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;MACrB,IAAIkD,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;MAC1B;MACA,IAAItJ,KAAK,EAAE;QACP,GAAG;UACC,MAAM8J,UAAU,GAAGrK,UAAU,CAACgJ,iBAAiB,CAACH,MAAM,EAAElE,SAAS,CAAC;UAClEkE,MAAM,GAAGwB,UAAU,CAAC,CAAC,CAAC;UACtB,MAAMC,IAAI,GAAGD,UAAU,CAAC,CAAC,CAAC;UAC1B1F,SAAS,GAAG0F,UAAU,CAAC,CAAC,CAAC;UACzB,MAAM5I,MAAM,GAAGzB,UAAU,CAACqF,kBAAkB,CAACN,YAAY,EAAEH,IAAI,EAAEM,OAAO,EAAEoF,IAAI,EAAE9B,IAAI,CAAC;UACrFtD,OAAO,GAAGzD,MAAM,CAAC,CAAC,CAAC;UACnBmD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;UAChBsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;UACxB,IAAIkD,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;YACzB,OAAO,CAACP,IAAI,EAAEiF,OAAO,CAAC;UAC1B;UACA,MAAMK,aAAa,GAAGlK,UAAU,CAACqF,kBAAkB,CAAC0E,cAAc,EAAEF,OAAO,EAAED,UAAU,EAAE,IAAI,EAAEpB,IAAI,CAAC;UACpGoB,UAAU,GAAGM,aAAa,CAAC,CAAC,CAAC;UAC7BL,OAAO,GAAGK,aAAa,CAAC,CAAC,CAAC;UAC1BH,cAAc,GAAGG,aAAa,CAAC,CAAC,CAAC;QACrC,CAAC,QAAS,EAAE3J,KAAK,IAAMwE,YAAY,GAAGtF,GAAG,CAAC2D,YAAa;MAC3D;MACA,IAAI2B,YAAY,IAAItF,GAAG,CAAC2D,YAAY,EAAE;QAClC4G,eAAe,GAAG,KAAK;MAC3B;MACAI,SAAS,EAAE;IACf;IACA,IAAIvB,MAAM,CAACC,QAAQ,IAAI,IAAI,EAAE;MACzBnE,SAAS,EAAE;IACf;IACA,OAAO,CAACC,IAAI,EAAEiF,OAAO,CAAC;EAC1B;EACA,OAAOxE,kBAAkB,CAACkF,eAAe,EAAE3F,IAAI,EAAEM,OAAO,EAAEjB,EAAE,EAAEuE,IAAI,EAAE;IAChE5D,IAAI,CAAC4F,GAAG,CAAC,CAACvG,EAAE,CAAC,EAAEiB,OAAO,CAAC;IACvBqF,eAAe,EAAE;IACjB,IAAKA,eAAe,IAAK9K,GAAG,CAAC2D,YAAY,EAAE;MACvC,OAAO,CAAC8B,OAAO,EAAEN,IAAI,EAAE2F,eAAe,CAAC;IAC3C;IACA,IAAI/B,IAAI,IAAInJ,UAAU,CAACiG,IAAI,EAAE;MACzBJ,OAAO,EAAE;MACT,OAAO,CAACA,OAAO,EAAEN,IAAI,EAAE2F,eAAe,CAAC;IAC3C;IACA,IAAI,EAAEA,eAAe,GAAI9K,GAAG,CAAC6B,OAAQ,CAAC,EAAE;MACpC4D,OAAO,IAAOzF,GAAG,CAACyB,OAAO,GAAG,CAAC,IAAKzB,GAAG,CAAC6B,OAAO,GAAG,CAAC,CAAC,IAAM7B,GAAG,CAACyB,OAAO,GAAG,CAAC,GAAI,CAAC,CAAE;IAClF,CAAC,MACI;MACDgE,OAAO,IAAKzF,GAAG,CAACyB,OAAO,GAAG,CAAE;IAChC;IACA,OAAO,CAACgE,OAAO,EAAEN,IAAI,EAAE2F,eAAe,CAAC;EAC3C;EACA,OAAOvB,iBAAiB,CAACH,MAAM,EAAElE,SAAS,EAAE;IACxC,IAAI8F,YAAY;IAChB,MAAMhJ,MAAM,GAAGzB,UAAU,CAAC0K,WAAW,CAAC7B,MAAM,EAAElE,SAAS,CAAC;IACxD,IAAIV,EAAE,GAAGxC,MAAM,CAAC,CAAC,CAAC;IAClBoH,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;IAClBkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;IACrB,IAAIkD,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;MACzBsF,YAAY,GAAG,CAAC5B,MAAM,EAAE,IAAI,EAAElE,SAAS,CAAC;MACxC,OAAO8F,YAAY;IACvB;IACA,IAAIE,SAAS;IACb,IAAIC,WAAW;IACf,IAAI5F,CAAC;IACL,IAAIf,EAAE,EAAE;MACJ,IAAI4G,SAAS,GAAG,CAAC;MACjB,KAAK7F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACpB,MAAMvD,MAAM,GAAGzB,UAAU,CAAC0K,WAAW,CAAC7B,MAAM,EAAElE,SAAS,CAAC;QACxDkE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;QAClBkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;QACrB,IAAIA,MAAM,CAAC,CAAC,CAAC,EAAE;UACXoJ,SAAS,EAAE;QACf,CAAC,MACI;UACD7F,CAAC,GAAG,CAAC;QACT;QACA,IAAIL,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzBsF,YAAY,GAAG,CAAC5B,MAAM,EAAE,IAAI,EAAElE,SAAS,CAAC;UACxC,OAAO8F,YAAY;QACvB;MACJ;MACAG,WAAW,GAAG/B,MAAM,CAACE,WAAW,CAAC8B,SAAS,CAAC;IAC/C,CAAC,MACI;MACDF,SAAS,GAAG,IAAI;MAChBC,WAAW,GAAG,IAAI;MAClB,KAAK5F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACpB,MAAMvD,MAAM,GAAGzB,UAAU,CAAC0K,WAAW,CAAC7B,MAAM,EAAElE,SAAS,CAAC;QACxDkE,MAAM,GAAGpH,MAAM,CAAC,CAAC,CAAC;QAClBkD,SAAS,GAAGlD,MAAM,CAAC,CAAC,CAAC;QACrB,IAAIA,MAAM,CAAC,CAAC,CAAC,EAAE;UACXmJ,WAAW,IAAID,SAAS;QAC5B;QACA,IAAIhG,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;UACzBsF,YAAY,GAAG,CAAC5B,MAAM,EAAE,IAAI,EAAElE,SAAS,CAAC;UACxC,OAAO8F,YAAY;QACvB;QACAE,SAAS,KAAK,CAAC;MACnB;IACJ;IACAF,YAAY,GAAG,CAAC5B,MAAM,EAAE+B,WAAW,EAAEjG,SAAS,CAAC;IAC/C,OAAQ8F,YAAY;EACxB;EACA,OAAOC,WAAW,CAAC7B,MAAM,EAAElE,SAAS,EAAE;IAClC,IAAI8F,YAAY;IAChB,IAAIxG,EAAE,GAAIlE,GAAG,CAACmE,UAAU,CAACS,SAAS,CAAC,GAAGkE,MAAM,CAACC,QAAS;IACtD,IAAI,EAAED,MAAM,CAACC,QAAQ,KAAK,CAAC,CAAC,EAAE;MAC1BD,MAAM,CAACC,QAAQ,GAAG,IAAI;MACtBnE,SAAS,EAAE;MACX,IAAIA,SAAS,IAAI5E,GAAG,CAACoF,MAAM,EAAE;QACzBsF,YAAY,GAAG,CAAC,IAAI,EAAE5B,MAAM,EAAElE,SAAS,CAAC;QACxC,OAAO8F,YAAY;MACvB;IACJ;IACAA,YAAY,GAAG,CAACxG,EAAE,EAAE4E,MAAM,EAAElE,SAAS,CAAC;IACtC,OAAO8F,YAAY;EACvB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}