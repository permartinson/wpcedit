{"ast":null,"code":"import { toHex, logStr } from \"../resources/Helpers.js\";\nimport { ROM } from \"../stores/ROM.js\";\nimport { WPC } from \"../resources/Constants.js\";\nexport class Checksum {\n  constructor() {}\n  static get stored() {\n    return ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.ChecksumOffset) * 256 + ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.ChecksumOffset + 1);\n  }\n  static getRomDelta() {\n    return ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.DeltaOffset) * 256 + ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.DeltaOffset + 1);\n  }\n  static get calculated() {\n    let checksum = 0;\n    for (let i = 0; i < ROM.size; i++) {\n      checksum += ROM.byteAtAddr(i);\n    }\n    checksum %= 65536;\n    return checksum;\n  }\n  static get delta() {\n    return this.getRomDelta();\n  }\n  static byteSumOf16bitVal(value) {\n    value &= 0xFFFF;\n    const highByte = value >> 8 & 0xFF;\n    const lowByte = value & 0xFF;\n    return highByte + lowByte;\n  }\n  static subtractChecksumAndDeltaBytes(checksum) {\n    const romDelta = this.getRomDelta();\n    const storedChecksum = this.stored;\n    return checksum - this.byteSumOf16bitVal(romDelta) - this.byteSumOf16bitVal(storedChecksum);\n  }\n  static disable() {\n    const romDelta = this.getRomDelta();\n    const romData = ROM.data;\n    if (romDelta != 0x00FF) {\n      romData.set([0x00, 0xFF], ROM.nonPagedBankAddr + WPC.DeltaOffset);\n      logStr(\"ROM modified to disable checksum.\");\n    }\n    return romData;\n  }\n  static update(version, baseDelta = 0, force = false) {\n    version &= version;\n    version = parseInt(version.toString(), 16);\n    const romData = ROM.data;\n    const clearedChecksum = this.subtractChecksumAndDeltaBytes(this.calculated);\n    let newChecksum = 0;\n    let newDelta = 0;\n    let checksumFound = false;\n    if (this.stored == this.calculated && version == (this.stored & 0xFF) && !force) {\n      logStr(\"The checksum of the ROM is correct, no need to update\");\n    } else {\n      logStr(\"Trying to figure out a new checksum and delta\");\n      for (let delta = this.delta; delta < 0xFFFF && !checksumFound; delta++) {\n        if (delta != 0x00FF) {\n          for (let highByte = 0; highByte < 0xFF && !checksumFound; highByte++) {\n            const checksum = (highByte << 8) + version;\n            if (clearedChecksum + this.byteSumOf16bitVal(delta) + highByte + version == checksum) {\n              checksumFound = true;\n              newChecksum = checksum;\n              newDelta = delta;\n              logStr(`New checksum is ${toHex(newChecksum)} and delta is ${toHex(newDelta)}`);\n            }\n          }\n        }\n      }\n      if (!checksumFound) {\n        logStr(`Error: Could not figure out a new checksum`);\n        return;\n      }\n    }\n    romData.set([newDelta >> 8 & 0xFF, newDelta & 0xFF], ROM.nonPagedBankAddr + WPC.DeltaOffset);\n    romData.set([newChecksum >> 8 & 0xFF, newChecksum & 0xFF], ROM.nonPagedBankAddr + WPC.ChecksumOffset);\n    return romData;\n  }\n  static get isValid() {\n    return this.calculated == this.stored;\n  }\n}","map":{"version":3,"names":["toHex","logStr","ROM","WPC","Checksum","constructor","stored","byteAtAddr","nonPagedBankAddr","ChecksumOffset","getRomDelta","DeltaOffset","calculated","checksum","i","size","delta","byteSumOf16bitVal","value","highByte","lowByte","subtractChecksumAndDeltaBytes","romDelta","storedChecksum","disable","romData","data","set","update","version","baseDelta","force","parseInt","toString","clearedChecksum","newChecksum","newDelta","checksumFound","isValid"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit-vue/node_modules/wpcedit/dist/src/classes/Checksum.js"],"sourcesContent":["import { toHex, logStr } from \"../resources/Helpers.js\";\nimport { ROM } from \"../stores/ROM.js\";\nimport { WPC } from \"../resources/Constants.js\";\nexport class Checksum {\n    constructor() {\n    }\n    static get stored() {\n        return ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.ChecksumOffset) * 256 + ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.ChecksumOffset + 1);\n    }\n    static getRomDelta() {\n        return ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.DeltaOffset) * 256 + ROM.byteAtAddr(ROM.nonPagedBankAddr + WPC.DeltaOffset + 1);\n    }\n    static get calculated() {\n        let checksum = 0;\n        for (let i = 0; i < ROM.size; i++) {\n            checksum += ROM.byteAtAddr(i);\n        }\n        checksum %= 65536;\n        return checksum;\n    }\n    static get delta() {\n        return this.getRomDelta();\n    }\n    static byteSumOf16bitVal(value) {\n        value &= 0xFFFF;\n        const highByte = (value >> 8) & 0xFF;\n        const lowByte = value & 0xFF;\n        return highByte + lowByte;\n    }\n    static subtractChecksumAndDeltaBytes(checksum) {\n        const romDelta = this.getRomDelta();\n        const storedChecksum = this.stored;\n        return checksum - this.byteSumOf16bitVal(romDelta) - this.byteSumOf16bitVal(storedChecksum);\n    }\n    static disable() {\n        const romDelta = this.getRomDelta();\n        const romData = ROM.data;\n        if ((romDelta != 0x00FF)) {\n            romData.set([0x00, 0xFF], ROM.nonPagedBankAddr + WPC.DeltaOffset);\n            logStr(\"ROM modified to disable checksum.\");\n        }\n        return romData;\n    }\n    static update(version, baseDelta = 0, force = false) {\n        version &= version;\n        version = parseInt(version.toString(), 16);\n        const romData = ROM.data;\n        const clearedChecksum = this.subtractChecksumAndDeltaBytes(this.calculated);\n        let newChecksum = 0;\n        let newDelta = 0;\n        let checksumFound = false;\n        if (((this.stored == this.calculated) && version == (this.stored & 0xFF)) && !force) {\n            logStr(\"The checksum of the ROM is correct, no need to update\");\n        }\n        else {\n            logStr(\"Trying to figure out a new checksum and delta\");\n            for (let delta = this.delta; delta < 0xFFFF && !checksumFound; delta++) {\n                if (delta != 0x00FF) {\n                    for (let highByte = 0; highByte < 0xFF && !checksumFound; highByte++) {\n                        const checksum = (highByte << 8) + version;\n                        if ((clearedChecksum + this.byteSumOf16bitVal(delta) + highByte + version) == checksum) {\n                            checksumFound = true;\n                            newChecksum = checksum;\n                            newDelta = delta;\n                            logStr(`New checksum is ${toHex(newChecksum)} and delta is ${toHex(newDelta)}`);\n                        }\n                    }\n                }\n            }\n            if (!checksumFound) {\n                logStr(`Error: Could not figure out a new checksum`);\n                return;\n            }\n        }\n        romData.set([(newDelta >> 8) & 0xFF, newDelta & 0xFF], ROM.nonPagedBankAddr + WPC.DeltaOffset);\n        romData.set([(newChecksum >> 8) & 0xFF, newChecksum & 0xFF], ROM.nonPagedBankAddr + WPC.ChecksumOffset);\n        return (romData);\n    }\n    static get isValid() {\n        return (this.calculated == this.stored);\n    }\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,MAAM,QAAQ,yBAAyB;AACvD,SAASC,GAAG,QAAQ,kBAAkB;AACtC,SAASC,GAAG,QAAQ,2BAA2B;AAC/C,OAAO,MAAMC,QAAQ,CAAC;EAClBC,WAAW,GAAG,CACd;EACA,WAAWC,MAAM,GAAG;IAChB,OAAOJ,GAAG,CAACK,UAAU,CAACL,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACM,cAAc,CAAC,GAAG,GAAG,GAAGP,GAAG,CAACK,UAAU,CAACL,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACM,cAAc,GAAG,CAAC,CAAC;EAC1I;EACA,OAAOC,WAAW,GAAG;IACjB,OAAOR,GAAG,CAACK,UAAU,CAACL,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACQ,WAAW,CAAC,GAAG,GAAG,GAAGT,GAAG,CAACK,UAAU,CAACL,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACQ,WAAW,GAAG,CAAC,CAAC;EACpI;EACA,WAAWC,UAAU,GAAG;IACpB,IAAIC,QAAQ,GAAG,CAAC;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,GAAG,CAACa,IAAI,EAAED,CAAC,EAAE,EAAE;MAC/BD,QAAQ,IAAIX,GAAG,CAACK,UAAU,CAACO,CAAC,CAAC;IACjC;IACAD,QAAQ,IAAI,KAAK;IACjB,OAAOA,QAAQ;EACnB;EACA,WAAWG,KAAK,GAAG;IACf,OAAO,IAAI,CAACN,WAAW,EAAE;EAC7B;EACA,OAAOO,iBAAiB,CAACC,KAAK,EAAE;IAC5BA,KAAK,IAAI,MAAM;IACf,MAAMC,QAAQ,GAAID,KAAK,IAAI,CAAC,GAAI,IAAI;IACpC,MAAME,OAAO,GAAGF,KAAK,GAAG,IAAI;IAC5B,OAAOC,QAAQ,GAAGC,OAAO;EAC7B;EACA,OAAOC,6BAA6B,CAACR,QAAQ,EAAE;IAC3C,MAAMS,QAAQ,GAAG,IAAI,CAACZ,WAAW,EAAE;IACnC,MAAMa,cAAc,GAAG,IAAI,CAACjB,MAAM;IAClC,OAAOO,QAAQ,GAAG,IAAI,CAACI,iBAAiB,CAACK,QAAQ,CAAC,GAAG,IAAI,CAACL,iBAAiB,CAACM,cAAc,CAAC;EAC/F;EACA,OAAOC,OAAO,GAAG;IACb,MAAMF,QAAQ,GAAG,IAAI,CAACZ,WAAW,EAAE;IACnC,MAAMe,OAAO,GAAGvB,GAAG,CAACwB,IAAI;IACxB,IAAKJ,QAAQ,IAAI,MAAM,EAAG;MACtBG,OAAO,CAACE,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAEzB,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACQ,WAAW,CAAC;MACjEV,MAAM,CAAC,mCAAmC,CAAC;IAC/C;IACA,OAAOwB,OAAO;EAClB;EACA,OAAOG,MAAM,CAACC,OAAO,EAAEC,SAAS,GAAG,CAAC,EAAEC,KAAK,GAAG,KAAK,EAAE;IACjDF,OAAO,IAAIA,OAAO;IAClBA,OAAO,GAAGG,QAAQ,CAACH,OAAO,CAACI,QAAQ,EAAE,EAAE,EAAE,CAAC;IAC1C,MAAMR,OAAO,GAAGvB,GAAG,CAACwB,IAAI;IACxB,MAAMQ,eAAe,GAAG,IAAI,CAACb,6BAA6B,CAAC,IAAI,CAACT,UAAU,CAAC;IAC3E,IAAIuB,WAAW,GAAG,CAAC;IACnB,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIC,aAAa,GAAG,KAAK;IACzB,IAAM,IAAI,CAAC/B,MAAM,IAAI,IAAI,CAACM,UAAU,IAAKiB,OAAO,KAAK,IAAI,CAACvB,MAAM,GAAG,IAAI,CAAC,IAAK,CAACyB,KAAK,EAAE;MACjF9B,MAAM,CAAC,uDAAuD,CAAC;IACnE,CAAC,MACI;MACDA,MAAM,CAAC,+CAA+C,CAAC;MACvD,KAAK,IAAIe,KAAK,GAAG,IAAI,CAACA,KAAK,EAAEA,KAAK,GAAG,MAAM,IAAI,CAACqB,aAAa,EAAErB,KAAK,EAAE,EAAE;QACpE,IAAIA,KAAK,IAAI,MAAM,EAAE;UACjB,KAAK,IAAIG,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAG,IAAI,IAAI,CAACkB,aAAa,EAAElB,QAAQ,EAAE,EAAE;YAClE,MAAMN,QAAQ,GAAG,CAACM,QAAQ,IAAI,CAAC,IAAIU,OAAO;YAC1C,IAAKK,eAAe,GAAG,IAAI,CAACjB,iBAAiB,CAACD,KAAK,CAAC,GAAGG,QAAQ,GAAGU,OAAO,IAAKhB,QAAQ,EAAE;cACpFwB,aAAa,GAAG,IAAI;cACpBF,WAAW,GAAGtB,QAAQ;cACtBuB,QAAQ,GAAGpB,KAAK;cAChBf,MAAM,CAAE,mBAAkBD,KAAK,CAACmC,WAAW,CAAE,iBAAgBnC,KAAK,CAACoC,QAAQ,CAAE,EAAC,CAAC;YACnF;UACJ;QACJ;MACJ;MACA,IAAI,CAACC,aAAa,EAAE;QAChBpC,MAAM,CAAE,4CAA2C,CAAC;QACpD;MACJ;IACJ;IACAwB,OAAO,CAACE,GAAG,CAAC,CAAES,QAAQ,IAAI,CAAC,GAAI,IAAI,EAAEA,QAAQ,GAAG,IAAI,CAAC,EAAElC,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACQ,WAAW,CAAC;IAC9Fc,OAAO,CAACE,GAAG,CAAC,CAAEQ,WAAW,IAAI,CAAC,GAAI,IAAI,EAAEA,WAAW,GAAG,IAAI,CAAC,EAAEjC,GAAG,CAACM,gBAAgB,GAAGL,GAAG,CAACM,cAAc,CAAC;IACvG,OAAQgB,OAAO;EACnB;EACA,WAAWa,OAAO,GAAG;IACjB,OAAQ,IAAI,CAAC1B,UAAU,IAAI,IAAI,CAACN,MAAM;EAC1C;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}