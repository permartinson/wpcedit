{"ast":null,"code":"import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n  constructor() {\n    this.PreviousPlaneDataPane0 = new Uint8Array();\n    this.PreviousPlaneDataPane1 = new Uint8Array();\n  }\n  init() {}\n  static decodeNextIndex(count, dataType) {\n    switch (dataType) {\n      case DataTypes.Graphics:\n        while (count--) {\n          {\n            FullFrameImageData.CurrentImageIndex++;\n          }\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageXShift + WPC.DmdCols < VariableSizedImageData.CurrentImageXSize) {\n            VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount * count;\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageYShift + WPC.DmdRows < VariableSizedImageData.CurrentImageYSize) {\n            VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount * count;\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {\n            logStr(`Unexpected error advancing image indexes`);\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0];\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xff) < (tmpImageIndex & 0xff)) {\n      pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n      pTableIndex++;\n      pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [0, 0];\n  }\n  static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n    let tmpImageIndex;\n    if (pTableIndex == null || pImageIndex == null) {\n      return [-1, -1];\n    }\n    tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n    if (tmpImageIndex == -1) {\n      return [-1, -1];\n    }\n    if ((pImageIndex & 0xff) > (tmpImageIndex & 0xff)) {\n      pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n      if (pImageIndex == -1) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    if (pTableIndex > VariableSizedImageData.minTableIndex) {\n      pTableIndex = pTableIndex - 1;\n      if (DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0] != 0) {\n        return [-1, -1];\n      }\n      return [pTableIndex, pImageIndex];\n    }\n    return [pTableIndex, pImageIndex];\n  }\n  static decodePreviousIndex(count, dataType) {\n    switch (dataType) {\n      case DataTypes.Graphics:\n        while (count-- && FullFrameImageData.CurrentImageIndex) {\n          FullFrameImageData.CurrentImageIndex--;\n        }\n        break;\n      case DataTypes.FontData:\n      case DataTypes.AniData:\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status == PlaneStatuses.Valid) {\n          if (VariableSizedImageData.CurrentImageYShift > 0) {\n            VariableSizedImageData.CurrentImageYShift -= WPC.ImageShiftYPixelCount * count;\n            if (VariableSizedImageData.CurrentImageYShift < 0) {\n              VariableSizedImageData.CurrentImageYShift = 0;\n            }\n            break;\n          }\n          if (VariableSizedImageData.CurrentImageXShift > 0) {\n            VariableSizedImageData.CurrentImageXShift -= WPC.ImageShiftXPixelCount * count;\n            if (VariableSizedImageData.CurrentImageXShift < 0) {\n              VariableSizedImageData.CurrentImageXShift = 0;\n            }\n            break;\n          }\n        }\n        VariableSizedImageData.CurrentImageXShift = -1;\n        VariableSizedImageData.CurrentImageYShift = -1;\n        while (count--) {\n          const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n          VariableSizedImageData.CurrentTableIndex = result[0];\n          VariableSizedImageData.CurrentImageIndex = result[1];\n          if (result[0] == -1) {}\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  static decodeFullFrameGraphic(GraphicIndex) {\n    FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n    FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane(GraphicIndex + 1);\n  }\n  static decodeVariableSizedImageData() {\n    const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n    VariableSizedImageData.Planes = result[1];\n    if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n      VariableSizedImageData.CurrentImageXSize = 0;\n      VariableSizedImageData.CurrentImageYSize = 0;\n      VariableSizedImageData.CurrentImageXShift = 0;\n      VariableSizedImageData.CurrentImageYShift = 0;\n    }\n  }\n  static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n    let DataPtr;\n    let Addr;\n    let pPlanes = {\n      Plane0: DmdDecoder.decodePlaneInit(),\n      Plane1: DmdDecoder.decodePlaneInit()\n    };\n    VariableSizedImageData.CurrentImageXSize = 0;\n    VariableSizedImageData.CurrentImageYSize = 0;\n    Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n    VariableSizedImageData.Address = Addr;\n    if (Addr == -1) {\n      pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n      pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n      return [-1, pPlanes];\n    }\n    DataPtr = Addr;\n    pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n    let TableHeight;\n    let TableSpacing;\n    VariableSizedImageData.Address = Source;\n    let ch = ROM.byteAtAddr(Source);\n    const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n    TableHeight = result[0];\n    TableSpacing = result[1];\n    if (TableHeight == -1) {\n      logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n      return [-1, pPlanes];\n    }\n    if (ch > 0 && ch <= WPC.DmdCols) {\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n    } else {\n      switch (ch) {\n        case ImageCodes.Monochrome:\n        case ImageCodes.BicolorIndirect:\n        case ImageCodes.BicolorDirect:\n        case ImageCodes.FD:\n          break;\n        default:\n          logStr(`Unrecognized Header Byte ${ch}`);\n          break;\n      }\n      pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n    }\n    return [0, pPlanes];\n  }\n  static decodeVariableSizedImageToBits(SourcePtr, Dest, ImageHeight, ImageWidth, Centered = false) {\n    let ch;\n    let WriteCounter = 0;\n    let i, j;\n    let DestPtr = 0;\n    Dest = new Uint8Array(Math.ceil(Math.ceil(ImageWidth / 8) * 8 * ImageHeight) / 8);\n    if (SourcePtr >= ROM.endPtr) {\n      return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n    }\n    if (VariableSizedImageData.CurrentImageYShift == -1) {\n      VariableSizedImageData.CurrentImageYShift = 0;\n      while (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift < ImageHeight) {\n        VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n      }\n    }\n    if (VariableSizedImageData.CurrentImageXShift == -1) {\n      VariableSizedImageData.CurrentImageXShift = 0;\n      while (WPC.DmdCols + VariableSizedImageData.CurrentImageXShift < ImageWidth) {\n        VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n      }\n    }\n    for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight && WriteCounter < Dest.length; i++) {\n      for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n        ch = ROM.byteAtAddr(SourcePtr);\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (j >= Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8) && j < Math.floor(ImageWidth + VariableSizedImageData.CurrentImageXShift + 7) / 8) {\n          const result = this.writeNext8BitValueAnySize(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows, ImageWidth, ImageHeight);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        }\n      }\n    }\n    for (i = 0; i < ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift); i++) {\n      for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n        if (SourcePtr++ >= ROM.endPtr) {\n          return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n      }\n    }\n    VariableSizedImageData.CurrentImageXSize = ImageWidth;\n    VariableSizedImageData.CurrentImageYSize = ImageHeight;\n    return [PlaneStatuses.Valid, Dest, SourcePtr];\n  }\n  static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane1.Plane_Size = 0;\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    if (SourcePtr++ >= ROM.endPtr) {\n      logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n      return pPlanes;\n    }\n    const result = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n    pPlanes.Plane0.Plane_Status = result[0];\n    pPlanes.Plane0.Plane_Data = result[1];\n    SourcePtr = result[2];\n    return pPlanes;\n  }\n  static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n    let DestPlane0 = pPlanes.Plane0.Plane_Data;\n    let DestPlane1 = pPlanes.Plane1.Plane_Data;\n    let HeaderByte;\n    let VerticalOffset;\n    let HorizontalOffset;\n    let ImageHeight;\n    let ImageWidth;\n    pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane0.Plane_Size = 0;\n    pPlanes.Plane0.Address = SourcePtr;\n    pPlanes.Plane1.Address = SourcePtr;\n    HeaderByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    VerticalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageHeight = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    ImageWidth = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return pPlanes;\n    }\n    switch (HeaderByte) {\n      case ImageCodes.BicolorDirect:\n        const result1 = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n        pPlanes.Plane1.Plane_Status = result1[0];\n        pPlanes.Plane1.Plane_Data = result1[1];\n        const result0 = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result0[0];\n        pPlanes.Plane0.Plane_Data = result0[1];\n        break;\n      case ImageCodes.BicolorIndirect:\n        {\n          let Page;\n          let TmpBuf = [0, 0, 0];\n          let Addr;\n          let pBiColor;\n          const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n          Addr = result[0];\n          Page = result[1];\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n            return pPlanes;\n          }\n          TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xff;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xff;\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n          }\n          TmpBuf[2] = Page & 0xff;\n          Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n          if (Addr == -1) {\n            logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xff} ${TmpBuf[1] & 0xff} ${TmpBuf[2] & 0xff}`);\n            return pPlanes;\n          }\n          pBiColor = ROM.byteAtAddr(Addr);\n          const result1 = this.decodeVariableSizedImageToBits(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n          pPlanes.Plane1.Plane_Status = result1[0];\n          pPlanes.Plane1.Plane_Data = result1[1];\n          const result0 = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n          pPlanes.Plane0.Plane_Status = result0[0];\n          pPlanes.Plane0.Plane_Data = result0[1];\n        }\n        break;\n      case ImageCodes.FD:\n      default:\n        const result = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        break;\n    }\n    return pPlanes;\n  }\n  static getImageEncoding(Index) {\n    const pPlane = this.decodeImageToPlane(Index);\n    return pPlane.Plane_Encoding;\n  }\n  static decodeImageToPlane(Index, SkipDecoding = false) {\n    let pPlane;\n    let OriginalDataPtr;\n    let DataPtr;\n    let Addr;\n    let DMDPlane;\n    DMDPlane = DmdDecoder.decodePlaneInit();\n    DMDPlane.Table_Address = FullFrameImageData.TableAddress;\n    Addr = FullFrameImageData.TableAddress + Index * 3;\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n    if (Addr == -1) {\n      logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    if (Addr >= ROM.size) {\n      DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n      return DMDPlane;\n    }\n    OriginalDataPtr = DataPtr = Addr;\n    DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane, SkipDecoding);\n    DMDPlane.Plane_Size = DataPtr - OriginalDataPtr;\n    return DMDPlane;\n  }\n  static decodePlaneInit() {\n    let Plane = new Uint8Array(WPC.DmdPageBytes);\n    let pPlane = {\n      Plane_Size: 0,\n      Plane_Data: Plane,\n      Plane_Skipped: Plane,\n      Plane_XorFlags: Plane,\n      Plane_XorBits: Plane,\n      Plane_Status: PlaneStatuses.Valid,\n      Plane_Encoding: 255,\n      Address: 0,\n      Table_Address: 0\n    };\n    return pPlane;\n  }\n  static decodeFullFrameGraphicImage(Source, pPlane, SkipDecoding) {\n    let OriginalDataPtr = Source;\n    let Dest = new Uint8Array(pPlane.Plane_Data);\n    let ch = ROM.byteAtAddr(Source);\n    pPlane.Plane_Encoding = ch & 0x0f;\n    pPlane.Address = Source;\n    if (SkipDecoding) {\n      return pPlane;\n    }\n    Source++;\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    logStr(`Type ${toHex(ch)}`);\n    switch (ch & 0x0f) {\n      case 0x00:\n        Dest = this.decode_00(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x01:\n        Dest = this.decode_01(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x02:\n        Dest = this.decode_02(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x03:\n        Dest = this.decode_03(Source);\n        pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n        return pPlane;\n      case 0x04:\n        Dest = this.decode_04(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x05:\n        Dest = this.decode_05(Source);\n        pPlane.Plane_Data = Dest;\n        return pPlane;\n      case 0x06:\n        const result_06 = this.decode_06(Source);\n        pPlane.Plane_Data = result_06[0];\n        pPlane.Plane_XorFlags = result_06[1];\n        pPlane.Plane_XorBits = result_06[2];\n        return pPlane;\n      case 0x07:\n        const result_07 = this.decode_07(Source);\n        pPlane.Plane_Data = result_07[0];\n        pPlane.Plane_XorFlags = result_07[1];\n        pPlane.Plane_XorBits = result_07[2];\n        return pPlane;\n      case 0x08:\n        const result_08 = this.decode_08(Source);\n        pPlane.Plane_Data = result_08[0];\n        pPlane.Plane_Skipped = result_08[1];\n        return pPlane;\n        break;\n      case 0x09:\n        const result_09 = this.decode_09(Source);\n        pPlane.Plane_Data = result_09[0];\n        pPlane.Plane_Skipped = result_09[1];\n        return pPlane;\n      case 0x0a:\n        const result_0A = this.decode_0A(Source);\n        pPlane.Plane_Data = result_0A[0];\n        pPlane.Plane_Skipped = result_0A[1];\n        return pPlane;\n      case 0x0b:\n        const result_0B = this.decode_0B(Source);\n        pPlane.Plane_Data = result_0B[0];\n        pPlane.Plane_Skipped = result_0B[1];\n        return pPlane;\n      default:\n        logStr(`Unknown Image Type ${ch}`);\n        pPlane.Plane_Data = Dest;\n        pPlane.Plane_Status = PlaneStatuses.Unknown;\n        pPlane.Plane_Size = OriginalDataPtr - Source;\n        return pPlane;\n    }\n    if (Source >= ROM.endPtr) {\n      pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n      return pPlane;\n    }\n    pPlane.Plane_Status = PlaneStatuses.Valid;\n    return pPlane;\n  }\n  static decode_00(Source) {\n    let Dest = new Uint8Array();\n    let i;\n    for (i = 0; i < WPC.DmdPageBytes; i++) {\n      Dest[i] = ROM.byteAtAddr(Source + i);\n      if (Source + i >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    return Dest;\n  }\n  static decode_01(Source) {\n    return this.decode_01or02(Source, WriteTypes.Columns);\n  }\n  static decode_02(Source) {\n    return this.decode_01or02(Source, WriteTypes.Rows);\n  }\n  static decode_01or02(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    WriteCounter = 0;\n    DestPtr = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return Dest;\n  }\n  static decode_03(Source) {\n    return new Uint8Array();\n  }\n  static decode_04(Source) {\n    return this.decode_04or05(Source, WriteTypes.Columns);\n  }\n  static decode_05(Source) {\n    return this.decode_04or05(Source, WriteTypes.Rows);\n  }\n  static decode_04or05(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: ROM.byteAtAddr(SourcePtr)\n    };\n    let ch;\n    let i;\n    let WriteCounter;\n    WriteCounter = 0;\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return Dest;\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n    }\n    do {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      ch = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return Dest;\n      }\n      if (ch == Header.SpecialFlagByte) {\n        const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result1[0];\n        let Value1 = result1[1];\n        SourcePtr = result1[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result2[0];\n        let Value2 = result2[1];\n        SourcePtr = result2[2];\n        if (SourcePtr >= ROM.endPtr) {\n          return Dest;\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return Dest;\n  }\n  static decode_06(Source) {\n    return this.decode_06or07(Source, WriteTypes.Columns);\n  }\n  static decode_07(Source) {\n    return this.decode_06or07(Source, WriteTypes.Rows);\n  }\n  static decode_06or07(SourcePtr, Type) {\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n    let XorBits = new Uint8Array(WPC.DmdPageBytes);\n    let DestPtr = 0;\n    let XorFlagsPtr = 0;\n    let XorBitsPtr = 0;\n    let ch;\n    let SpecialFlagByte;\n    let WriteCounter;\n    let XorFlagsCounter;\n    let XorBitsCounter;\n    SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, XorFlags, XorBits];\n    }\n    WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n    do {\n      ch = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, XorFlags, XorBits];\n      }\n      if (ch == SpecialFlagByte) {\n        let Value1 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        let Value2 = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n          return [Dest, XorFlags, XorBits];\n        }\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xff, Type);\n          XorFlagsPtr = resultXorFlags[0];\n          XorFlags = resultXorFlags[1];\n          XorFlagsCounter = resultXorFlags[2];\n          const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n          XorBitsPtr = resultXorBits[0];\n          XorBits = resultXorBits[1];\n          XorBitsCounter = resultXorBits[2];\n        } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n      } else {\n        const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n        DestPtr = result[0];\n        Dest = result[1];\n        WriteCounter = result[2];\n        const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n        XorFlagsPtr = resultXorFlags[0];\n        XorFlags = resultXorFlags[1];\n        XorFlagsCounter = resultXorFlags[2];\n        const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n        XorBitsPtr = resultXorBits[0];\n        XorBits = resultXorBits[1];\n        XorBitsCounter = resultXorBits[2];\n      }\n    } while (WriteCounter < WPC.DmdPageBytes);\n    return [Dest, XorFlags, XorBits];\n  }\n  static decode_08(Source) {\n    return this.decode_08or09(Source, WriteTypes.Columns);\n  }\n  static decode_09(Source) {\n    return this.decode_08or09(Source, WriteTypes.Rows);\n  }\n  static decode_08or09(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let count;\n    let pattern;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    function repeatSkips() {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xff, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n    }\n    count = SourcePtr;\n    count = ROM.byteAtAddr(SourcePtr);\n    SourcePtr++;\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    WriteCounter = SkippedCounter = 0;\n    if (!count) {\n      repeatSkips();\n    }\n    while (continueLooping) {\n      count = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          pattern = ROM.byteAtAddr(SourcePtr);\n          SourcePtr++;\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      if (continueLooping) {\n        repeatSkips();\n      }\n    }\n    return [Dest, Skipped];\n  }\n  static decode_0A(Source) {\n    return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n  }\n  static decode_0B(Source) {\n    return this.decode_0Aor0B(Source, WriteTypes.Rows);\n  }\n  static decode_0Aor0B(SourcePtr, Type) {\n    let DestPtr = 0;\n    let Dest = new Uint8Array(WPC.DmdPageBytes);\n    let SkippedPtr = 0;\n    let Skipped = new Uint8Array(WPC.DmdPageBytes);\n    let Header = {\n      ReadMask: 0x80,\n      RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n      SpecialFlagByte: 0\n    };\n    let count;\n    let i;\n    let WriteCounter;\n    let SkippedCounter;\n    let continueLooping = true;\n    Header.ReadMask = 0x80;\n    WriteCounter = SkippedCounter = 0;\n    function BulkSkips() {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xff, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n        return [Dest, Skipped];\n      }\n      return [Dest, Skipped];\n    }\n    for (i = 0; i < 8; i++) {\n      Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n    }\n    const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n    Header = result[0];\n    count = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      return [Dest, Skipped];\n    }\n    if (!count) {\n      BulkSkips();\n    }\n    while (continueLooping) {\n      const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n      Header = result[0];\n      count = result[1];\n      SourcePtr = result[2];\n      if (SourcePtr >= ROM.endPtr) {\n        return [Dest, Skipped];\n      }\n      if (count) {\n        do {\n          const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n          Header = resultRead[0];\n          const Read = resultRead[1];\n          SourcePtr = resultRead[2];\n          const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n          DestPtr = result[0];\n          Dest = result[1];\n          WriteCounter = result[2];\n          if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n          }\n          const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n          SkippedPtr = resultSkipped[0];\n          Skipped = resultSkipped[1];\n          SkippedCounter = resultSkipped[2];\n        } while (--count && WriteCounter < WPC.DmdPageBytes);\n      }\n      if (WriteCounter >= WPC.DmdPageBytes) {\n        continueLooping = false;\n      }\n      BulkSkips();\n    }\n    if (Header.ReadMask == 0x80) {\n      SourcePtr--;\n    }\n    return [Dest, Skipped];\n  }\n  static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n    return DmdDecoder.writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, WPC.DmdCols, WPC.DmdRows);\n  }\n  static writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, cols, rows) {\n    Dest.set([ch], DestPtr);\n    WriteCounterPtr++;\n    if (WriteCounterPtr >= Math.ceil(Math.ceil(cols / 8) * 8 * rows) / 8) {\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (Type == WriteTypes.Rows) {\n      DestPtr++;\n      return [DestPtr, Dest, WriteCounterPtr];\n    }\n    if (!(WriteCounterPtr % rows)) {\n      DestPtr -= cols / 8 * (rows - 2) + (cols / 8 - 1);\n    } else {\n      DestPtr += cols / 8;\n    }\n    return [DestPtr, Dest, WriteCounterPtr];\n  }\n  static readNext8BitValue(Header, SourcePtr) {\n    let returnValues;\n    const result = DmdDecoder.readNextBit(Header, SourcePtr);\n    let ch = result[0];\n    Header = result[1];\n    SourcePtr = result[2];\n    if (SourcePtr >= ROM.endPtr) {\n      returnValues = [Header, 0x00, SourcePtr];\n      return returnValues;\n    }\n    let WriteMask;\n    let ReturnValue;\n    let i;\n    if (ch) {\n      let OnesCount = 0;\n      for (i = 0; i < 7; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          OnesCount++;\n        } else {\n          i = 7;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n      }\n      ReturnValue = Header.RepeatBytes[OnesCount];\n    } else {\n      WriteMask = 0x80;\n      ReturnValue = 0x00;\n      for (i = 0; i < 8; i++) {\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        Header = result[1];\n        SourcePtr = result[2];\n        if (result[0]) {\n          ReturnValue |= WriteMask;\n        }\n        if (SourcePtr >= ROM.endPtr) {\n          returnValues = [Header, 0x00, SourcePtr];\n          return returnValues;\n        }\n        WriteMask >>= 1;\n      }\n    }\n    returnValues = [Header, ReturnValue, SourcePtr];\n    return returnValues;\n  }\n  static readNextBit(Header, SourcePtr) {\n    let returnValues;\n    let ch = ROM.byteAtAddr(SourcePtr) & Header.ReadMask;\n    if (!(Header.ReadMask >>= 1)) {\n      Header.ReadMask = 0x80;\n      SourcePtr++;\n      if (SourcePtr >= ROM.endPtr) {\n        returnValues = [0x00, Header, SourcePtr];\n        return returnValues;\n      }\n    }\n    returnValues = [ch, Header, SourcePtr];\n    return returnValues;\n  }\n}","map":{"version":3,"names":["WriteTypes","ImageCodes","DataTypes","PlaneStatuses","WPC","DataParser","toHex","logStr","VariableSizedImageData","FullFrameImageData","ROM","DmdDecoder","constructor","PreviousPlaneDataPane0","Uint8Array","PreviousPlaneDataPane1","init","decodeNextIndex","count","dataType","Graphics","CurrentImageIndex","FontData","AniData","Planes","Plane0","Plane_Status","Valid","CurrentImageXShift","DmdCols","CurrentImageXSize","ImageShiftXPixelCount","CurrentImageYShift","DmdRows","CurrentImageYSize","ImageShiftYPixelCount","result","incrementVariableSizedImageIndex","CurrentTableIndex","pTableIndex","pImageIndex","tmpImageIndex","getLastImageIndex","getNextImageIndex","maxTableIndex","getFirstImageIndex","decrementVariableSizedImageIndex","getPrevImageIndex","minTableIndex","decodePreviousIndex","decodeFullFrameGraphic","GraphicIndex","decodeImageToPlane","Plane1","decodeVariableSizedImageData","decodeVariableSizedImageIndexToPlane","TableIndex","ImageIndex","DataPtr","Addr","pPlanes","decodePlaneInit","getROMAddressOfVariableSizedImageIndex","Address","BadDimension","decodeVariableSizedImage","Source","TableHeight","TableSpacing","ch","byteAtAddr","getVariableSizedImageTableMetadata","decodeVariableSizedImageIndex_NoHeader","Monochrome","BicolorIndirect","BicolorDirect","FD","decodeVariableSizedImageIndex_Header","decodeVariableSizedImageToBits","SourcePtr","Dest","ImageHeight","ImageWidth","Centered","WriteCounter","i","j","DestPtr","Math","ceil","endPtr","ImageOutOfRange","length","floor","writeNext8BitValueAnySize","Rows","DestPlane0","Plane_Data","DestPlane1","Invalid","Plane_Size","HeaderByte","VerticalOffset","HorizontalOffset","result1","result0","Page","TmpBuf","pBiColor","extractWPCAddrAndPageOfImageTable","getROMAddressFromAddrOf3ByteWPCAddrPage","getImageEncoding","Index","pPlane","Plane_Encoding","SkipDecoding","OriginalDataPtr","DMDPlane","Table_Address","TableAddress","size","TableEntryOutOfRange","decodeFullFrameGraphicImage","Plane","DmdPageBytes","Plane_Skipped","Plane_XorFlags","Plane_XorBits","decode_00","decode_01","decode_02","decode_03","Unimplemented","decode_04","decode_05","result_06","decode_06","result_07","decode_07","result_08","decode_08","result_09","decode_09","result_0A","decode_0A","result_0B","decode_0B","Unknown","decode_01or02","Columns","Type","SpecialFlagByte","Value1","Value2","writeNext8BitValue","decode_04or05","Header","ReadMask","RepeatBytes","readNext8BitValue","result2","decode_06or07","XorFlags","XorBits","XorFlagsPtr","XorBitsPtr","XorFlagsCounter","XorBitsCounter","resultXorFlags","resultXorBits","decode_08or09","SkippedPtr","Skipped","pattern","SkippedCounter","continueLooping","repeatSkips","resultSkipped","decode_0Aor0B","BulkSkips","resultRead","Read","WriteCounterPtr","cols","rows","set","returnValues","readNextBit","WriteMask","ReturnValue","OnesCount"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit/node_modules/wpcedit/dist/classes/DmdDecoder.js"],"sourcesContent":["import { WriteTypes, ImageCodes, DataTypes, PlaneStatuses, WPC, } from \"../resources/Constants.js\";\nimport { DataParser } from \"./DataParser.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DmdDecoder {\n    constructor() {\n        this.PreviousPlaneDataPane0 = new Uint8Array();\n        this.PreviousPlaneDataPane1 = new Uint8Array();\n    }\n    init() { }\n    static decodeNextIndex(count, dataType) {\n        switch (dataType) {\n            case DataTypes.Graphics:\n                while (count--) {\n                    {\n                        FullFrameImageData.CurrentImageIndex++;\n                    }\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status ==\n                    PlaneStatuses.Valid) {\n                    if (VariableSizedImageData.CurrentImageXShift + WPC.DmdCols <\n                        VariableSizedImageData.CurrentImageXSize) {\n                        VariableSizedImageData.CurrentImageXShift +=\n                            WPC.ImageShiftXPixelCount * count;\n                        break;\n                    }\n                    if (VariableSizedImageData.CurrentImageYShift + WPC.DmdRows <\n                        VariableSizedImageData.CurrentImageYSize) {\n                        VariableSizedImageData.CurrentImageYShift +=\n                            WPC.ImageShiftYPixelCount * count;\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.incrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                        logStr(`Unexpected error advancing image indexes`);\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static incrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if (pTableIndex == null || pImageIndex == null) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0];\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if ((pImageIndex & 0xff) < (tmpImageIndex & 0xff)) {\n            pImageIndex = DataParser.getNextImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex < VariableSizedImageData.maxTableIndex) {\n            pTableIndex++;\n            pImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [0, 0];\n    }\n    static decrementVariableSizedImageIndex(pTableIndex, pImageIndex) {\n        let tmpImageIndex;\n        if (pTableIndex == null || pImageIndex == null) {\n            return [-1, -1];\n        }\n        tmpImageIndex = DataParser.getFirstImageIndex(pTableIndex);\n        if (tmpImageIndex == -1) {\n            return [-1, -1];\n        }\n        if ((pImageIndex & 0xff) > (tmpImageIndex & 0xff)) {\n            pImageIndex = DataParser.getPrevImageIndex(pImageIndex, pTableIndex);\n            if (pImageIndex == -1) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        if (pTableIndex > VariableSizedImageData.minTableIndex) {\n            pTableIndex = pTableIndex - 1;\n            if (DataParser.getLastImageIndex(pImageIndex, pTableIndex)[0] != 0) {\n                return [-1, -1];\n            }\n            return [pTableIndex, pImageIndex];\n        }\n        return [pTableIndex, pImageIndex];\n    }\n    static decodePreviousIndex(count, dataType) {\n        switch (dataType) {\n            case DataTypes.Graphics:\n                while (count-- && FullFrameImageData.CurrentImageIndex) {\n                    FullFrameImageData.CurrentImageIndex--;\n                }\n                break;\n            case DataTypes.FontData:\n            case DataTypes.AniData:\n                if (VariableSizedImageData.Planes.Plane0.Plane_Status ==\n                    PlaneStatuses.Valid) {\n                    if (VariableSizedImageData.CurrentImageYShift > 0) {\n                        VariableSizedImageData.CurrentImageYShift -=\n                            WPC.ImageShiftYPixelCount * count;\n                        if (VariableSizedImageData.CurrentImageYShift < 0) {\n                            VariableSizedImageData.CurrentImageYShift = 0;\n                        }\n                        break;\n                    }\n                    if (VariableSizedImageData.CurrentImageXShift > 0) {\n                        VariableSizedImageData.CurrentImageXShift -=\n                            WPC.ImageShiftXPixelCount * count;\n                        if (VariableSizedImageData.CurrentImageXShift < 0) {\n                            VariableSizedImageData.CurrentImageXShift = 0;\n                        }\n                        break;\n                    }\n                }\n                VariableSizedImageData.CurrentImageXShift = -1;\n                VariableSizedImageData.CurrentImageYShift = -1;\n                while (count--) {\n                    const result = DmdDecoder.decrementVariableSizedImageIndex(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n                    VariableSizedImageData.CurrentTableIndex = result[0];\n                    VariableSizedImageData.CurrentImageIndex = result[1];\n                    if (result[0] == -1) {\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static decodeFullFrameGraphic(GraphicIndex) {\n        FullFrameImageData.Planes.Plane0 = this.decodeImageToPlane(GraphicIndex);\n        FullFrameImageData.Planes.Plane1 = this.decodeImageToPlane(GraphicIndex + 1);\n    }\n    static decodeVariableSizedImageData() {\n        const result = DmdDecoder.decodeVariableSizedImageIndexToPlane(VariableSizedImageData.CurrentTableIndex, VariableSizedImageData.CurrentImageIndex);\n        VariableSizedImageData.Planes = result[1];\n        if (VariableSizedImageData.Planes.Plane0.Plane_Status != PlaneStatuses.Valid) {\n            VariableSizedImageData.CurrentImageXSize = 0;\n            VariableSizedImageData.CurrentImageYSize = 0;\n            VariableSizedImageData.CurrentImageXShift = 0;\n            VariableSizedImageData.CurrentImageYShift = 0;\n        }\n    }\n    static decodeVariableSizedImageIndexToPlane(TableIndex, ImageIndex) {\n        let DataPtr;\n        let Addr;\n        let pPlanes = {\n            Plane0: DmdDecoder.decodePlaneInit(),\n            Plane1: DmdDecoder.decodePlaneInit(),\n        };\n        VariableSizedImageData.CurrentImageXSize = 0;\n        VariableSizedImageData.CurrentImageYSize = 0;\n        Addr = DataParser.getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex);\n        VariableSizedImageData.Address = Addr;\n        if (Addr == -1) {\n            pPlanes.Plane0.Plane_Status = PlaneStatuses.BadDimension;\n            pPlanes.Plane1.Plane_Status = PlaneStatuses.BadDimension;\n            return [-1, pPlanes];\n        }\n        DataPtr = Addr;\n        pPlanes = DmdDecoder.decodeVariableSizedImage(DataPtr, pPlanes, TableIndex)[1];\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImage(Source, pPlanes, TableIndex) {\n        let TableHeight;\n        let TableSpacing;\n        VariableSizedImageData.Address = Source;\n        let ch = ROM.byteAtAddr(Source);\n        const result = DataParser.getVariableSizedImageTableMetadata(TableIndex);\n        TableHeight = result[0];\n        TableSpacing = result[1];\n        if (TableHeight == -1) {\n            logStr(`Unexpected problem looking up TableIndex ${TableIndex} height & spacing`);\n            return [-1, pPlanes];\n        }\n        if (ch > 0 && ch <= WPC.DmdCols) {\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_NoHeader(Source, pPlanes, TableHeight);\n        }\n        else {\n            switch (ch) {\n                case ImageCodes.Monochrome:\n                case ImageCodes.BicolorIndirect:\n                case ImageCodes.BicolorDirect:\n                case ImageCodes.FD:\n                    break;\n                default:\n                    logStr(`Unrecognized Header Byte ${ch}`);\n                    break;\n            }\n            pPlanes = DmdDecoder.decodeVariableSizedImageIndex_Header(Source, pPlanes, TableHeight, TableIndex);\n        }\n        return [0, pPlanes];\n    }\n    static decodeVariableSizedImageToBits(SourcePtr, Dest, ImageHeight, ImageWidth, Centered = false) {\n        let ch;\n        let WriteCounter = 0;\n        let i, j;\n        let DestPtr = 0;\n        Dest = new Uint8Array(Math.ceil(Math.ceil(ImageWidth / 8) * 8 * ImageHeight) / 8);\n        if (SourcePtr >= ROM.endPtr) {\n            return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n        }\n        if (VariableSizedImageData.CurrentImageYShift == -1) {\n            VariableSizedImageData.CurrentImageYShift = 0;\n            while (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift <\n                ImageHeight) {\n                VariableSizedImageData.CurrentImageYShift += WPC.ImageShiftYPixelCount;\n            }\n        }\n        if (VariableSizedImageData.CurrentImageXShift == -1) {\n            VariableSizedImageData.CurrentImageXShift = 0;\n            while (WPC.DmdCols + VariableSizedImageData.CurrentImageXShift <\n                ImageWidth) {\n                VariableSizedImageData.CurrentImageXShift += WPC.ImageShiftXPixelCount;\n            }\n        }\n        for (i = 0; i < VariableSizedImageData.CurrentImageYShift; i++) {\n            for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        for (i = 0; i < ImageHeight && WriteCounter < Dest.length; i++) {\n            for (j = 0; j < Math.floor((ImageWidth + 7) / 8); j++) {\n                ch = ROM.byteAtAddr(SourcePtr);\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n                if (j >=\n                    Math.floor((VariableSizedImageData.CurrentImageXShift + 7) / 8) &&\n                    j <\n                        Math.floor(ImageWidth + VariableSizedImageData.CurrentImageXShift + 7) /\n                            8) {\n                    const result = this.writeNext8BitValueAnySize(WriteCounter, Dest, DestPtr, ch, WriteTypes.Rows, ImageWidth, ImageHeight);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                }\n            }\n        }\n        for (i = 0; i <\n            ImageHeight - (WPC.DmdRows + VariableSizedImageData.CurrentImageYShift); i++) {\n            for (j = 0; j < (ImageWidth + 7) / 8; j++) {\n                if (SourcePtr++ >= ROM.endPtr) {\n                    return [PlaneStatuses.ImageOutOfRange, Dest, SourcePtr];\n                }\n            }\n        }\n        VariableSizedImageData.CurrentImageXSize = ImageWidth;\n        VariableSizedImageData.CurrentImageYSize = ImageHeight;\n        return [PlaneStatuses.Valid, Dest, SourcePtr];\n    }\n    static decodeVariableSizedImageIndex_NoHeader(SourcePtr, pPlanes, TableHeight) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane1.Plane_Size = 0;\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        if (SourcePtr++ >= ROM.endPtr) {\n            logStr(`Address is out of bounds in decodeVariableSizedImageIndex_NoHeader()`);\n            return pPlanes;\n        }\n        const result = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, TableHeight, ImageWidth);\n        pPlanes.Plane0.Plane_Status = result[0];\n        pPlanes.Plane0.Plane_Data = result[1];\n        SourcePtr = result[2];\n        return pPlanes;\n    }\n    static decodeVariableSizedImageIndex_Header(SourcePtr, pPlanes, TableHeight, TableIndex) {\n        let DestPlane0 = pPlanes.Plane0.Plane_Data;\n        let DestPlane1 = pPlanes.Plane1.Plane_Data;\n        let HeaderByte;\n        let VerticalOffset;\n        let HorizontalOffset;\n        let ImageHeight;\n        let ImageWidth;\n        pPlanes.Plane0.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane1.Plane_Status = PlaneStatuses.Invalid;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane0.Plane_Size = 0;\n        pPlanes.Plane0.Address = SourcePtr;\n        pPlanes.Plane1.Address = SourcePtr;\n        HeaderByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        VerticalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        HorizontalOffset = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageHeight = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        ImageWidth = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return pPlanes;\n        }\n        switch (HeaderByte) {\n            case ImageCodes.BicolorDirect:\n                const result1 = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane1, ImageHeight, ImageWidth);\n                pPlanes.Plane1.Plane_Status = result1[0];\n                pPlanes.Plane1.Plane_Data = result1[1];\n                const result0 = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result0[0];\n                pPlanes.Plane0.Plane_Data = result0[1];\n                break;\n            case ImageCodes.BicolorIndirect:\n                {\n                    let Page;\n                    let TmpBuf = [0, 0, 0];\n                    let Addr;\n                    let pBiColor;\n                    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n                    Addr = result[0];\n                    Page = result[1];\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up TableIndex ${TableIndex} WPC Page`);\n                        return pPlanes;\n                    }\n                    TmpBuf[0] = ROM.byteAtAddr(SourcePtr) & 0xff;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[1] = ROM.byteAtAddr(SourcePtr) & 0xff;\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return pPlanes;\n                    }\n                    TmpBuf[2] = Page & 0xff;\n                    Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(TmpBuf[0]);\n                    if (Addr == -1) {\n                        logStr(`decodeVariableSizedImageIndex_Header(), Unexpected problem looking up ROM address of bi-color plane from 3-byte WPC Addr ${TmpBuf[0] & 0xff} ${TmpBuf[1] & 0xff} ${TmpBuf[2] & 0xff}`);\n                        return pPlanes;\n                    }\n                    pBiColor = ROM.byteAtAddr(Addr);\n                    const result1 = this.decodeVariableSizedImageToBits(pBiColor, DestPlane1, ImageHeight, ImageWidth);\n                    pPlanes.Plane1.Plane_Status = result1[0];\n                    pPlanes.Plane1.Plane_Data = result1[1];\n                    const result0 = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                    pPlanes.Plane0.Plane_Status = result0[0];\n                    pPlanes.Plane0.Plane_Data = result0[1];\n                }\n                break;\n            case ImageCodes.FD:\n            default:\n                const result = this.decodeVariableSizedImageToBits(SourcePtr, DestPlane0, ImageHeight, ImageWidth);\n                pPlanes.Plane0.Plane_Status = result[0];\n                pPlanes.Plane0.Plane_Data = result[1];\n                break;\n        }\n        return pPlanes;\n    }\n    static getImageEncoding(Index) {\n        const pPlane = this.decodeImageToPlane(Index);\n        return pPlane.Plane_Encoding;\n    }\n    static decodeImageToPlane(Index, SkipDecoding = false) {\n        let pPlane;\n        let OriginalDataPtr;\n        let DataPtr;\n        let Addr;\n        let DMDPlane;\n        DMDPlane = DmdDecoder.decodePlaneInit();\n        DMDPlane.Table_Address = FullFrameImageData.TableAddress;\n        Addr = FullFrameImageData.TableAddress + Index * 3;\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Addr);\n        if (Addr == -1) {\n            logStr(`decodeImageToPlane() got error from GetROMAddressFromAddrOf3ByteWPCAddrPage()`);\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        if (Addr >= ROM.size) {\n            DMDPlane.Plane_Status = PlaneStatuses.TableEntryOutOfRange;\n            return DMDPlane;\n        }\n        OriginalDataPtr = DataPtr = Addr;\n        DMDPlane = this.decodeFullFrameGraphicImage(Addr, DMDPlane, SkipDecoding);\n        DMDPlane.Plane_Size = DataPtr - OriginalDataPtr;\n        return DMDPlane;\n    }\n    static decodePlaneInit() {\n        let Plane = new Uint8Array(WPC.DmdPageBytes);\n        let pPlane = {\n            Plane_Size: 0,\n            Plane_Data: Plane,\n            Plane_Skipped: Plane,\n            Plane_XorFlags: Plane,\n            Plane_XorBits: Plane,\n            Plane_Status: PlaneStatuses.Valid,\n            Plane_Encoding: 255,\n            Address: 0,\n            Table_Address: 0,\n        };\n        return pPlane;\n    }\n    static decodeFullFrameGraphicImage(Source, pPlane, SkipDecoding) {\n        let OriginalDataPtr = Source;\n        let Dest = new Uint8Array(pPlane.Plane_Data);\n        let ch = ROM.byteAtAddr(Source);\n        pPlane.Plane_Encoding = ch & 0x0f;\n        pPlane.Address = Source;\n        if (SkipDecoding) {\n            return pPlane;\n        }\n        Source++;\n        if (Source >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        logStr(`Type ${toHex(ch)}`);\n        switch (ch & 0x0f) {\n            case 0x00:\n                Dest = this.decode_00(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x01:\n                Dest = this.decode_01(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x02:\n                Dest = this.decode_02(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x03:\n                Dest = this.decode_03(Source);\n                pPlane.Plane_Status = PlaneStatuses.Unimplemented;\n                return pPlane;\n            case 0x04:\n                Dest = this.decode_04(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x05:\n                Dest = this.decode_05(Source);\n                pPlane.Plane_Data = Dest;\n                return pPlane;\n            case 0x06:\n                const result_06 = this.decode_06(Source);\n                pPlane.Plane_Data = result_06[0];\n                pPlane.Plane_XorFlags = result_06[1];\n                pPlane.Plane_XorBits = result_06[2];\n                return pPlane;\n            case 0x07:\n                const result_07 = this.decode_07(Source);\n                pPlane.Plane_Data = result_07[0];\n                pPlane.Plane_XorFlags = result_07[1];\n                pPlane.Plane_XorBits = result_07[2];\n                return pPlane;\n            case 0x08:\n                const result_08 = this.decode_08(Source);\n                pPlane.Plane_Data = result_08[0];\n                pPlane.Plane_Skipped = result_08[1];\n                return pPlane;\n                break;\n            case 0x09:\n                const result_09 = this.decode_09(Source);\n                pPlane.Plane_Data = result_09[0];\n                pPlane.Plane_Skipped = result_09[1];\n                return pPlane;\n            case 0x0a:\n                const result_0A = this.decode_0A(Source);\n                pPlane.Plane_Data = result_0A[0];\n                pPlane.Plane_Skipped = result_0A[1];\n                return pPlane;\n            case 0x0b:\n                const result_0B = this.decode_0B(Source);\n                pPlane.Plane_Data = result_0B[0];\n                pPlane.Plane_Skipped = result_0B[1];\n                return pPlane;\n            default:\n                logStr(`Unknown Image Type ${ch}`);\n                pPlane.Plane_Data = Dest;\n                pPlane.Plane_Status = PlaneStatuses.Unknown;\n                pPlane.Plane_Size = OriginalDataPtr - Source;\n                return pPlane;\n        }\n        if (Source >= ROM.endPtr) {\n            pPlane.Plane_Status = PlaneStatuses.ImageOutOfRange;\n            return pPlane;\n        }\n        pPlane.Plane_Status = PlaneStatuses.Valid;\n        return pPlane;\n    }\n    static decode_00(Source) {\n        let Dest = new Uint8Array();\n        let i;\n        for (i = 0; i < WPC.DmdPageBytes; i++) {\n            Dest[i] = ROM.byteAtAddr(Source + i);\n            if (Source + i >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        return Dest;\n    }\n    static decode_01(Source) {\n        return this.decode_01or02(Source, WriteTypes.Columns);\n    }\n    static decode_02(Source) {\n        return this.decode_01or02(Source, WriteTypes.Rows);\n    }\n    static decode_01or02(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return Dest;\n        }\n        WriteCounter = 0;\n        DestPtr = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return Dest;\n    }\n    static decode_03(Source) {\n        return new Uint8Array();\n    }\n    static decode_04(Source) {\n        return this.decode_04or05(Source, WriteTypes.Columns);\n    }\n    static decode_05(Source) {\n        return this.decode_04or05(Source, WriteTypes.Rows);\n    }\n    static decode_04or05(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: ROM.byteAtAddr(SourcePtr),\n        };\n        let ch;\n        let i;\n        let WriteCounter;\n        WriteCounter = 0;\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return Dest;\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n        }\n        do {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            ch = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return Dest;\n            }\n            if (ch == Header.SpecialFlagByte) {\n                const result1 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result1[0];\n                let Value1 = result1[1];\n                SourcePtr = result1[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                const result2 = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                Header = result2[0];\n                let Value2 = result2[1];\n                SourcePtr = result2[2];\n                if (SourcePtr >= ROM.endPtr) {\n                    return Dest;\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Value2, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return Dest;\n    }\n    static decode_06(Source) {\n        return this.decode_06or07(Source, WriteTypes.Columns);\n    }\n    static decode_07(Source) {\n        return this.decode_06or07(Source, WriteTypes.Rows);\n    }\n    static decode_06or07(SourcePtr, Type) {\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let XorFlags = new Uint8Array(WPC.DmdPageBytes);\n        let XorBits = new Uint8Array(WPC.DmdPageBytes);\n        let DestPtr = 0;\n        let XorFlagsPtr = 0;\n        let XorBitsPtr = 0;\n        let ch;\n        let SpecialFlagByte;\n        let WriteCounter;\n        let XorFlagsCounter;\n        let XorBitsCounter;\n        SpecialFlagByte = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, XorFlags, XorBits];\n        }\n        WriteCounter = XorFlagsCounter = XorBitsCounter = 0;\n        do {\n            ch = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, XorFlags, XorBits];\n            }\n            if (ch == SpecialFlagByte) {\n                let Value1 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                let Value2 = ROM.byteAtAddr(SourcePtr);\n                SourcePtr++;\n                if (SourcePtr >= ROM.endPtr) {\n                    return [Dest, XorFlags, XorBits];\n                }\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0xff, Type);\n                    XorFlagsPtr = resultXorFlags[0];\n                    XorFlags = resultXorFlags[1];\n                    XorFlagsCounter = resultXorFlags[2];\n                    const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, Value2, Type);\n                    XorBitsPtr = resultXorBits[0];\n                    XorBits = resultXorBits[1];\n                    XorBitsCounter = resultXorBits[2];\n                } while (--Value1 && WriteCounter < WPC.DmdPageBytes);\n            }\n            else {\n                const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, ch, Type);\n                DestPtr = result[0];\n                Dest = result[1];\n                WriteCounter = result[2];\n                const resultXorFlags = DmdDecoder.writeNext8BitValue(XorFlagsCounter, XorFlags, XorFlagsPtr, 0x00, Type);\n                XorFlagsPtr = resultXorFlags[0];\n                XorFlags = resultXorFlags[1];\n                XorFlagsCounter = resultXorFlags[2];\n                const resultXorBits = DmdDecoder.writeNext8BitValue(XorBitsCounter, XorBits, XorBitsPtr, 0x00, Type);\n                XorBitsPtr = resultXorBits[0];\n                XorBits = resultXorBits[1];\n                XorBitsCounter = resultXorBits[2];\n            }\n        } while (WriteCounter < WPC.DmdPageBytes);\n        return [Dest, XorFlags, XorBits];\n    }\n    static decode_08(Source) {\n        return this.decode_08or09(Source, WriteTypes.Columns);\n    }\n    static decode_09(Source) {\n        return this.decode_08or09(Source, WriteTypes.Rows);\n    }\n    static decode_08or09(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let count;\n        let pattern;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        function repeatSkips() {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xff, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while (--count && WriteCounter < WPC.DmdPageBytes);\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n        }\n        count = SourcePtr;\n        count = ROM.byteAtAddr(SourcePtr);\n        SourcePtr++;\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        WriteCounter = SkippedCounter = 0;\n        if (!count) {\n            repeatSkips();\n        }\n        while (continueLooping) {\n            count = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    pattern = ROM.byteAtAddr(SourcePtr);\n                    SourcePtr++;\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, pattern, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while (--count && WriteCounter < WPC.DmdPageBytes);\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            if (continueLooping) {\n                repeatSkips();\n            }\n        }\n        return [Dest, Skipped];\n    }\n    static decode_0A(Source) {\n        return DmdDecoder.decode_0Aor0B(Source, WriteTypes.Columns);\n    }\n    static decode_0B(Source) {\n        return this.decode_0Aor0B(Source, WriteTypes.Rows);\n    }\n    static decode_0Aor0B(SourcePtr, Type) {\n        let DestPtr = 0;\n        let Dest = new Uint8Array(WPC.DmdPageBytes);\n        let SkippedPtr = 0;\n        let Skipped = new Uint8Array(WPC.DmdPageBytes);\n        let Header = {\n            ReadMask: 0x80,\n            RepeatBytes: [0, 0, 0, 0, 0, 0, 0, 0],\n            SpecialFlagByte: 0,\n        };\n        let count;\n        let i;\n        let WriteCounter;\n        let SkippedCounter;\n        let continueLooping = true;\n        Header.ReadMask = 0x80;\n        WriteCounter = SkippedCounter = 0;\n        function BulkSkips() {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, 0x00, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0xff, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while (--count && WriteCounter < WPC.DmdPageBytes);\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n                return [Dest, Skipped];\n            }\n            return [Dest, Skipped];\n        }\n        for (i = 0; i < 8; i++) {\n            Header.RepeatBytes[i] = ROM.byteAtAddr(SourcePtr);\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n        }\n        const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n        Header = result[0];\n        count = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            return [Dest, Skipped];\n        }\n        if (!count) {\n            BulkSkips();\n        }\n        while (continueLooping) {\n            const result = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n            Header = result[0];\n            count = result[1];\n            SourcePtr = result[2];\n            if (SourcePtr >= ROM.endPtr) {\n                return [Dest, Skipped];\n            }\n            if (count) {\n                do {\n                    const resultRead = DmdDecoder.readNext8BitValue(Header, SourcePtr);\n                    Header = resultRead[0];\n                    const Read = resultRead[1];\n                    SourcePtr = resultRead[2];\n                    const result = DmdDecoder.writeNext8BitValue(WriteCounter, Dest, DestPtr, Read, Type);\n                    DestPtr = result[0];\n                    Dest = result[1];\n                    WriteCounter = result[2];\n                    if (SourcePtr >= ROM.endPtr) {\n                        return [Dest, Skipped];\n                    }\n                    const resultSkipped = DmdDecoder.writeNext8BitValue(SkippedCounter, Skipped, SkippedPtr, 0x00, Type);\n                    SkippedPtr = resultSkipped[0];\n                    Skipped = resultSkipped[1];\n                    SkippedCounter = resultSkipped[2];\n                } while (--count && WriteCounter < WPC.DmdPageBytes);\n            }\n            if (WriteCounter >= WPC.DmdPageBytes) {\n                continueLooping = false;\n            }\n            BulkSkips();\n        }\n        if (Header.ReadMask == 0x80) {\n            SourcePtr--;\n        }\n        return [Dest, Skipped];\n    }\n    static writeNext8BitValue(WriteCounterPtr, Dest, DestPtr, ch, Type) {\n        return DmdDecoder.writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, WPC.DmdCols, WPC.DmdRows);\n    }\n    static writeNext8BitValueAnySize(WriteCounterPtr, Dest, DestPtr, ch, Type, cols, rows) {\n        Dest.set([ch], DestPtr);\n        WriteCounterPtr++;\n        if (WriteCounterPtr >= Math.ceil(Math.ceil(cols / 8) * 8 * rows) / 8) {\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (Type == WriteTypes.Rows) {\n            DestPtr++;\n            return [DestPtr, Dest, WriteCounterPtr];\n        }\n        if (!(WriteCounterPtr % rows)) {\n            DestPtr -= (cols / 8) * (rows - 2) + (cols / 8 - 1);\n        }\n        else {\n            DestPtr += cols / 8;\n        }\n        return [DestPtr, Dest, WriteCounterPtr];\n    }\n    static readNext8BitValue(Header, SourcePtr) {\n        let returnValues;\n        const result = DmdDecoder.readNextBit(Header, SourcePtr);\n        let ch = result[0];\n        Header = result[1];\n        SourcePtr = result[2];\n        if (SourcePtr >= ROM.endPtr) {\n            returnValues = [Header, 0x00, SourcePtr];\n            return returnValues;\n        }\n        let WriteMask;\n        let ReturnValue;\n        let i;\n        if (ch) {\n            let OnesCount = 0;\n            for (i = 0; i < 7; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    OnesCount++;\n                }\n                else {\n                    i = 7;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n            }\n            ReturnValue = Header.RepeatBytes[OnesCount];\n        }\n        else {\n            WriteMask = 0x80;\n            ReturnValue = 0x00;\n            for (i = 0; i < 8; i++) {\n                const result = DmdDecoder.readNextBit(Header, SourcePtr);\n                Header = result[1];\n                SourcePtr = result[2];\n                if (result[0]) {\n                    ReturnValue |= WriteMask;\n                }\n                if (SourcePtr >= ROM.endPtr) {\n                    returnValues = [Header, 0x00, SourcePtr];\n                    return returnValues;\n                }\n                WriteMask >>= 1;\n            }\n        }\n        returnValues = [Header, ReturnValue, SourcePtr];\n        return returnValues;\n    }\n    static readNextBit(Header, SourcePtr) {\n        let returnValues;\n        let ch = ROM.byteAtAddr(SourcePtr) & Header.ReadMask;\n        if (!(Header.ReadMask >>= 1)) {\n            Header.ReadMask = 0x80;\n            SourcePtr++;\n            if (SourcePtr >= ROM.endPtr) {\n                returnValues = [0x00, Header, SourcePtr];\n                return returnValues;\n            }\n        }\n        returnValues = [ch, Header, SourcePtr];\n        return returnValues;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}