{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport { DataTypes, WPC } from \"../resources/Constants.js\";\nimport { DmdDecoder } from \"./DmdDecoder.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nexport class FullFrameImage {\n  static init() {\n    if (FullFrameImage.instance) {\n      return this.instance;\n    }\n    this.instance = new FullFrameImage();\n    return this.instance;\n  }\n  constructor() {\n    FullFrameImageData.init();\n  }\n  prev(steps) {\n    DmdDecoder.decodePreviousIndex(steps, DataTypes.Graphics);\n  }\n  next(steps) {\n    DmdDecoder.decodeNextIndex(steps, DataTypes.Graphics);\n  }\n  get minImageIndex() {\n    return 0;\n  }\n  get maxImageIndex() {\n    let index = 200;\n    let invalidImages = 0;\n    while (invalidImages < 3 && index < 2000) {\n      const plane = this.getPlaneAt(index);\n      if (plane.type > 11 && plane.type != 255) {\n        invalidImages++;\n      }\n      index++;\n    }\n    return index;\n  }\n  set index(index) {\n    FullFrameImageData.CurrentImageIndex = Math.max(0, index);\n  }\n  get index() {\n    return FullFrameImageData.CurrentImageIndex;\n  }\n  get plane() {\n    FullFrameImage._getCurrent();\n    return FullFrameImage.currentPlane;\n  }\n  getPlaneAt(index) {\n    FullFrameImageData.CurrentImageIndex = Math.max(0, index);\n    FullFrameImage._getCurrent();\n    return FullFrameImage.currentPlane;\n  }\n  mergeImages(img1, img2, mask) {\n    const imageSize = Math.min(img1.length, img2.length, mask.length);\n    let mergedImage = new Uint8Array(imageSize);\n    let i;\n    for (i = 0; i < imageSize; i++) {\n      if (mask[i] == 0xff) {\n        mergedImage[i] = img1[i];\n      } else {\n        mergedImage[i] = img2[i];\n      }\n    }\n    return mergedImage;\n  }\n  mergePlanes(img1, plane2) {\n    const img2 = plane2.image;\n    const mask = plane2.mask;\n    const xor = plane2.xor;\n    const flags = plane2.flags;\n    const imageSize = Math.min(img1.length, img2.length);\n    let mergedImage = new Uint8Array(imageSize);\n    let i;\n    for (i = 0; i < imageSize; i++) {\n      let skip = false;\n      let img1Byte = img1[i];\n      let img2Byte = img2[i];\n      if (flags[i] > 0) {\n        for (let j = 0; j < 8; j++) {\n          const xorBit = xor[i] >> j & 0x01;\n          const flagBit = flags[i] >> j & 0x01;\n          const img1Bit = img1Byte >> j & 0x01;\n          if (flagBit) {\n            if (xorBit) {\n              img2Byte |= (~img1Bit & 0x01) << j;\n            } else {\n              img2Byte |= img1Bit << j;\n            }\n          }\n        }\n      }\n      if (mask[i] == 0xff) {\n        mergedImage[i] = img1Byte;\n      } else {\n        mergedImage[i] = img2Byte;\n      }\n    }\n    return mergedImage;\n  }\n  static _getCurrent() {\n    DmdDecoder.decodeFullFrameGraphic(FullFrameImageData.CurrentImageIndex);\n    FullFrameImage.currentPlane.image = FullFrameImageData.Planes.Plane0.Plane_Data;\n    FullFrameImage.currentPlane.mask = FullFrameImageData.Planes.Plane0.Plane_Skipped;\n    FullFrameImage.currentPlane.xor = FullFrameImageData.Planes.Plane0.Plane_XorBits;\n    FullFrameImage.currentPlane.flags = FullFrameImageData.Planes.Plane0.Plane_XorFlags;\n    FullFrameImage.currentPlane.type = FullFrameImageData.Planes.Plane0.Plane_Encoding;\n    FullFrameImage.currentPlane.address = FullFrameImageData.Planes.Plane0.Address;\n    FullFrameImage.currentPlane.tableAddress = FullFrameImageData.Planes.Plane0.Table_Address;\n  }\n}\nFullFrameImage.currentPlane = {\n  width: WPC.DmdCols,\n  height: WPC.DmdRows,\n  image: new Uint8Array(WPC.DmdPageBytes),\n  mask: new Uint8Array(WPC.DmdPageBytes),\n  xor: new Uint8Array(WPC.DmdPageBytes),\n  flags: new Uint8Array(WPC.DmdPageBytes),\n  xOffset: 0,\n  yOffset: 0,\n  type: 255,\n  address: 0,\n  tableAddress: 0\n};","map":{"version":3,"names":["DataTypes","WPC","DmdDecoder","FullFrameImageData","FullFrameImage","init","instance","constructor","prev","steps","decodePreviousIndex","Graphics","next","decodeNextIndex","minImageIndex","maxImageIndex","index","invalidImages","plane","getPlaneAt","type","CurrentImageIndex","Math","max","_getCurrent","currentPlane","mergeImages","img1","img2","mask","imageSize","min","length","mergedImage","Uint8Array","i","mergePlanes","plane2","image","xor","flags","skip","img1Byte","img2Byte","j","xorBit","flagBit","img1Bit","decodeFullFrameGraphic","Planes","Plane0","Plane_Data","Plane_Skipped","Plane_XorBits","Plane_XorFlags","Plane_Encoding","address","Address","tableAddress","Table_Address","width","DmdCols","height","DmdRows","DmdPageBytes","xOffset","yOffset"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit/node_modules/wpcedit/dist/classes/FullFrameImage.js"],"sourcesContent":["import { DataTypes, WPC } from \"../resources/Constants.js\";\nimport { DmdDecoder } from \"./DmdDecoder.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nexport class FullFrameImage {\n    static init() {\n        if (FullFrameImage.instance) {\n            return this.instance;\n        }\n        this.instance = new FullFrameImage();\n        return this.instance;\n    }\n    constructor() {\n        FullFrameImageData.init();\n    }\n    prev(steps) {\n        DmdDecoder.decodePreviousIndex(steps, DataTypes.Graphics);\n    }\n    next(steps) {\n        DmdDecoder.decodeNextIndex(steps, DataTypes.Graphics);\n    }\n    get minImageIndex() {\n        return 0;\n    }\n    get maxImageIndex() {\n        let index = 200;\n        let invalidImages = 0;\n        while (invalidImages < 3 && index < 2000) {\n            const plane = this.getPlaneAt(index);\n            if (plane.type > 11 && plane.type != 255) {\n                invalidImages++;\n            }\n            index++;\n        }\n        return index;\n    }\n    set index(index) {\n        FullFrameImageData.CurrentImageIndex = Math.max(0, index);\n    }\n    get index() {\n        return FullFrameImageData.CurrentImageIndex;\n    }\n    get plane() {\n        FullFrameImage._getCurrent();\n        return FullFrameImage.currentPlane;\n    }\n    getPlaneAt(index) {\n        FullFrameImageData.CurrentImageIndex = Math.max(0, index);\n        FullFrameImage._getCurrent();\n        return FullFrameImage.currentPlane;\n    }\n    mergeImages(img1, img2, mask) {\n        const imageSize = Math.min(img1.length, img2.length, mask.length);\n        let mergedImage = new Uint8Array(imageSize);\n        let i;\n        for (i = 0; i < imageSize; i++) {\n            if (mask[i] == 0xff) {\n                mergedImage[i] = img1[i];\n            }\n            else {\n                mergedImage[i] = img2[i];\n            }\n        }\n        return mergedImage;\n    }\n    mergePlanes(img1, plane2) {\n        const img2 = plane2.image;\n        const mask = plane2.mask;\n        const xor = plane2.xor;\n        const flags = plane2.flags;\n        const imageSize = Math.min(img1.length, img2.length);\n        let mergedImage = new Uint8Array(imageSize);\n        let i;\n        for (i = 0; i < imageSize; i++) {\n            let skip = false;\n            let img1Byte = img1[i];\n            let img2Byte = img2[i];\n            if (flags[i] > 0) {\n                for (let j = 0; j < 8; j++) {\n                    const xorBit = (xor[i] >> j) & 0x01;\n                    const flagBit = (flags[i] >> j) & 0x01;\n                    const img1Bit = (img1Byte >> j) & 0x01;\n                    if (flagBit) {\n                        if (xorBit) {\n                            img2Byte |= (~img1Bit & 0x01) << j;\n                        }\n                        else {\n                            img2Byte |= img1Bit << j;\n                        }\n                    }\n                }\n            }\n            if (mask[i] == 0xff) {\n                mergedImage[i] = img1Byte;\n            }\n            else {\n                mergedImage[i] = img2Byte;\n            }\n        }\n        return mergedImage;\n    }\n    static _getCurrent() {\n        DmdDecoder.decodeFullFrameGraphic(FullFrameImageData.CurrentImageIndex);\n        FullFrameImage.currentPlane.image =\n            FullFrameImageData.Planes.Plane0.Plane_Data;\n        FullFrameImage.currentPlane.mask =\n            FullFrameImageData.Planes.Plane0.Plane_Skipped;\n        FullFrameImage.currentPlane.xor =\n            FullFrameImageData.Planes.Plane0.Plane_XorBits;\n        FullFrameImage.currentPlane.flags =\n            FullFrameImageData.Planes.Plane0.Plane_XorFlags;\n        FullFrameImage.currentPlane.type =\n            FullFrameImageData.Planes.Plane0.Plane_Encoding;\n        FullFrameImage.currentPlane.address =\n            FullFrameImageData.Planes.Plane0.Address;\n        FullFrameImage.currentPlane.tableAddress =\n            FullFrameImageData.Planes.Plane0.Table_Address;\n    }\n}\nFullFrameImage.currentPlane = {\n    width: WPC.DmdCols,\n    height: WPC.DmdRows,\n    image: new Uint8Array(WPC.DmdPageBytes),\n    mask: new Uint8Array(WPC.DmdPageBytes),\n    xor: new Uint8Array(WPC.DmdPageBytes),\n    flags: new Uint8Array(WPC.DmdPageBytes),\n    xOffset: 0,\n    yOffset: 0,\n    type: 255,\n    address: 0,\n    tableAddress: 0,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}