{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { HitTypes, DataTypes, WPC } from \"../resources/Constants.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DataParser {\n  constructor() {}\n  static init(romData) {\n    if (DataParser.instance) {\n      return this.instance;\n    }\n    this.instance = new DataParser();\n    return this.instance;\n  }\n  static initTableAddrs(dataType) {\n    let Page;\n    let PageByteIdx;\n    let HitTablePtr;\n    let HitPagePtr;\n    let RomAddr;\n    let WpcAddr;\n    let Ptr = 0;\n    logStr(`Searching ROM for Master Animation Table Address`);\n    for (Page = 0; Page < ROM.totalPages; Page++) {\n      for (PageByteIdx = 0; PageByteIdx < WPC.PageLength; PageByteIdx++) {\n        switch (ROM.byteAtAddr(Ptr++) & 0xff) {\n          case 0xbe:\n            if (PageByteIdx >= WPC.PageLength - 16) {\n              break;\n            }\n            if ((ROM.byteAtAddr(Ptr + 2) & 0xff) == 0x3a && (ROM.byteAtAddr(Ptr + 3) & 0xff) == 0x58 && (ROM.byteAtAddr(Ptr + 4) & 0xff) == 0x3a && (ROM.byteAtAddr(Ptr + 5) & 0xff) == 0xd6 && (ROM.byteAtAddr(Ptr + 7) & 0xff) == 0x34 && (ROM.byteAtAddr(Ptr + 8) & 0xff) == 0x04 && ((ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xf6 || (ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xbd) && ((ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xbd || (ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xf6)) {\n              HitTablePtr = Ptr;\n              HitPagePtr = Ptr + 2;\n              RomAddr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n              if (RomAddr == -1) {\n                logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Font Table Pointer opcode: ${toHex(HitTablePtr & 0xff)} ${toHex(HitTablePtr + 1 & 0xff)}`);\n                return -1;\n              }\n              logStr(`Address in ROM of Font Table Pointer ${toHex(RomAddr)}`);\n              if (dataType == DataTypes.FontData) {\n                VariableSizedImageData.TableAddress = DataParser.processHitType(HitTypes.AddrAddr, HitTablePtr, HitPagePtr, Ptr);\n                if (VariableSizedImageData.TableAddress == -1) {\n                  logStr(`Error from ProcessHitType while trying to process Font Table Pointer opcode: ${toHex(HitTablePtr & 0xff)} ${toHex(HitTablePtr + 1 & 0xff)}`);\n                  break;\n                }\n                logStr(`Found Address in ROM of Font Table ${toHex(VariableSizedImageData.TableAddress)}`);\n              }\n              HitTablePtr = RomAddr;\n              HitPagePtr = RomAddr + 2;\n              WpcAddr = (ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + ROM.byteAtAddr(HitTablePtr + 1) & 0xff & 0xffff;\n              if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom && WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength && ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                RomAddr += 2;\n              } else {\n                RomAddr += 3;\n              }\n              logStr(`Address in ROM of Graphics Table Pointer ${toHex(RomAddr)}`);\n              HitTablePtr = RomAddr;\n              HitPagePtr = RomAddr + 2;\n              FullFrameImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n              if (FullFrameImageData.TableAddress == -1) {\n                logStr(`Error from processHitType while trying to process Graphic Table Pointer: ${toHex(HitTablePtr & 0xff)} ${toHex(HitTablePtr + 1 & 0xff)}`);\n                if (dataType == DataTypes.FontData) {\n                  return 0;\n                }\n                return -1;\n              }\n              logStr(`Found Address in ROM of Graphics Table ${toHex(FullFrameImageData.TableAddress)}`);\n              if (dataType != DataTypes.AniData) {\n                return 0;\n              }\n              HitTablePtr = ROM.byteAtAddr(RomAddr);\n              HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n              WpcAddr = (ROM.byteAtAddr(HitTablePtr & 0xff) << 8) + (ROM.byteAtAddr(HitTablePtr + 1) & 0xff) & 0xffff;\n              if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom && WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength && ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                RomAddr += 2;\n              } else {\n                RomAddr += 3;\n              }\n              logStr(`Address in ROM of Animation Table Pointer ${toHex(RomAddr)}`);\n              HitTablePtr = ROM.byteAtAddr(RomAddr);\n              HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n              VariableSizedImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n              if (VariableSizedImageData.TableAddress == -1) {\n                logStr(`Error from processHitType while trying to process Animation Table Pointer: ${HitTablePtr & 0xff} ${HitTablePtr + 1 & 0xff}`);\n                return -1;\n              }\n              logStr(`Found Address in ROM of Animation Table ${toHex(VariableSizedImageData.TableAddress)}`);\n              ROM.startPtr = Ptr;\n              return 0;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n  static getFirstImageIndex(TableIndex) {\n    const imageIndex = this.getNextImageIndex(0, TableIndex);\n    if (imageIndex == -1) {\n      return -1;\n    }\n    VariableSizedImageData.CurrentImageIndex = imageIndex;\n    return imageIndex;\n  }\n  static getNextImageIndex(pImageIndex, TableIndex) {\n    let Addr;\n    let Ptr;\n    let ImageIndexMin;\n    let ImageIndexMax;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    Ptr = Addr;\n    while ((ROM.byteAtAddr(Ptr) & 0xff) != 0x00) {\n      ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xff;\n      ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xff;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if ((pImageIndex & 0xff) < (ImageIndexMin & 0xff)) {\n        return ImageIndexMin;\n      }\n      if ((pImageIndex & 0xff) < (ImageIndexMax & 0xff)) {\n        return pImageIndex + 1;\n      }\n    }\n    return -1;\n  }\n  static getLastImageIndex(pImageIndex, TableIndex) {\n    let ImageIndex = 0;\n    let hit = 0;\n    let counter = 0;\n    let imageIndeces = [0];\n    imageIndeces.length = 0;\n    while (ImageIndex != -1) {\n      ImageIndex = this.getNextImageIndex(ImageIndex, TableIndex);\n      counter++;\n      if (ImageIndex != -1) {\n        pImageIndex = ImageIndex;\n        imageIndeces.push(ImageIndex);\n      }\n      hit = 1;\n    }\n    if (hit == 0) {\n      return [-1, imageIndeces];\n    }\n    return [pImageIndex, imageIndeces];\n  }\n  static getPrevImageIndex(pImageIndex, TableIndex) {\n    let Addr;\n    let Ptr;\n    let ImageIndexMin;\n    let ImageIndexMax;\n    let windUp;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    if (pImageIndex == null) {\n      return -1;\n    }\n    Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    Ptr = Addr;\n    windUp = 0;\n    while ((ROM.byteAtAddr(Ptr) & 0xff) != 0x00) {\n      Ptr += 2;\n      windUp++;\n    }\n    while (windUp != 0) {\n      Ptr -= 2;\n      windUp--;\n      ImageIndexMin = ROM.byteAtAddr(Ptr) & 0xff;\n      ImageIndexMax = ROM.byteAtAddr(Ptr + 1) & 0xff;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if ((pImageIndex & 0xff) > (ImageIndexMax & 0xff)) {\n        pImageIndex = ImageIndexMax;\n        return pImageIndex;\n      }\n      if ((pImageIndex & 0xff) > (ImageIndexMin & 0xff)) {\n        pImageIndex = pImageIndex - 1;\n        return pImageIndex;\n      }\n    }\n    return -1;\n  }\n  static getROMAddressOfVariableSizedImageTable(TableIndex) {\n    const result = this.extractWPCAddrAndPageOfImageTable(TableIndex);\n    const Addr = result[0];\n    const Page = result[1];\n    if (Addr == -1) {\n      return -1;\n    }\n    const romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (romAddr == -1) {\n      return -1;\n    }\n    return romAddr;\n  }\n  static extractWPCAddrAndPageOfImageTable(TableIndex) {\n    let romAddr;\n    let Ptr;\n    let Addr;\n    let Page;\n    if (!VariableSizedImageData.TableAddress) {\n      return [-1, -1];\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return [-1, -1];\n    }\n    if (VariableSizedImageData.CurrentTableIndex < VariableSizedImageData.minTableIndex || VariableSizedImageData.CurrentTableIndex > VariableSizedImageData.maxTableIndex) {\n      return [-1, -1];\n    }\n    romAddr = DataParser.getAddrToWPCAddressOfVariableSizedImageTable(TableIndex);\n    if (romAddr == -1) {\n      return [-1, -1];\n    }\n    Ptr = romAddr;\n    Addr = ROM.byteAtAddr(Ptr) & 0xff;\n    Addr = Addr << 8;\n    Addr = Addr | ROM.byteAtAddr(Ptr + 1) & 0xff;\n    Addr = Addr & 0xffff;\n    Page = ROM.byteAtAddr(Ptr + 2) & 0xff;\n    {\n      let TempAddr;\n      let TempPage;\n      romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n      if (romAddr == -1) {\n        return [-1, -1];\n      }\n      Ptr = romAddr;\n      TempAddr = ROM.byteAtAddr(Ptr) & 0xff;\n      TempAddr = TempAddr << 8;\n      TempAddr = TempAddr | ROM.byteAtAddr(Ptr + 1) & 0xff;\n      TempAddr = TempAddr & 0xffff;\n      TempPage = ROM.byteAtAddr(Ptr + 2) & 0xff;\n      logStr(`Testing Tempaddr ${toHex(TempAddr)} and Page ${toHex(TempPage)}`);\n      if (TempAddr >= WPC.BaseCodeAddrPagedRom && TempAddr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) {\n        Addr = TempAddr;\n      }\n      logStr(`extractWPCAddrAndPageOfImageTable() FIXUP, Addr fixed to ${toHex(Addr)},${toHex(Page)}`);\n    }\n    return [Addr, Page];\n  }\n  static getROMAddressFromWPCAddrAndPage(Addr, Page) {\n    let romAddr;\n    if (Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      if (Page != WPC.NonpagedBankIndicator) {\n        logStr(`getROMAddressFromWPCAddrAndPage() Non-banked WPC addr ${Addr} followed by page byte ${Page}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n        Page = WPC.NonpagedBankIndicator;\n      }\n    }\n    if (Page == WPC.NonpagedBankIndicator && Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      romAddr = (ROM.totalPages - 2) * WPC.PageLength + (Addr - WPC.BaseCodeAddrNonpagedRom);\n    } else if (Page >= ROM.basePageIndex && Page < ROM.basePageIndex + ROM.totalPages - 2 && Addr >= WPC.BaseCodeAddrPagedRom && Addr < WPC.BaseCodeAddrNonpagedRom) {\n      romAddr = (Page - ROM.basePageIndex) * WPC.PageLength + (Addr - WPC.BaseCodeAddrPagedRom);\n    } else {\n      logStr(`Invalid WPC Addr and Page, ${toHex(Addr)},${toHex(Page)}, BasePage ${toHex(ROM.basePageIndex)}, TotalPages ${ROM.totalPages}`);\n      return -1;\n    }\n    if (romAddr >= ROM.size) {\n      logStr(`Unexpected: Calculated addr in ROM ${romAddr} is greater than determined ROM size ${ROM.size}`);\n      return -1;\n    }\n    return romAddr;\n  }\n  static getAddrToWPCAddressOfVariableSizedImageTable(TableIndex) {\n    let romAddr;\n    if (!VariableSizedImageData.TableAddress) {\n      return -1;\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      return -1;\n    }\n    if (TableIndex < VariableSizedImageData.minTableIndex || TableIndex > VariableSizedImageData.maxTableIndex) {\n      return -1;\n    }\n    romAddr = VariableSizedImageData.TableAddress + 3 * TableIndex;\n    if (romAddr >= ROM.size) {\n      return -1;\n    }\n    return romAddr;\n  }\n  static getROMAddressFromAddrOf3ByteWPCAddrPage(pSrc) {\n    let Addr;\n    let Page;\n    const result = DataParser.extractWPCAddrAndPageFromBuffer(pSrc);\n    Addr = result[0];\n    Page = result[1];\n    if (Addr == -1) {\n      logStr(`Error from ExtractWPCAddrAndPageFromBuffer(), Passed it ptr to: ${ROM.byteAtAddr(pSrc) & 0xff} ${ROM.byteAtAddr(pSrc + 1) & 0xff} ${ROM.byteAtAddr(pSrc + 2) & 0xff}`);\n      return -1;\n    }\n    logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() WPC TableAddress ${toHex(Addr)},${toHex(Page)}`);\n    Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (Addr == -1) {\n      logStr(`Error from getROMAddressFromWPCAddrAndPage(), Passed it WPC Addr ${Addr},${Page}`);\n      return -1;\n    }\n    logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() ROM TableAddress ${toHex(Addr)}`);\n    return Addr;\n  }\n  static getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex) {\n    let Addr;\n    let Page;\n    let Ptr;\n    let TableHeight;\n    let TableSpacing;\n    let ImageIndexMin, ImageIndexMax, ImageNum, ImageFound;\n    Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return -1;\n    }\n    if (Addr >= ROM.size) {\n      return -1;\n    }\n    Ptr = Addr;\n    ImageNum = ImageFound = 0;\n    while ((ROM.byteAtAddr(Ptr) & 0xff) != 0x00) {\n      ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xff;\n      ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xff;\n      if (ImageIndexMin > ImageIndexMax) {\n        return -1;\n      }\n      if (ImageFound == 0) {\n        while (ImageIndexMin <= ImageIndexMax) {\n          if (ImageIndex <= ImageIndexMin) {\n            logStr(`getROMAddressOfVariableSizedImageIndex() ImageFound, ImageNum ${ImageNum}, ImageIndexMin ${ImageIndexMin}, ImageIndexMax ${ImageIndexMax}`);\n            ImageFound = 1;\n            break;\n          }\n          ImageNum++;\n          ImageIndexMin++;\n        }\n      }\n    }\n    Ptr++;\n    TableHeight = ROM.byteAtAddr(Ptr++);\n    TableSpacing = ROM.byteAtAddr(Ptr++);\n    Ptr += ImageNum * 2;\n    Addr = ROM.byteAtAddr(Ptr) & 0xff;\n    Addr = Addr << 8;\n    Addr |= ROM.byteAtAddr(Ptr + 1) & 0xff;\n    Addr &= 0xffff;\n    const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n    Page = result[1];\n    if (Page == -1) {\n      return -1;\n    }\n    Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n    if (Addr == -1) {\n      return -1;\n    }\n    logStr(`getROMAddressOfVariableSizedImageIndex() TableHeight ${TableHeight}, TableSpacing ${TableSpacing} ImageIndex ${ImageIndex} at ${Addr}`);\n    return Addr;\n  }\n  static extractWPCAddrAndPageFromBuffer(pSrc) {\n    let Addr;\n    let Page;\n    Addr = ROM.byteAtAddr(pSrc) & 0xff;\n    Addr = Addr << 8;\n    Addr = Addr | ROM.byteAtAddr(pSrc + 1) & 0xff;\n    Addr = Addr & 0xffff;\n    Page = ROM.byteAtAddr(pSrc + 2) & 0xff;\n    if (Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n      if (Page != WPC.NonpagedBankIndicator) {\n        logStr(`extractWPCAddrAndPageFromBuffer() Non-banked WPC addr ${toHex(Addr)} followed by page byte ${toHex(Page)}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n        Page = WPC.NonpagedBankIndicator;\n      }\n    }\n    if (Addr != null) {\n      if (Addr >= WPC.BaseCodeAddrPagedRom && Addr < WPC.BaseCodeAddrPagedRom + WPC.PageLength || Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {} else {\n        logStr(`Expected a WPC Addr, but read ${toHex(Addr)}`);\n        return [-1, -1];\n      }\n    }\n    if (Page != null) {\n      if (Page >= ROM.basePageIndex && Page < ROM.basePageIndex + ROM.totalPages || Page == WPC.NonpagedBankIndicator) {} else {\n        logStr(`Expected a WPC Page Number, but read ${Page}, Base is ${ROM.basePageIndex}, Total Pages ${ROM.totalPages}`);\n        return [-1, -1];\n      }\n    }\n    return [Addr, Page];\n  }\n  static processHitType(HitType, HitTablePtr, HitPagePtr, Ptr) {\n    let Addr;\n    let HitBuf = [0, 0, 0];\n    let pTbl;\n    switch (HitType) {\n      case HitTypes.AddrAddrAddr:\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xff)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xff)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xff)}`);\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n        if (Addr == -1) {\n          logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xff} ${HitTablePtr + 1 & 0xff}`);\n          return -1;\n        }\n        logStr(`HitTypes.AddrAddrAddr derived ROM TableAddressAddress ${Addr}, going to HitTypes.AddrAddr`);\n        HitTablePtr = ROM.byteAtAddr(Addr);\n      case HitTypes.AddrAddr:\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xff)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xff)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xff)}`);\n        Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n        if (Addr == -1) {\n          logStr(`Error from GetROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xff} ${HitTablePtr + 1 & 0xff}`);\n          return -1;\n        }\n        logStr(`HitTypes.AddrAddr derived TableAddress of ${toHex(Addr)} going to HitTypes.Addr`);\n        HitTablePtr = Addr;\n        HitPagePtr = Addr + 2;\n      case HitTypes.Addr:\n        if (HitTablePtr == null) {\n          logStr(\"HitTypes.Addr, but HitTablePtr is NULL\");\n          return -1;\n        }\n        HitBuf[0] = HitTablePtr;\n        HitBuf[1] = HitTablePtr + 1;\n        if (HitPagePtr == null) {\n          let Addr;\n          Addr = HitBuf[0] & 0xff;\n          Addr = Addr << 8;\n          Addr = Addr | HitBuf[1] & 0xff;\n          Addr = Addr & 0xffff;\n          if (!(Addr >= WPC.BaseCodeAddrNonpagedRom && Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n            logStr(`HitTypes.Addr, but HitPagePtr is NULL, and Addr is in paged ROM`);\n            return -1;\n          }\n          HitBuf[2] = WPC.NonpagedBankIndicator;\n        } else {\n          HitBuf[2] = ROM.byteAtAddr(HitPagePtr);\n        }\n        logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xff)}, HitBytes ${toHex(ROM.byteAtAddr(HitBuf[0]) & 0xff)} ${toHex(ROM.byteAtAddr(HitBuf[1]) & 0xff)} ${toHex(HitBuf[2] & 0xff)}`);\n        pTbl = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitBuf[0]);\n        if (pTbl != -1) {\n          logStr(\"Table Found!\");\n          return pTbl;\n        }\n        logStr(`Error deriving table addr from hit, HitType ${Ptr - 1 & 0xff}, HitBytes ${HitBuf[0] & 0xff} ${HitBuf[1] & 0xff} ${HitBuf[2] & 0xff}. Will keep looking. May need to debug by opening window while pressing <shift>`);\n        break;\n      case HitTypes.None:\n        return 0;\n      default:\n        logStr(\"Unexpected HitType\");\n        break;\n    }\n    return -1;\n  }\n  static preAnalyzeVariableSizedImageTable() {\n    let Ptr;\n    let Addr;\n    let TableCount = 0;\n    ROM.vSImageTableMap.length = 0;\n    if (!VariableSizedImageData.TableAddress) {\n      logStr(`Unexpected NULL ${VariableSizedImageData.TableAddress}`);\n    }\n    if (VariableSizedImageData.TableAddress >= ROM.size) {\n      logStr(`Unexpected table address ${VariableSizedImageData.TableAddress} is >= ${ROM.size}`);\n    }\n    Ptr = VariableSizedImageData.TableAddress;\n    let continueLooping = true;\n    while (continueLooping) {\n      Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Ptr);\n      if (Addr == -1) {\n        continueLooping = false;\n      } else {\n        VariableSizedImageData.maxTableIndex++;\n        const result = DataParser.getLastImageIndex(-1, VariableSizedImageData.maxTableIndex - 1);\n        const ImageIndex = result[0];\n        ROM.vSImageTableMap.push(result[1]);\n        if (ImageIndex == -1) {\n          VariableSizedImageData.maxTableIndex--;\n          logStr(`Stopped looking for image tables due to getLastImageIndex() error on TableIndex ${VariableSizedImageData.maxTableIndex}`);\n          continueLooping = false;\n        }\n        Ptr += 3;\n        TableCount++;\n      }\n    }\n    logStr(`Determined TableCount: ${TableCount}%d`);\n    if (TableCount == 0) {\n      logStr(\"Found 0 table entries\");\n      return -1;\n    }\n    VariableSizedImageData.minTableIndex = 0;\n    VariableSizedImageData.maxTableIndex = TableCount - 1;\n    VariableSizedImageData.maxImageIndex = DataParser.getLastImageIndex(VariableSizedImageData.maxImageIndex, VariableSizedImageData.maxTableIndex)[0];\n    if (VariableSizedImageData.maxImageIndex == -1) {\n      logStr(`Error looking up max image index for last table index ${VariableSizedImageData.maxTableIndex}`);\n      return -1;\n    }\n    VariableSizedImageData.minImageIndex = DataParser.getFirstImageIndex(VariableSizedImageData.minTableIndex);\n    if (VariableSizedImageData.minTableIndex == -1) {\n      logStr(`Error looking up min image index for first table index ${VariableSizedImageData.maxTableIndex})`);\n      return -1;\n    }\n    logStr(`Determined maxTableIndex ${VariableSizedImageData.maxTableIndex}, maxImageIndex ${VariableSizedImageData.maxImageIndex}`);\n    return 0;\n  }\n  static getVariableSizedImageTableMetadata(TableIndex) {\n    let Addr;\n    let Ptr;\n    let TableHeight;\n    let TableSpacing;\n    Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n    if (Addr == -1) {\n      return [-1, -1];\n    }\n    if (Addr >= ROM.size) {\n      return [-1, -1];\n    }\n    Ptr = Addr;\n    while ((ROM.byteAtAddr(Ptr++) & 0xff) != 0x00);\n    TableHeight = ROM.byteAtAddr(Ptr++);\n    TableSpacing = ROM.byteAtAddr(Ptr++);\n    return [TableHeight, TableSpacing];\n  }\n}","map":{"version":3,"names":["HitTypes","DataTypes","WPC","toHex","logStr","VariableSizedImageData","FullFrameImageData","ROM","DataParser","constructor","init","romData","instance","initTableAddrs","dataType","Page","PageByteIdx","HitTablePtr","HitPagePtr","RomAddr","WpcAddr","Ptr","totalPages","PageLength","byteAtAddr","getROMAddressFromAddrOf3ByteWPCAddrPage","FontData","TableAddress","processHitType","AddrAddr","BaseCodeAddrNonpagedRom","NonpagedLength","NonpagedBankIndicator","Addr","AniData","startPtr","getFirstImageIndex","TableIndex","imageIndex","getNextImageIndex","CurrentImageIndex","pImageIndex","ImageIndexMin","ImageIndexMax","size","minTableIndex","maxTableIndex","getROMAddressOfVariableSizedImageTable","getLastImageIndex","ImageIndex","hit","counter","imageIndeces","length","push","getPrevImageIndex","windUp","result","extractWPCAddrAndPageOfImageTable","romAddr","getROMAddressFromWPCAddrAndPage","CurrentTableIndex","getAddrToWPCAddressOfVariableSizedImageTable","TempAddr","TempPage","BaseCodeAddrPagedRom","basePageIndex","pSrc","extractWPCAddrAndPageFromBuffer","getROMAddressOfVariableSizedImageIndex","TableHeight","TableSpacing","ImageNum","ImageFound","HitType","HitBuf","pTbl","AddrAddrAddr","None","preAnalyzeVariableSizedImageTable","TableCount","vSImageTableMap","continueLooping","maxImageIndex","minImageIndex","getVariableSizedImageTableMetadata"],"sources":["/Users/permartinson/Documents/GitHub/wpcedit/node_modules/wpcedit/dist/classes/DataParser.js"],"sourcesContent":["import { HitTypes, DataTypes, WPC } from \"../resources/Constants.js\";\nimport { toHex, logStr } from \"../resources/Helpers.js\";\nimport { VariableSizedImageData } from \"../stores/VariableSizedImageData.js\";\nimport { FullFrameImageData } from \"../stores/FullFrameImageData.js\";\nimport { ROM } from \"../stores/ROM.js\";\nexport class DataParser {\n    constructor() { }\n    static init(romData) {\n        if (DataParser.instance) {\n            return this.instance;\n        }\n        this.instance = new DataParser();\n        return this.instance;\n    }\n    static initTableAddrs(dataType) {\n        let Page;\n        let PageByteIdx;\n        let HitTablePtr;\n        let HitPagePtr;\n        let RomAddr;\n        let WpcAddr;\n        let Ptr = 0;\n        logStr(`Searching ROM for Master Animation Table Address`);\n        for (Page = 0; Page < ROM.totalPages; Page++) {\n            for (PageByteIdx = 0; PageByteIdx < WPC.PageLength; PageByteIdx++) {\n                switch (ROM.byteAtAddr(Ptr++) & 0xff) {\n                    case 0xbe:\n                        if (PageByteIdx >= WPC.PageLength - 16) {\n                            break;\n                        }\n                        if ((ROM.byteAtAddr(Ptr + 2) & 0xff) == 0x3a &&\n                            (ROM.byteAtAddr(Ptr + 3) & 0xff) == 0x58 &&\n                            (ROM.byteAtAddr(Ptr + 4) & 0xff) == 0x3a &&\n                            (ROM.byteAtAddr(Ptr + 5) & 0xff) == 0xd6 &&\n                            (ROM.byteAtAddr(Ptr + 7) & 0xff) == 0x34 &&\n                            (ROM.byteAtAddr(Ptr + 8) & 0xff) == 0x04 &&\n                            ((ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xf6 ||\n                                (ROM.byteAtAddr(Ptr + 9) & 0xff) == 0xbd) &&\n                            ((ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xbd ||\n                                (ROM.byteAtAddr(Ptr + 12) & 0xff) == 0xf6)) {\n                            HitTablePtr = Ptr;\n                            HitPagePtr = Ptr + 2;\n                            RomAddr =\n                                DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                            if (RomAddr == -1) {\n                                logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Font Table Pointer opcode: ${toHex(HitTablePtr & 0xff)} ${toHex((HitTablePtr + 1) & 0xff)}`);\n                                return -1;\n                            }\n                            logStr(`Address in ROM of Font Table Pointer ${toHex(RomAddr)}`);\n                            if (dataType == DataTypes.FontData) {\n                                VariableSizedImageData.TableAddress = DataParser.processHitType(HitTypes.AddrAddr, HitTablePtr, HitPagePtr, Ptr);\n                                if (VariableSizedImageData.TableAddress == -1) {\n                                    logStr(`Error from ProcessHitType while trying to process Font Table Pointer opcode: ${toHex(HitTablePtr & 0xff)} ${toHex((HitTablePtr + 1) & 0xff)}`);\n                                    break;\n                                }\n                                logStr(`Found Address in ROM of Font Table ${toHex(VariableSizedImageData.TableAddress)}`);\n                            }\n                            HitTablePtr = RomAddr;\n                            HitPagePtr = RomAddr + 2;\n                            WpcAddr =\n                                ((ROM.byteAtAddr(HitTablePtr & 0xff) << 8) +\n                                    (ROM.byteAtAddr(HitTablePtr + 1)) & 0xff) &\n                                    0xffff;\n                            if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom &&\n                                WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength &&\n                                ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                                RomAddr += 2;\n                            }\n                            else {\n                                RomAddr += 3;\n                            }\n                            logStr(`Address in ROM of Graphics Table Pointer ${toHex(RomAddr)}`);\n                            HitTablePtr = RomAddr;\n                            HitPagePtr = RomAddr + 2;\n                            FullFrameImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n                            if (FullFrameImageData.TableAddress == -1) {\n                                logStr(`Error from processHitType while trying to process Graphic Table Pointer: ${toHex(HitTablePtr & 0xff)} ${toHex((HitTablePtr + 1) & 0xff)}`);\n                                if (dataType == DataTypes.FontData) {\n                                    return 0;\n                                }\n                                return -1;\n                            }\n                            logStr(`Found Address in ROM of Graphics Table ${toHex(FullFrameImageData.TableAddress)}`);\n                            if (dataType != DataTypes.AniData) {\n                                return 0;\n                            }\n                            HitTablePtr = ROM.byteAtAddr(RomAddr);\n                            HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n                            WpcAddr =\n                                ((ROM.byteAtAddr(HitTablePtr & 0xff) << 8) +\n                                    (ROM.byteAtAddr(HitTablePtr + 1) & 0xff)) &\n                                    0xffff;\n                            if (WpcAddr >= WPC.BaseCodeAddrNonpagedRom &&\n                                WpcAddr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength &&\n                                ROM.byteAtAddr(HitPagePtr & 0xff) != WPC.NonpagedBankIndicator) {\n                                RomAddr += 2;\n                            }\n                            else {\n                                RomAddr += 3;\n                            }\n                            logStr(`Address in ROM of Animation Table Pointer ${toHex(RomAddr)}`);\n                            HitTablePtr = ROM.byteAtAddr(RomAddr);\n                            HitPagePtr = ROM.byteAtAddr(RomAddr + 2);\n                            VariableSizedImageData.TableAddress = this.processHitType(HitTypes.Addr, HitTablePtr, HitPagePtr, Ptr);\n                            if (VariableSizedImageData.TableAddress == -1) {\n                                logStr(`Error from processHitType while trying to process Animation Table Pointer: ${HitTablePtr & 0xff} ${(HitTablePtr + 1) & 0xff}`);\n                                return -1;\n                            }\n                            logStr(`Found Address in ROM of Animation Table ${toHex(VariableSizedImageData.TableAddress)}`);\n                            ROM.startPtr = Ptr;\n                            return 0;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n    static getFirstImageIndex(TableIndex) {\n        const imageIndex = this.getNextImageIndex(0, TableIndex);\n        if (imageIndex == -1) {\n            return -1;\n        }\n        VariableSizedImageData.CurrentImageIndex = imageIndex;\n        return imageIndex;\n    }\n    static getNextImageIndex(pImageIndex, TableIndex) {\n        let Addr;\n        let Ptr;\n        let ImageIndexMin;\n        let ImageIndexMax;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if (TableIndex < VariableSizedImageData.minTableIndex ||\n            TableIndex > VariableSizedImageData.maxTableIndex) {\n            return -1;\n        }\n        Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        Ptr = Addr;\n        while ((ROM.byteAtAddr(Ptr) & 0xff) != 0x00) {\n            ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xff;\n            ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xff;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if ((pImageIndex & 0xff) < (ImageIndexMin & 0xff)) {\n                return ImageIndexMin;\n            }\n            if ((pImageIndex & 0xff) < (ImageIndexMax & 0xff)) {\n                return pImageIndex + 1;\n            }\n        }\n        return -1;\n    }\n    static getLastImageIndex(pImageIndex, TableIndex) {\n        let ImageIndex = 0;\n        let hit = 0;\n        let counter = 0;\n        let imageIndeces = [0];\n        imageIndeces.length = 0;\n        while (ImageIndex != -1) {\n            ImageIndex = this.getNextImageIndex(ImageIndex, TableIndex);\n            counter++;\n            if (ImageIndex != -1) {\n                pImageIndex = ImageIndex;\n                imageIndeces.push(ImageIndex);\n            }\n            hit = 1;\n        }\n        if (hit == 0) {\n            return [-1, imageIndeces];\n        }\n        return [pImageIndex, imageIndeces];\n    }\n    static getPrevImageIndex(pImageIndex, TableIndex) {\n        let Addr;\n        let Ptr;\n        let ImageIndexMin;\n        let ImageIndexMax;\n        let windUp;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if (TableIndex < VariableSizedImageData.minTableIndex ||\n            TableIndex > VariableSizedImageData.maxTableIndex) {\n            return -1;\n        }\n        if (pImageIndex == null) {\n            return -1;\n        }\n        Addr = this.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        Ptr = Addr;\n        windUp = 0;\n        while ((ROM.byteAtAddr(Ptr) & 0xff) != 0x00) {\n            Ptr += 2;\n            windUp++;\n        }\n        while (windUp != 0) {\n            Ptr -= 2;\n            windUp--;\n            ImageIndexMin = ROM.byteAtAddr(Ptr) & 0xff;\n            ImageIndexMax = ROM.byteAtAddr(Ptr + 1) & 0xff;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if ((pImageIndex & 0xff) > (ImageIndexMax & 0xff)) {\n                pImageIndex = ImageIndexMax;\n                return pImageIndex;\n            }\n            if ((pImageIndex & 0xff) > (ImageIndexMin & 0xff)) {\n                pImageIndex = pImageIndex - 1;\n                return pImageIndex;\n            }\n        }\n        return -1;\n    }\n    static getROMAddressOfVariableSizedImageTable(TableIndex) {\n        const result = this.extractWPCAddrAndPageOfImageTable(TableIndex);\n        const Addr = result[0];\n        const Page = result[1];\n        if (Addr == -1) {\n            return -1;\n        }\n        const romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (romAddr == -1) {\n            return -1;\n        }\n        return romAddr;\n    }\n    static extractWPCAddrAndPageOfImageTable(TableIndex) {\n        let romAddr;\n        let Ptr;\n        let Addr;\n        let Page;\n        if (!VariableSizedImageData.TableAddress) {\n            return [-1, -1];\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return [-1, -1];\n        }\n        if (VariableSizedImageData.CurrentTableIndex <\n            VariableSizedImageData.minTableIndex ||\n            VariableSizedImageData.CurrentTableIndex >\n                VariableSizedImageData.maxTableIndex) {\n            return [-1, -1];\n        }\n        romAddr =\n            DataParser.getAddrToWPCAddressOfVariableSizedImageTable(TableIndex);\n        if (romAddr == -1) {\n            return [-1, -1];\n        }\n        Ptr = romAddr;\n        Addr = ROM.byteAtAddr(Ptr) & 0xff;\n        Addr = Addr << 8;\n        Addr = Addr | (ROM.byteAtAddr(Ptr + 1) & 0xff);\n        Addr = Addr & 0xffff;\n        Page = ROM.byteAtAddr(Ptr + 2) & 0xff;\n        {\n            let TempAddr;\n            let TempPage;\n            romAddr = this.getROMAddressFromWPCAddrAndPage(Addr, Page);\n            if (romAddr == -1) {\n                return [-1, -1];\n            }\n            Ptr = romAddr;\n            TempAddr = ROM.byteAtAddr(Ptr) & 0xff;\n            TempAddr = TempAddr << 8;\n            TempAddr = TempAddr | (ROM.byteAtAddr(Ptr + 1) & 0xff);\n            TempAddr = TempAddr & 0xffff;\n            TempPage = ROM.byteAtAddr(Ptr + 2) & 0xff;\n            logStr(`Testing Tempaddr ${toHex(TempAddr)} and Page ${toHex(TempPage)}`);\n            if (TempAddr >= WPC.BaseCodeAddrPagedRom &&\n                TempAddr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) {\n                Addr = TempAddr;\n            }\n            logStr(`extractWPCAddrAndPageOfImageTable() FIXUP, Addr fixed to ${toHex(Addr)},${toHex(Page)}`);\n        }\n        return [Addr, Page];\n    }\n    static getROMAddressFromWPCAddrAndPage(Addr, Page) {\n        let romAddr;\n        if (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            if (Page != WPC.NonpagedBankIndicator) {\n                logStr(`getROMAddressFromWPCAddrAndPage() Non-banked WPC addr ${Addr} followed by page byte ${Page}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n                Page = WPC.NonpagedBankIndicator;\n            }\n        }\n        if (Page == WPC.NonpagedBankIndicator &&\n            Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            romAddr =\n                (ROM.totalPages - 2) * WPC.PageLength +\n                    (Addr - WPC.BaseCodeAddrNonpagedRom);\n        }\n        else if (Page >= ROM.basePageIndex &&\n            Page < ROM.basePageIndex + ROM.totalPages - 2 &&\n            Addr >= WPC.BaseCodeAddrPagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom) {\n            romAddr =\n                (Page - ROM.basePageIndex) * WPC.PageLength +\n                    (Addr - WPC.BaseCodeAddrPagedRom);\n        }\n        else {\n            logStr(`Invalid WPC Addr and Page, ${toHex(Addr)},${toHex(Page)}, BasePage ${toHex(ROM.basePageIndex)}, TotalPages ${ROM.totalPages}`);\n            return -1;\n        }\n        if (romAddr >= ROM.size) {\n            logStr(`Unexpected: Calculated addr in ROM ${romAddr} is greater than determined ROM size ${ROM.size}`);\n            return -1;\n        }\n        return romAddr;\n    }\n    static getAddrToWPCAddressOfVariableSizedImageTable(TableIndex) {\n        let romAddr;\n        if (!VariableSizedImageData.TableAddress) {\n            return -1;\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            return -1;\n        }\n        if (TableIndex < VariableSizedImageData.minTableIndex ||\n            TableIndex > VariableSizedImageData.maxTableIndex) {\n            return -1;\n        }\n        romAddr = VariableSizedImageData.TableAddress + 3 * TableIndex;\n        if (romAddr >= ROM.size) {\n            return -1;\n        }\n        return romAddr;\n    }\n    static getROMAddressFromAddrOf3ByteWPCAddrPage(pSrc) {\n        let Addr;\n        let Page;\n        const result = DataParser.extractWPCAddrAndPageFromBuffer(pSrc);\n        Addr = result[0];\n        Page = result[1];\n        if (Addr == -1) {\n            logStr(`Error from ExtractWPCAddrAndPageFromBuffer(), Passed it ptr to: ${ROM.byteAtAddr(pSrc) & 0xff} ${ROM.byteAtAddr(pSrc + 1) & 0xff} ${ROM.byteAtAddr(pSrc + 2) & 0xff}`);\n            return -1;\n        }\n        logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() WPC TableAddress ${toHex(Addr)},${toHex(Page)}`);\n        Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (Addr == -1) {\n            logStr(`Error from getROMAddressFromWPCAddrAndPage(), Passed it WPC Addr ${Addr},${Page}`);\n            return -1;\n        }\n        logStr(`getROMAddressFromAddrOf3ByteWPCAddrPage() ROM TableAddress ${toHex(Addr)}`);\n        return Addr;\n    }\n    static getROMAddressOfVariableSizedImageIndex(TableIndex, ImageIndex) {\n        let Addr;\n        let Page;\n        let Ptr;\n        let TableHeight;\n        let TableSpacing;\n        let ImageIndexMin, ImageIndexMax, ImageNum, ImageFound;\n        Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return -1;\n        }\n        if (Addr >= ROM.size) {\n            return -1;\n        }\n        Ptr = Addr;\n        ImageNum = ImageFound = 0;\n        while ((ROM.byteAtAddr(Ptr) & 0xff) != 0x00) {\n            ImageIndexMin = ROM.byteAtAddr(Ptr++) & 0xff;\n            ImageIndexMax = ROM.byteAtAddr(Ptr++) & 0xff;\n            if (ImageIndexMin > ImageIndexMax) {\n                return -1;\n            }\n            if (ImageFound == 0) {\n                while (ImageIndexMin <= ImageIndexMax) {\n                    if (ImageIndex <= ImageIndexMin) {\n                        logStr(`getROMAddressOfVariableSizedImageIndex() ImageFound, ImageNum ${ImageNum}, ImageIndexMin ${ImageIndexMin}, ImageIndexMax ${ImageIndexMax}`);\n                        ImageFound = 1;\n                        break;\n                    }\n                    ImageNum++;\n                    ImageIndexMin++;\n                }\n            }\n        }\n        Ptr++;\n        TableHeight = ROM.byteAtAddr(Ptr++);\n        TableSpacing = ROM.byteAtAddr(Ptr++);\n        Ptr += ImageNum * 2;\n        Addr = ROM.byteAtAddr(Ptr) & 0xff;\n        Addr = Addr << 8;\n        Addr |= ROM.byteAtAddr(Ptr + 1) & 0xff;\n        Addr &= 0xffff;\n        const result = DataParser.extractWPCAddrAndPageOfImageTable(TableIndex);\n        Page = result[1];\n        if (Page == -1) {\n            return -1;\n        }\n        Addr = DataParser.getROMAddressFromWPCAddrAndPage(Addr, Page);\n        if (Addr == -1) {\n            return -1;\n        }\n        logStr(`getROMAddressOfVariableSizedImageIndex() TableHeight ${TableHeight}, TableSpacing ${TableSpacing} ImageIndex ${ImageIndex} at ${Addr}`);\n        return Addr;\n    }\n    static extractWPCAddrAndPageFromBuffer(pSrc) {\n        let Addr;\n        let Page;\n        Addr = ROM.byteAtAddr(pSrc) & 0xff;\n        Addr = Addr << 8;\n        Addr = Addr | (ROM.byteAtAddr(pSrc + 1) & 0xff);\n        Addr = Addr & 0xffff;\n        Page = ROM.byteAtAddr(pSrc + 2) & 0xff;\n        if (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n            Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength) {\n            if (Page != WPC.NonpagedBankIndicator) {\n                logStr(`extractWPCAddrAndPageFromBuffer() Non-banked WPC addr ${toHex(Addr)} followed by page byte ${toHex(Page)}, normal when reading from opcode or some ROMs with 2-byte table addr entries. Forcing page to ${WPC.NonpagedBankIndicator}`);\n                Page = WPC.NonpagedBankIndicator;\n            }\n        }\n        if (Addr != null) {\n            if ((Addr >= WPC.BaseCodeAddrPagedRom &&\n                Addr < WPC.BaseCodeAddrPagedRom + WPC.PageLength) ||\n                (Addr >= WPC.BaseCodeAddrNonpagedRom &&\n                    Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n            }\n            else {\n                logStr(`Expected a WPC Addr, but read ${toHex(Addr)}`);\n                return [-1, -1];\n            }\n        }\n        if (Page != null) {\n            if ((Page >= ROM.basePageIndex &&\n                Page < ROM.basePageIndex + ROM.totalPages) ||\n                Page == WPC.NonpagedBankIndicator) {\n            }\n            else {\n                logStr(`Expected a WPC Page Number, but read ${Page}, Base is ${ROM.basePageIndex}, Total Pages ${ROM.totalPages}`);\n                return [-1, -1];\n            }\n        }\n        return [Addr, Page];\n    }\n    static processHitType(HitType, HitTablePtr, HitPagePtr, Ptr) {\n        let Addr;\n        let HitBuf = [0, 0, 0];\n        let pTbl;\n        switch (HitType) {\n            case HitTypes.AddrAddrAddr:\n                logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xff)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xff)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xff)}`);\n                Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                if (Addr == -1) {\n                    logStr(`Error from getROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xff} ${(HitTablePtr + 1) & 0xff}`);\n                    return -1;\n                }\n                logStr(`HitTypes.AddrAddrAddr derived ROM TableAddressAddress ${Addr}, going to HitTypes.AddrAddr`);\n                HitTablePtr = ROM.byteAtAddr(Addr);\n            case HitTypes.AddrAddr:\n                logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xff)}, HitBytes ${toHex(ROM.byteAtAddr(HitTablePtr) & 0xff)} ${toHex(ROM.byteAtAddr(HitTablePtr + 1) & 0xff)}`);\n                Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitTablePtr);\n                if (Addr == -1) {\n                    logStr(`Error from GetROMAddressFromAddrOf3ByteWPCAddrPage(), Passed it WPC Ptr to ${HitTablePtr & 0xff} ${(HitTablePtr + 1) & 0xff}`);\n                    return -1;\n                }\n                logStr(`HitTypes.AddrAddr derived TableAddress of ${toHex(Addr)} going to HitTypes.Addr`);\n                HitTablePtr = Addr;\n                HitPagePtr = Addr + 2;\n            case HitTypes.Addr:\n                if (HitTablePtr == null) {\n                    logStr(\"HitTypes.Addr, but HitTablePtr is NULL\");\n                    return -1;\n                }\n                HitBuf[0] = HitTablePtr;\n                HitBuf[1] = HitTablePtr + 1;\n                if (HitPagePtr == null) {\n                    let Addr;\n                    Addr = HitBuf[0] & 0xff;\n                    Addr = Addr << 8;\n                    Addr = Addr | (HitBuf[1] & 0xff);\n                    Addr = Addr & 0xffff;\n                    if (!(Addr >= WPC.BaseCodeAddrNonpagedRom &&\n                        Addr < WPC.BaseCodeAddrNonpagedRom + WPC.NonpagedLength)) {\n                        logStr(`HitTypes.Addr, but HitPagePtr is NULL, and Addr is in paged ROM`);\n                        return -1;\n                    }\n                    HitBuf[2] = WPC.NonpagedBankIndicator;\n                }\n                else {\n                    HitBuf[2] = ROM.byteAtAddr(HitPagePtr);\n                }\n                logStr(`Potential Match. HitType ${toHex(ROM.byteAtAddr(Ptr - 1) & 0xff)}, HitBytes ${toHex(ROM.byteAtAddr(HitBuf[0]) & 0xff)} ${toHex(ROM.byteAtAddr(HitBuf[1]) & 0xff)} ${toHex(HitBuf[2] & 0xff)}`);\n                pTbl = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(HitBuf[0]);\n                if (pTbl != -1) {\n                    logStr(\"Table Found!\");\n                    return pTbl;\n                }\n                logStr(`Error deriving table addr from hit, HitType ${(Ptr - 1) & 0xff}, HitBytes ${HitBuf[0] & 0xff} ${HitBuf[1] & 0xff} ${HitBuf[2] & 0xff}. Will keep looking. May need to debug by opening window while pressing <shift>`);\n                break;\n            case HitTypes.None:\n                return 0;\n            default:\n                logStr(\"Unexpected HitType\");\n                break;\n        }\n        return -1;\n    }\n    static preAnalyzeVariableSizedImageTable() {\n        let Ptr;\n        let Addr;\n        let TableCount = 0;\n        ROM.vSImageTableMap.length = 0;\n        if (!VariableSizedImageData.TableAddress) {\n            logStr(`Unexpected NULL ${VariableSizedImageData.TableAddress}`);\n        }\n        if (VariableSizedImageData.TableAddress >= ROM.size) {\n            logStr(`Unexpected table address ${VariableSizedImageData.TableAddress} is >= ${ROM.size}`);\n        }\n        Ptr = VariableSizedImageData.TableAddress;\n        let continueLooping = true;\n        while (continueLooping) {\n            Addr = DataParser.getROMAddressFromAddrOf3ByteWPCAddrPage(Ptr);\n            if (Addr == -1) {\n                continueLooping = false;\n            }\n            else {\n                VariableSizedImageData.maxTableIndex++;\n                const result = DataParser.getLastImageIndex(-1, VariableSizedImageData.maxTableIndex - 1);\n                const ImageIndex = result[0];\n                ROM.vSImageTableMap.push(result[1]);\n                if (ImageIndex == -1) {\n                    VariableSizedImageData.maxTableIndex--;\n                    logStr(`Stopped looking for image tables due to getLastImageIndex() error on TableIndex ${VariableSizedImageData.maxTableIndex}`);\n                    continueLooping = false;\n                }\n                Ptr += 3;\n                TableCount++;\n            }\n        }\n        logStr(`Determined TableCount: ${TableCount}%d`);\n        if (TableCount == 0) {\n            logStr(\"Found 0 table entries\");\n            return -1;\n        }\n        VariableSizedImageData.minTableIndex = 0;\n        VariableSizedImageData.maxTableIndex = TableCount - 1;\n        VariableSizedImageData.maxImageIndex = DataParser.getLastImageIndex(VariableSizedImageData.maxImageIndex, VariableSizedImageData.maxTableIndex)[0];\n        if (VariableSizedImageData.maxImageIndex == -1) {\n            logStr(`Error looking up max image index for last table index ${VariableSizedImageData.maxTableIndex}`);\n            return -1;\n        }\n        VariableSizedImageData.minImageIndex = DataParser.getFirstImageIndex(VariableSizedImageData.minTableIndex);\n        if (VariableSizedImageData.minTableIndex == -1) {\n            logStr(`Error looking up min image index for first table index ${VariableSizedImageData.maxTableIndex})`);\n            return -1;\n        }\n        logStr(`Determined maxTableIndex ${VariableSizedImageData.maxTableIndex}, maxImageIndex ${VariableSizedImageData.maxImageIndex}`);\n        return 0;\n    }\n    static getVariableSizedImageTableMetadata(TableIndex) {\n        let Addr;\n        let Ptr;\n        let TableHeight;\n        let TableSpacing;\n        Addr = DataParser.getROMAddressOfVariableSizedImageTable(TableIndex);\n        if (Addr == -1) {\n            return [-1, -1];\n        }\n        if (Addr >= ROM.size) {\n            return [-1, -1];\n        }\n        Ptr = Addr;\n        while ((ROM.byteAtAddr(Ptr++) & 0xff) != 0x00)\n            ;\n        TableHeight = ROM.byteAtAddr(Ptr++);\n        TableSpacing = ROM.byteAtAddr(Ptr++);\n        return [TableHeight, TableSpacing];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}