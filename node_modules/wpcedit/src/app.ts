import { Plane } from "./resources/Plane.js";
import { WPCEdit } from "./WPCEdit.js";

const inputField = document.getElementById("rom")! as HTMLInputElement;
const canvas = document.getElementById("DMDDisplay")! as HTMLCanvasElement;
const prevBtn = document.getElementById("prev")! as HTMLButtonElement;
const nextBtn = document.getElementById("next")! as HTMLButtonElement;
const n2Btn = document.getElementById("n2")! as HTMLButtonElement;
const p2Btn = document.getElementById("p2")! as HTMLButtonElement;
const prevBtnVS = document.getElementById("prevvs")! as HTMLButtonElement;
const nextBtnVS = document.getElementById("nextvs")! as HTMLButtonElement;
const n2BtnVS = document.getElementById("n2vs")! as HTMLButtonElement;
const p2BtnVS = document.getElementById("p2vs")! as HTMLButtonElement;

WPCEdit.init();
WPCEdit.verbose = false;

let accFullFrameImage = new Uint8Array(512);
let accVariableSizedImage = new Uint8Array(512);
let accPlane: Plane;

inputField.addEventListener("change",function() {
    readFile();
});
prevBtn.addEventListener("click",function() {
    goPrev();
});
nextBtn.addEventListener("click",function() {
    goNext();
});
n2Btn.addEventListener("click",function() {
    goN2();
});
p2Btn.addEventListener("click",function() {
    goP2();
});
prevBtnVS.addEventListener("click",function() {
    goPrevVS();
});
nextBtnVS.addEventListener("click",function() {
    goNextVS();
});
n2BtnVS.addEventListener("click",function() {
    goN2VS();
});
p2BtnVS.addEventListener("click",function() {
    goP2VS();
});

export function readFile() {
    if(inputField.files) Â {
        const file = inputField.files[0];
        readBytes(file, 4, 512);    
    }
}

function bitToRGBRows(rawData:Uint8Array,index:number) {
    const width = 128;
    const height = 32;
    const row = Math.floor(index/width);
    const col = index % width;
    const byte = Math.floor(index/8);
    const bitPos = (col % 8);
    const bit =  ( rawData[byte] & 0xFF ) >>(bitPos) & 1;
   // console.log(`index:${index}, col:${col}, row:${row}, byte: ${byte}, bitPos: ${bitPos}, byte: ${rawData[byte].toString(2)}, bit: ${bit}`);
//console.log(bit); 
    return bit;
}


function bitToRGBRowsBlended(plane0Data:Uint8Array,plane1Data:Uint8Array,index:number) {
    const width = 128;
    const height = 32;
    const row = Math.floor(index/width);
    const col = index % width;
    const byte = Math.floor(index/8);
    const bitPos = (col % 8);
    const plane0Bit =  ( plane0Data[byte] & 0xFF ) >>(bitPos) & 1;
    const plane1Bit =  ( plane1Data[byte] & 0xFF ) >>(bitPos) & 1;
    let colorVal = plane0Bit * 0.67 + plane1Bit * 0.33;
    /*
    if(plane0Bit && plane1Bit) {
        colorVal = 1;
    } else if (plane0Bit) {
        colorVal = 0.66;
    } else if (plane1Bit) {
        colorVal = 0.33;
    }*/
   // console.log(`index:${index}, col:${col}, row:${row}, byte: ${byte}, bitPos: ${bitPos}, byte: ${rawData[byte].toString(2)}, bit: ${bit}`);
//console.log(bit); 
    return colorVal;
}



function drawData(canvas: HTMLCanvasElement, plane0Data:Plane, plane1Data:Plane|null) {
    console.log(plane0Data);
    let image0 = plane0Data.image;
    if(accFullFrameImage != null) {
        image0 = WPCEdit.fullFrameImage.mergePlanes(accFullFrameImage,plane0Data);
    }
    accFullFrameImage = image0;
    const width = Math.ceil(plane0Data.width/8)*8;
    const height = plane0Data.height;
    var ctx = canvas.getContext("2d")!;
    var imageData = ctx.createImageData(width,height);
    var imageBitmap = null;
    const data = new Uint32Array(imageData.data.buffer);
    let counter = 0;
    for(let i=0; i<imageData.data.length; i += 4) {
        let color = bitToRGBRows(image0,counter);
        if(plane1Data != null) {
            const image1 = plane1Data.image
            color = bitToRGBRowsBlended(image0,image1,counter);
        }
        imageData.data[i] = color*187 +33;
        imageData.data[i+1] = color*100 +33;
        imageData.data[i+2] = 33;//color;
        imageData.data[i+3] = 255;
        counter++;
    }
    console.log(plane0Data);
    ctx.putImageData(imageData,0,0);
    createImageBitmap(canvas).then((bmp)=>{
        imageBitmap = bmp;
    });
}

function goNext() {
        console.log("next");
       //WPCEdit.goForward(1);
       //const plane = WPCEdit.currentImage;
       WPCEdit.fullFrameImage.next(1);
       const image = WPCEdit.fullFrameImage.plane.image;
       const mask = WPCEdit.fullFrameImage.plane.mask;
       //accFullFrameImage = WPCEdit.mergeImages(accFullFrameImage,image,mask);
        drawData(canvas,WPCEdit.fullFrameImage.plane,null);
}

function goPrev() {
    
        //WPCEdit.goBackward(1);
        //const plane = WPCEdit.currentImage;
        WPCEdit.fullFrameImage.prev(1);
        const plane = WPCEdit.fullFrameImage.plane;
 
        drawData(canvas,plane,null);
    
}

function goN2() {
        console.log("next");
        WPCEdit.fullFrameImage.next(1);
        const plane1 = WPCEdit.fullFrameImage.plane;
        WPCEdit.fullFrameImage.next(1);
        const plane2 = WPCEdit.fullFrameImage.plane;
        drawData(canvas,plane1,null);
}

function goP2() {
    WPCEdit.fullFrameImage.prev(1);
    const plane2 = WPCEdit.fullFrameImage.plane;
    WPCEdit.fullFrameImage.prev(1);
    const plane1 = WPCEdit.fullFrameImage.plane;
    drawData(canvas,plane1,null);
}

function goNextVS() {
        console.log("next");
        //WPCEdit.goForward(1);
        //const plane = WPCEdit.currentImage;
        WPCEdit.variableSizedImage.next(1);
        const plane = WPCEdit.variableSizedImage.plane;
        const empty = new Uint8Array(512);
        const mergedImage = WPCEdit.variableSizedImage.placeInFullFrame(plane,18,5);
        let mergedPlane: Plane = {image:mergedImage,height:32,width:128,mask:mergedImage,xor:mergedImage,flags:mergedImage,xOffset:0,yOffset:0,type:0,address:0,tableAddress:0};
        drawData(canvas,mergedPlane,null);
}
function goPrevVS() {
        //WPCEdit.goBackward(1);
        //const plane = WPCEdit.currentImage;
        WPCEdit.variableSizedImage.prev(1);
        const plane = WPCEdit.variableSizedImage.plane;
        drawData(canvas,plane,null);
}

function goN2VS() {
        console.log("next");
        WPCEdit.variableSizedImage.getImageAt(52,2);//.next(2);
        const plane = WPCEdit.variableSizedImage.plane;
        const empty = new Uint8Array(512);
        const mergedImage = WPCEdit.variableSizedImage.placeInFullFrame(plane,18,5);
        let mergedPlane: Plane = {image:mergedImage,height:32,width:128,mask:mergedImage,xor:mergedImage,flags:mergedImage,xOffset:0,yOffset:0,type:0,address:0,tableAddress:0};
        drawData(canvas,mergedPlane,null);

}
function goP2VS() {
    WPCEdit.variableSizedImage.prev(2);
    const plane = WPCEdit.variableSizedImage.plane;
     drawData(canvas,plane,null);
}
function randClr() {
    return Math.random();
}

export function readBytes(file: File, pos: number,length: number) {
	const reader = new FileReader();

	reader.addEventListener("loadend", function() {
        if (reader.result) {
            const bytes = new Uint8Array(reader.result as ArrayBuffer);
            const result = WPCEdit.setRom(bytes);
            if(result.error) {
                alert(result.msg);
            }
            console.log("Index map:")
            console.log(WPCEdit.variableSizedImage.indexMap)
            const plane = WPCEdit.fullFrameImage.plane;
            console.log("actual:");
            //WPCEdit.setRom(bytes);
    
            //WPCEdit.getChecksum();
            drawData(canvas,plane,null);
        }
    });
	reader.readAsArrayBuffer(file);
}
